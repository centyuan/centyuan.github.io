<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>centyuan Blog</title>
  
  
  <link href="https://centyuan.github.io/atom.xml" rel="self"/>
  
  <link href="https://centyuan.github.io/"/>
  <updated>2024-02-19T14:17:19.434Z</updated>
  <id>https://centyuan.github.io/</id>
  
  <author>
    <name>hlyuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>私有知识库构建方案</title>
    <link href="https://centyuan.github.io/2024/02/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A7%81%E6%9C%89%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88--%E5%8F%82%E8%80%83%E5%AD%A6%E4%B9%A0/"/>
    <id>https://centyuan.github.io/2024/02/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E7%A7%81%E6%9C%89%E7%9F%A5%E8%AF%86%E5%BA%93%E6%9E%84%E5%BB%BA%E6%96%B9%E6%A1%88--%E5%8F%82%E8%80%83%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-19T14:12:01.908Z</published>
    <updated>2024-02-19T14:17:19.434Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic4.zhimg.com/v2-a285cd76374ece7f56a7b7e450ae3fab_b.jpg" alt="LLM Evolutionary Tree"></p><h4 id="基础概述与拓展">基础概述与拓展</h4><blockquote><p>基于Transformer架构的模型主要三大分类:</p><p>1、autoregressive自回归模型（AR模型,仅解码器架构Decoder-only）：代表作GPT。本质上是一个left-to-right的语言模型。通常用于生成式任务，在长文本生成方面取得了巨大的成功，比如自然语言生成（NLG）领域的任务：摘要、翻译或抽象问答。当扩展到十亿级别参数时，表现出了少样本学习能力。缺点是单向注意力机制，在NLU任务中，无法完全捕捉上下文的依赖关系。</p><p>2、autoencoding自编码模型（AE模型,仅编码器架构Encoder-only）：代表作BERT。是通过某个降噪目标（比如MLM）训练的双向文本编码器。编码器会产出适用于NLU任务的上下文表示，但无法直接用于文本生成。</p><p>3、encoder-decoder（Seq2seq模型）：代表作T5。采用双向注意力机制，通常用于条件生成任务，比如文本摘要、机器翻译等</p><p><strong><a href="https://kexue.fm/archives/9529">为什么现在的LLM都是Decoder-only的架构？</a></strong></p><p><strong><a href="https://www.zhihu.com/question/588325646/answer/2940298964">为什么现在的LLM都是Decoder only的架构？</a></strong></p><p><strong><a href="https://zhuanlan.zhihu.com/p/406751681">生成式预训练模型：UniLM、BART、T5、GPT</a></strong></p><p><strong><a href="https://zhuanlan.zhihu.com/p/614766286">大语言模型调研汇总</a></strong></p><p><strong><a href="https://blog.csdn.net/qq_56591814/article/details/119759105">从循环神经网络、transformer到GPT2</a></strong></p><p><strong><a href="https://zhuanlan.zhihu.com/p/123211148">循环神经网络讲解（RNN/LSTM/GRU）</a></strong></p><p><strong><a href="https://zhuanlan.zhihu.com/p/637985826">LLMs模型速览上（GPTs、LaMDA、GLM/ChatGLM、PaLM/Flan-PaLM）</a></strong></p></blockquote><h4 id="ChatGPT-Fine-tune">ChatGPT +Fine-tune</h4><blockquote><p>ChatGPT的唯一方式就是官方说的微调出一个自己的模型，然后上传到ChatGPT，聊天时选用这个模型就好</p><p>参考文档:</p><p><a href="https://www.youtube.com/watch?v=mzz1ldrRcuc">如何微调你的chatgpt？fine-tuning实例教学</a></p><p><a href="https://platform.openai.com/docs/guides/fine-tuning/fine-tuning">openai fine-tuning guides</a></p></blockquote><h4 id="Azure-Studio-训练自己的GPT">Azure  Studio 训练自己的GPT</h4><blockquote><p><a href="https://learn.microsoft.com/zh-cn/azure/ai-services/openai/how-to/fine-tuning?tabs=turbo%2Cpython&amp;pivots=programming-language-studio">Azure OpenAI 微调模型文档</a></p></blockquote><h4 id="开源LLM-本地部署和微调">开源LLM + 本地部署和微调</h4><h5 id="开源大模型">开源大模型</h5><h6 id="ChatGLM">ChatGLM</h6><blockquote><p>清华和智谱公司搞的开源LLM,ChatGLM-6B 是一个开源的、支持中英双语的对话语言模型，基于 <strong><a href="https://link.zhihu.com/?target=https%3A//github.com/THUDM/GLM">General Language Model (GLM)</a></strong> 架构，具有 62 亿参数。结合模型量化技术，用户可以在消费级的显卡上进行本地部署（INT4 量化级别下最低只需 6GB 显存）。 ChatGLM-6B 使用了和 ChatGPT 相似的技术，针对中文问答和对话进行了优化。经过约 1T 标识符的中英双语训练，辅以监督微调、反馈自助、人类反馈强化学习等技术的加持，62 亿参数的 ChatGLM-6B 已经能生成相当符合人类偏好的回答。</p><p><strong><a href="https://luxiangdong.com/2023/10/30/chatglm3/#/ChatGLM3-6B%E6%9D%A5%E4%BA%86">ChatGLM3-6B针对RAG能力对比测试</a></strong></p><p><strong>github:</strong><a href="https://github.com/THUDM/ChatGLM3">ChatGLM3-6B</a></p><p><strong>官方体验地址:</strong><a href="https://www.chatglm.cn/">智谱清言</a></p><p><strong><a href="https://zhuanlan.zhihu.com/p/630134021">清华ChatGLM底层原理详解</a></strong></p><p><strong><a href="https://chatglm.cn/blog">ChatGLM-blog</a></strong></p></blockquote><h6 id="Alpaca">Alpaca</h6><blockquote><p>**Alpaca 7B是由Meta的LLaMA 7B模型通过52K指令微调得到的模型。Alpaca与OpenAI的text-davinci-003（GPT-3.5）表现类似，模型容量惊人的小，易于复现，且复现成本低（&lt;600美元）。**斯坦福发布了模型训练方法和数据，并打算在未来发布模型权重</p><p><strong><a href="https://github.com/tatsu-lab/stanford_alpaca">github-stanford-alpaca</a></strong></p><p><strong>github <a href="https://github.com/tloen/alpaca-lora">alpaca-lora</a></strong></p><p><strong>github <a href="https://github.com/ymcui/Chinese-LLaMA-Alpaca">Chinese-LLAMA-Alpaca</a></strong></p><p><a href="https://zhuanlan.zhihu.com/p/629998652">Alpaca-lora本地化部署实践</a></p></blockquote><h6 id="Vicuna">Vicuna</h6><blockquote><p>可达到 ChatGPT/Bard 90% 以上水平</p><p>来自加州大学伯克利分校、CMU、斯坦福大学和加州大学圣地亚哥分校的成员，共同推出了一个 Vicuna-13B 开源聊天机器人，由增强的数据集和易于使用、可扩展的基础设施支持。</p><p>以 GPT-4 为评判标准的初步评估显示，Vicuna-13B 达到了 OpenAI ChatGPT 和 Google Bard 90% 以上的质量，同时在 90% 以上的情况下超过了 LLaMA 和 Stanford Alpaca 等其他模型的表现。训练 Vicuna-13B 成本约为 300 美元。训练和服务代码，以及在线<a href="https://link.zhihu.com/?target=https%3A//www.oschina.net/action/GoToLink%3Furl%3Dhttps%3A%2F%2Fchat.lmsys.org%2F">演示</a>都是公开的，可用于非商业用途</p><p><strong><a href="https://zhuanlan.zhihu.com/p/633246784">本地化部署Vicuna模型-教程</a></strong></p><p><strong><a href="https://huggingface.co/lmsys/vicuna-13b-v1.5">Hugging Face 地址</a></strong></p><p><strong><a href="https://huggingface.co/lmsys">Hugging Face lmsys</a></strong></p><p><strong><a href="https://github.com/lm-sys/FastChat/tree/main/fastchat">FastChat-github</a></strong></p><p><strong><a href="https://link.zhihu.com/?target=https%3A//vicuna.lmsys.org/">Vicuna: An Open-Source Chatbot Impressing GPT-4 with 90% ChatGPT Quality</a></strong></p></blockquote><h6 id="LLaMA2">LLaMA2</h6><blockquote><p>Meta加微软，开源，免费开放给商业</p><p>Meta宣布和微软深化合作，正式推出新一代开源大型语言模型Llama 2，并将该模型免费开放给商业和研究使用。当时Meta表示LLaMA拥有超高性能，使用130亿参数的LLaMA在规模仅为ChatGPT 的十分之一的情况下，性能表现可以优于GPT-3。使用650 亿参数的 LLaMA 则可以与 DeepMind700 亿参数的 Chinchilla模型和谷歌5400 亿参数的 PaLM模型比肩</p><p><a href="https://www.bilibili.com/video/BV1oc411R7Fy/?vd_source=3a5c8a14693f88eaee1ab81779a7f8cb">lama2模型申请与本地部署详细</a></p></blockquote><h4 id="外部LLM-ChatGPT-ChatGLM3-向量数据库">外部LLM(ChatGPT/ChatGLM3) + 向量数据库</h4><blockquote><p>当我们有一份文档需要 GPT 处理时，例如客服培训资料或者操作手册，可以先将这份文档的所有内容转化成向量（这个过程称之为 Vector Embedding），然后当用户提出相关问题时，我们将用户的搜索内容转换成向量，然后在数据库中搜索最相似的向量，匹配最相似的几个上下文，最后将上下文返回给 GPT。这样不仅可以大大减少 GPT 的计算量，从而提高响应速度，更重要的是降低成本，并绕过 GPT 的 tokens 限制</p></blockquote><p>截至目前，汇总到目前的向量数据库有以下几种选择：</p><table><thead><tr><th style="text-align:left">向量数据库</th><th style="text-align:left">URL</th><th style="text-align:left">GitHub Star</th><th style="text-align:left">Language</th><th style="text-align:left">Cloud</th></tr></thead><tbody><tr><td style="text-align:left">chroma</td><td style="text-align:left"><a href="https://github.com/chroma-core/chroma">https://github.com/chroma-core/chroma</a></td><td style="text-align:left">7.4K</td><td style="text-align:left">Python</td><td style="text-align:left">❌</td></tr><tr><td style="text-align:left">milvus</td><td style="text-align:left"><a href="https://github.com/milvus-io/milvus">https://github.com/milvus-io/milvus</a></td><td style="text-align:left">21.5K</td><td style="text-align:left">Go/Python/C++</td><td style="text-align:left">✅</td></tr><tr><td style="text-align:left">pinecone</td><td style="text-align:left"><a href="https://www.pinecone.io/">https://www.pinecone.io/</a></td><td style="text-align:left">❌</td><td style="text-align:left">❌</td><td style="text-align:left">✅</td></tr><tr><td style="text-align:left">qdrant</td><td style="text-align:left"><a href="https://github.com/qdrant/qdrant">https://github.com/qdrant/qdrant</a></td><td style="text-align:left">11.8K</td><td style="text-align:left">Rust</td><td style="text-align:left">✅</td></tr><tr><td style="text-align:left">typesense</td><td style="text-align:left"><a href="https://github.com/typesense/typesense">https://github.com/typesense/typesense</a></td><td style="text-align:left">12.9K</td><td style="text-align:left">C++</td><td style="text-align:left">❌</td></tr><tr><td style="text-align:left">weaviate</td><td style="text-align:left"><a href="https://github.com/weaviate/weaviate">https://github.com/weaviate/weaviate</a></td><td style="text-align:left">6.9K</td><td style="text-align:left">Go</td><td style="text-align:left">✅</td></tr></tbody></table><blockquote><p><a href="https://www.bilibili.com/video/BV11a4y1c7SW/">向量数据库技术鉴赏</a></p></blockquote><h4 id="内部部署开源LLM-向量数据库">内部部署开源LLM + 向量数据库</h4><h6 id="Langchain-Chatchat">Langchain-Chatchat</h6><blockquote><p>Langchain-Chatchat（原Langchain-ChatGLM）基于 Langchain 与 ChatGLM 等语言模型的本地知识库问答</p><p><strong>github:</strong> <a href="https://github.com/chatchat-space/Langchain-Chatchat">Langchain-Chatchat</a></p><p><strong><a href="https://www.bilibili.com/video/BV13M4y1e7cN/?share_source=copy_web&amp;vd_source=e6c5aafe684f30fbe41925d61ca6d514">ChatGLM + LangChain 实践培训</a></strong></p><p><strong><a href="https://www.bilibili.com/video/BV1t8411y7fp/">ChatGLM+Langchain构建本地知识库，只需6G显存，支持实时上传文档</a></strong></p></blockquote><h6 id="privateGPT">privateGPT</h6><blockquote><p><strong>github:</strong> <a href="https://github.com/imartinez/privateGPT">privateGPT</a></p></blockquote><h6 id="FastGPT-不推荐">FastGPT(不推荐)</h6><blockquote><p><strong>github:</strong><a href="https://github.com/labring/FastGPT">FastGPT</a></p></blockquote><h6 id="其他方案">其他方案</h6><blockquote><p><a href="https://zhuanlan.zhihu.com/p/652685138">https://zhuanlan.zhihu.com/p/652685138</a></p></blockquote><h4 id="Other">Other</h4><h5 id="gpt对话分享">gpt对话分享</h5><blockquote><p><a href="https://sharegpt.com/">ShareGPT</a></p></blockquote><h5 id="大语言模型评估排行榜汇总">大语言模型评估排行榜汇总</h5><blockquote><p>LMSYS:<a href="https://chat.lmsys.org/?leaderboard">排行榜地址</a></p><blockquote><p>排行榜由Chatboot Arena、MT-Bench、MMLU主要基准组成。</p><ul class="lvl-2"><li class="lvl-2">Chatbot Arena- 一个大语言模型基准平台，以众包的方式进行匿名、随机的战斗。目前有 47K+ 用户的投票数据，采用Elo 评级方法进行计算结果。该项基准正在考虑增加更多的开源/闭源模型。</li><li class="lvl-2">MT-Bench- 一个具有挑战性的多轮问题集，使用 GPT-4 对模型响应进行评分。</li><li class="lvl-2">MMLU-（5-shot）——测试大语言模型的多任务准确性，该测试覆盖了基础数学、美国历史、计算机科学、法律等57项任务</li></ul></blockquote><p>c-Eval: <a href="https://cevalbenchmark.com/static/leaderboard.html">排行榜地址</a></p><blockquote><p>C-Eval是一个针对基础模型的综合中文评估套件。它由 13948 道多项选择题组成，涵盖 52 个不同学科和四个难度级别</p></blockquote><p>SuperCLUElyb: <a href="https://www.superclueai.com/">排行榜地址</a></p><blockquote><p>SuperCLUE-琅琊榜是一个中文大模型匿名对战平台，由中文语言理解测评基准开源社区CLUE的成员发起的，目前已有5.8K投票数据，使用Elo评级系统来计算模型的相对性能</p></blockquote></blockquote><p>instructor: <a href="https://github.com/jxnl/instructor">https://github.com/jxnl/instructor</a></p><p>cohere: <a href="https://cohere.com">https://cohere.com</a></p><p>AppAgent: <a href="https://github.com/mnotgod96/AppAgent">https://github.com/mnotgod96/AppAgent</a></p><h5 id="如何基于Embedding让大模型解决长文本-如PDF-的输入问题">如何基于Embedding让大模型解决长文本(如PDF)的输入问题</h5><blockquote><p>大多数打语言模型都无法处理过长的文本,如何让大模型&quot;读懂&quot;一个PDF尼</p><p>1.基于pdf创建向量Embedding,并在数据库中存储</p><p>2.提问Prompt，将问题向量去数据库检索相似的向量,将检索的相似的向量原文一起给到GPT</p><div class="code-wrapper"><pre><code class="hljs">准备搜索数据（仅一次）  收集：即获取你要用的数据，例如OpenAI的案例是下载几百篇有关2022年奥运会的维基百科文章  切块：将文档分成短小的、大多是自包含的部分以进行嵌入  嵌入：使用OpenAI API对每个部分数据获得embeddings结果  存储：存储embedding是（对于大型数据集，可以使用向量数据库）搜索（每次查询一次）  给定用户问题，从OpenAI API生成查询的embeddings  使用embeddings，按照与查询相关性对文本部分进行排序提问（每次查询一次）  将问题和最相关的部分插入到发送给GPT的消息中  返回GPT的答案</code></pre></div></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/v2-a285cd76374ece7f56a7b7e450ae3fab_b.jpg&quot; alt=&quot;LLM Evolutionary Tree&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;基础概述与拓展&quot;&gt;基础概述与拓展&lt;/h4</summary>
      
    
    
    
    <category term="机器学习" scheme="https://centyuan.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>提示词Prompt</title>
    <link href="https://centyuan.github.io/2024/02/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%8F%90%E7%A4%BA%E8%AF%8DPrompt%E5%B7%A5%E7%A8%8B--%E5%8F%82%E8%80%83%E5%AD%A6%E4%B9%A0/"/>
    <id>https://centyuan.github.io/2024/02/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%8F%90%E7%A4%BA%E8%AF%8DPrompt%E5%B7%A5%E7%A8%8B--%E5%8F%82%E8%80%83%E5%AD%A6%E4%B9%A0/</id>
    <published>2024-02-19T14:12:01.907Z</published>
    <updated>2024-02-19T14:17:07.318Z</updated>
    
    <content type="html"><![CDATA[<h4 id="提示工程技术">提示工程技术</h4><h5 id="指令">指令</h5><blockquote><p><strong>从明确的说明开始:</strong> prompt的顺序很重要，在提示开始时明确告诉模型的角色，以及你希望它执行的任务(<strong>角色分配和目标设置</strong>)，有助于生成更高质量的输出</p><p>使用定界符标识输入的不同部分: ```或&quot;&quot;&quot;或— 或&lt;&gt;</p></blockquote><div class="code-wrapper"><pre><code class="hljs asciidoc">为每周新闻稿编写简介，包括以下内容：<span class="hljs-bullet">- </span>我的公司名为 contoso<span class="hljs-bullet">- </span>兴高采烈的问候<span class="hljs-bullet">- </span>感谢团队在艰难的几个月里辛勤工作<span class="hljs-bullet">- </span>下一季度的积极前景<span class="hljs-bullet">- </span>由 SLT 签名</code></pre></div><h5 id="主要内容">主要内容</h5><blockquote><p>是模型正在处理或转换的某种文本,通常与指令一起使用</p></blockquote><div class="code-wrapper"><pre><code class="hljs applescript">Can you please <span class="hljs-keyword">tell</span> <span class="hljs-keyword">me</span> how <span class="hljs-keyword">to</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> museum?翻译为中文:</code></pre></div><h5 id="指示">指示</h5><blockquote><p><strong>引导输出:</strong> 帮助模型输出和格式化</p><p>1.在提示的末尾包含几个字词或短语，以所需形式的模型响应。</p><p>例如，使用 <code>“Here’s a bulleted list of key points:\n- ”</code> 等提示有助于输出的格式为项目符号列表</p><p>2.正负提示：积极的提示（“这样做”）负面提示（“不要这样做”）</p></blockquote><div class="code-wrapper"><pre><code class="hljs 1c">绩效评估是我们在 Contoso 实施的绩效 <span class="hljs-meta">&amp; 发展方法的核心组成部分。 […]</span>总结上述电子邮件</code></pre></div><h5 id="支持内容">支持内容</h5><blockquote><p>用于以某种方式影响输出的信息。 它与主要内容的不同之处在于，它不是任务的主要目标，但它通常与主要内容一起使用。 常见示例包括上下文信息，例如当前日期、用户名、用户偏好等</p></blockquote><div class="code-wrapper"><pre><code class="hljs applescript">研讨会列表：标题描述规划研讨会启动请加入我们以启动研讨会！ 听取我们的领导关于未来一年的跨组优先事项和学习内容。 此活动的邀请已发送给 [...] 中的每个人我的重要主题：提示工程、搜索、GPT 模型总结上述研讨会，按我的重要主题分组：或者生成一个包含三个虚构书名及其作者和类型的列表。以soN格式提供它们，并使用以下关键字:书<span class="hljs-built_in">id</span>、书名、作者、类型。</code></pre></div><h5 id="在末尾重复指令">在末尾重复指令</h5><blockquote><p>模型可能容易受到<strong>近因偏差</strong>的影响，这意味着提示结束时的信息对输出的影响可能比提示开头的信息更大。 因此，值得尝试的是，在提示结束时重复指令，并评估对你的用例的影响</p></blockquote><h5 id="分解任务">分解任务</h5><blockquote><p>如果任务分解为较小的步骤，模型的性能通常会更好。 例如，在前面引用的搜索查询提示中，可以调整提示的结构，以便首先指示模型提取相关事实，然后指示生成可用于验证这些事实的搜索查询</p></blockquote><h5 id="示例">示例</h5><blockquote><p><strong>思维链:</strong> 给出输入输出对,过示例更好地使模型能够仅根据当前推理的需求做出响应</p></blockquote><div class="code-wrapper"><pre><code class="hljs">头条：双城队的科雷亚将选择跳出合同，试水自由市场主题：棒球头条：卡塔尔世界杯将设有清醒区主题：足球头条：教练相信伤病不会破坏勇士队主题：</code></pre></div><h5 id="迭代Prompt策略">迭代Prompt策略</h5><blockquote><p>根据初始提示的输出，提出进一步的问题</p></blockquote><h5 id="Prompt的Prompt">Prompt的Prompt</h5><blockquote><p>让gpt参与进来改进提示</p></blockquote><div class="code-wrapper"><pre><code class="hljs">我现在可以使用什么提示来进一步帮助您完成此任务？</code></pre></div><h5 id="模型引导Prompt">模型引导Prompt</h5><blockquote><p>让模型给出完成具体任务所需要的信息</p></blockquote><div class="code-wrapper"><pre><code class="hljs excel">我希望你编写一个 Python 程序来管理我的客户信息，这些信息存储在Google <span class="hljs-built_in">Sheet</span>中。为了完成这项任务，请询问我您需要回答的任何问题</code></pre></div><h5 id="最佳做法">最佳做法</h5><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">1.尽量具体:尽可能少留解读空间。 限制操作空间。</span><span class="hljs-section">2.具有描述性:使用类比。</span><span class="hljs-section">3.强调:有时可能需要对模型进行重复操作。 在主要内容之前和之后提供说明，使用指令和指示等。</span><span class="hljs-section">4.给事项排序: 向模型呈现信息的顺序可能会影响输出。 你选择是在内容之前放置指令（“汇总以下内容...”）还是之后（“汇总以上...”）会影响输出。 即使是少样本示例的顺序也很重要。 这被称为“近因偏差”(末尾项目的记忆效果优于中间部分)。</span><span class="hljs-section">5.给模型一个“出路”:如果模型无法完成分配的任务，有时为模型提供备用路径可能会有所帮助。 例如，在对一段文本提出问题时，可以加入类似于“如果答案不存在，则回复‘未找到’”之类的内容。这可帮助模型避免生成错误的响应。</span></code></pre></div><h5 id="空间效率">空间效率</h5><h5 id="e-g">e.g.</h5><blockquote><p>已下面这些情感分析示例：<br>{示例:结果}<br>请问句子{query}的情感是</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">已知信息: 高俅为了让他的义子得到林冲的老婆，和陆谦设计陷害林冲。叫亲信假装成卖宝刀的在大街上卖宝刀给林冲，然后派人以看林冲新买的宝刀为名，将之骗到军事禁地白虎节堂。高俅以林冲拿刀到白虎堂刺杀他为由。</span>根据已知信息,回答我的问题,如果无法从中获得答案,请说<span class="hljs-string">&quot;根据已知信息无法回答该问题&quot;</span>,不允许在答案中添加编造成分,答案请用中文<span class="hljs-section">问题是: 为什么陷害林冲</span></code></pre></div><p>分辨gpt3还是gpt4</p><div class="code-wrapper"><pre><code class="hljs pgsql">你好，请回答，你是谁？你是gpt<span class="hljs-number">-4</span>吗？你的数据更新到什么时候？Hello, please answer, Who are you? Are you gpt<span class="hljs-number">-4</span>? <span class="hljs-keyword">When</span> <span class="hljs-keyword">is</span> your data up <span class="hljs-keyword">to</span> <span class="hljs-type">date</span>?你的知识截止时间是什么时候？<span class="hljs-keyword">When</span> <span class="hljs-keyword">is</span> your knowledge deadline?昨天的当天是明天的什么爸妈结婚，为啥没邀请我参加树上 <span class="hljs-number">10</span> 只鸟，打掉 <span class="hljs-number">1</span> 只，还剩几只？</code></pre></div><p>广告商</p><div class="code-wrapper"><pre><code class="hljs asciidoc">我想让你充当广告商。您将创建一个活动来推广您选择的产品或服务。<span class="hljs-bullet">- </span>您将选择目标受众，<span class="hljs-bullet">- </span>制定关键信息和口号，<span class="hljs-bullet">- </span>选择宣传媒体渠道，<span class="hljs-bullet">- </span>并决定实现目标所需的任何其他活动。我的第一个建议请求是“我需要帮助针对 18-30 岁的年轻人制作一种新型能量饮料的广告活动。</code></pre></div></blockquote><p><strong><a href="https://www.bilibili.com/video/BV1e8411o7NP">吴恩达最新《面向开发者的ChatGPT提示工程》</a></strong></p><p><strong><a href="https://github.com/PlexPt/awesome-chatgpt-prompts-zh">ChatGPT 中文调教指南</a></strong></p><p><strong><a href="https://www.promptingguide.ai/zh/introduction">提示工程指南</a></strong></p><p><strong><a href="https://github.com/wangxuqi/Prompt-Engineering-Guide-Chinese?tab=readme-ov-file#prompt-engineering-guide-chinese">Prompt-Engineering-Guide-Chinese</a></strong></p><p><strong><a href="https://cloud.tencent.com/developer/article/2350191">解读提示工程（Prompt Engineering）</a></strong></p><h5 id="other">other</h5><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;提示工程技术&quot;&gt;提示工程技术&lt;/h4&gt;
&lt;h5 id=&quot;指令&quot;&gt;指令&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;从明确的说明开始:&lt;/strong&gt; prompt的顺序很重要，在提示开始时明确告诉模型的角色，以及你希望它执行的任务(&lt;strong&gt;</summary>
      
    
    
    
    <category term="机器学习" scheme="https://centyuan.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>大模型主流应用RAG</title>
    <link href="https://centyuan.github.io/2024/02/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/LLM-RAG/"/>
    <id>https://centyuan.github.io/2024/02/19/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/LLM-RAG/</id>
    <published>2024-02-19T14:11:52.179Z</published>
    <updated>2024-02-19T14:18:59.698Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言">前言</h4><p>RAG(<strong>Retrieval Augmented Generation</strong>)，检索增强生成（RAG）指的是在使用LLMs回答问题之前，从外部知识库中检索相关信息，本质还是基于提示词工程，根据问题和相关文档进行检索，利用LLM的推理能力和向量数据库的进行语义相识度搜索，将与问题语义相识的文档带入Prompt。</p><blockquote><p>论文:<a href="https://arxiv.org/pdf/2312.10997.pdf">Retrieval-Augmented Generation for Large Language Models: A Survey</a></p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/673910600">LLM之RAG理论（二）| RAG综述论文详解</a></p><p><a href="https://zhuanlan.zhihu.com/p/676982074">大模型主流应用RAG的介绍——从架构到技术细节</a></p><p><a href="https://zhuanlan.zhihu.com/p/644079274">问答系统使用 Embedding 召回的局限及解决方案</a></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/131552592">基于LangChain+LLM的本地知识库问答：从企业单文档问答到批量文档问答</a></p><p><a href="https://blog.csdn.net/v_JULY_v/article/details/135257848">知识库问答LangChain+LLM的二次开发：商用时的典型问题及其改进方案</a></p><p><a href="https://www.zhihu.com/question/628651389/answer/3321989558?utm_psn=1730185514337189888">检索增强生成（RAG）有什么好的优化方案？</a></p><p><a href="https://zhuanlan.zhihu.com/p/676996307">Rerank——RAG中百尺竿头更进一步的神器，从原理到解决方案</a></p><p><strong>知识库</strong></p><p><strong>Embedding Model</strong></p><p><img src="https://github.com/chatchat-space/Langchain-Chatchat/blob/master/img/langchain+chatglm.png" alt="Embedding"></p><blockquote><p><a href="https://cloud.tencent.com/developer/article/1749306">用万字长文聊一聊 Embedding 技术原理</a></p></blockquote><p><strong>分类</strong></p><blockquote><ul class="lvl-1"><li class="lvl-2"><p>基于矩阵分解的方式，代表方式是SVD</p></li><li class="lvl-2"><p>基于内容的Embedding：1.静态Embedding(如 word2vec、GloVe 和 FastText), 2.动态Embedding(如 ELMo、GPT 和 BERT)</p></li><li class="lvl-2"><p>基于物品序列：item2vec</p></li><li class="lvl-2"><p>基于图的Embedding: 分为浅层图模型和深层图模型。浅层图模型有deepwalk、Node2vec、EGES，深层图模型有GCN、GraphSAGE等</p></li></ul></blockquote><blockquote><p>1.BAAI/bge-large-zh-v1.5         # HuggingFaceBgeEmbeddings(model=“BAAI/bge-large-zh-v1.5”)<br>2.GanymedeNil/text2vec-large-chinese/text2vec-base-chinese    #  开源版本<br>3.text-embedding-ada-002            # openai 需要付费<br>4.models/embedding-001            # google embedding</p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">result</span> = genai.embed_content(   <span class="hljs-attr">model</span>=<span class="hljs-string">&quot;models/embedding-001&quot;</span>,   <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;What is the meaning of life?&quot;</span>,   <span class="hljs-attr">task_type</span>=<span class="hljs-string">&quot;retrieval_document&quot;</span>,   <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;Embedding of single string&quot;</span>)</code></pre></div></blockquote><div class="code-wrapper"><pre><code class="hljs mathematica">嵌入算法<span class="hljs-operator">:</span>词嵌入<span class="hljs-built_in">Word</span> <span class="hljs-variable">Embedding</span><span class="hljs-operator">:</span> 句子<span class="hljs-operator">/</span>文档嵌入 <span class="hljs-variable">Sentence</span><span class="hljs-operator">/</span><span class="hljs-variable">Document</span> <span class="hljs-variable">Embedding</span>： 图嵌入<span class="hljs-built_in">Graph</span> <span class="hljs-variable">Embedding</span><span class="hljs-operator">:</span> 常用嵌入技术<span class="hljs-operator">:</span> <span class="hljs-variable">Word2Vec</span><span class="hljs-operator">:</span> <span class="hljs-variable">Google</span>开发的一种计算词向量的模型，有两种训练架构：<span class="hljs-variable">CBOW</span>（<span class="hljs-variable">Continuous</span> <span class="hljs-variable">Bag</span> <span class="hljs-variable">of</span> <span class="hljs-variable">Words</span>）和<span class="hljs-built_in">Skip</span><span class="hljs-operator">-</span><span class="hljs-variable">gram</span><span class="hljs-variable">Glove</span><span class="hljs-operator">:</span>斯坦福大学开发的模型，通过对词与词之间共现概率的矩阵进行分解来学习词向量<span class="hljs-variable">FastText</span>（<span class="hljs-variable">Global</span> <span class="hljs-built_in">Vectors</span> <span class="hljs-variable">for</span> <span class="hljs-built_in">Word</span> <span class="hljs-variable">Representation</span>）：<span class="hljs-variable">Facebook</span>开发，和<span class="hljs-variable">Word2Vec</span>类似，但它在训练过程中考虑了词的内部结构，即子词（<span class="hljs-variable">subwords</span>）信息<span class="hljs-variable">ELMo</span>（<span class="hljs-variable">Embeddings</span> <span class="hljs-variable">from</span> <span class="hljs-built_in">Language</span> <span class="hljs-variable">Models</span>）：使用双向<span class="hljs-variable">LSTM</span>训练得到的深度语言模型来生成词嵌入，能够捕捉词在不同语境中的用法。<span class="hljs-variable">BERT</span>（<span class="hljs-variable">Bidirectional</span> <span class="hljs-variable">Encoder</span> <span class="hljs-variable">Representations</span> <span class="hljs-variable">from</span> <span class="hljs-variable">Transformers</span>）：<span class="hljs-variable">Google</span>开发，使用了<span class="hljs-variable">Transformer</span>的<span class="hljs-variable">Encoder</span>来预训练深度双向表示，可以产生依赖于上下文的词嵌入。<span class="hljs-variable">Transformer</span>：不单独是一个嵌入模型，但其编码器和解码器都使用自注意力机制来处理序列信息，并被广泛用于生成上下文敏感的嵌入。每种嵌入技术都有它的特点和适用场景，选择哪种技术取决于具体的任务需求和资源限制。随着深度学习的发展，越来越多的嵌入模型被提出，并在各种自然语言处理任务中取得了优异的性能</code></pre></div><p><strong>向量数据库</strong></p><blockquote><p><a href="https://cloud.tencent.com/developer/article/2312534">向量数据库｜一文全面了解向量数据库的基本概念、原理、算法、选型</a></p></blockquote><p>推荐使用milvus</p><blockquote><p>collection-&gt;segment-&gt;entity(搜索中:会搜素Milvus每个segment,并返回合并后的结果)</p><p>Sharding-分片:单个 Collection 包含 2 个分片（Shard）</p><p>Partition-分区:分区是集合（Collection）的一个分区。Milvus 支持将收集数据划分为物理存储上的多个部分。这个过程称为分区，每个分区可以包含多个段</p><blockquote><p>分区的意义在于通过划定分区减少数据读取，而分片的意义在于多台机器上并行写入操作。</p><p>Milvus 允许您将大量向量数据分成少量分区。然后，搜索和其他操作可以限制在一个分区内以提高性能。</p></blockquote><table><thead><tr><th>Resource</th><th>Limit</th></tr></thead><tbody><tr><td>Partition</td><td>4,096</td></tr><tr><td>Shard</td><td>64</td></tr><tr><td>Field</td><td>64</td></tr><tr><td>Index</td><td>1</td></tr><tr><td>Entity</td><td>unlimited</td></tr></tbody></table></blockquote><table><thead><tr><th style="text-align:left">向量数据库</th><th style="text-align:left">URL</th><th style="text-align:left">GitHub Star</th><th style="text-align:left">Language</th><th style="text-align:left">Cloud</th></tr></thead><tbody><tr><td style="text-align:left">chroma</td><td style="text-align:left"><a href="https://github.com/chroma-core/chroma">https://github.com/chroma-core/chroma</a></td><td style="text-align:left">7.4K</td><td style="text-align:left">Python</td><td style="text-align:left">❌</td></tr><tr><td style="text-align:left">milvus</td><td style="text-align:left"><a href="https://github.com/milvus-io/milvus">https://github.com/milvus-io/milvus</a></td><td style="text-align:left">21.5K</td><td style="text-align:left">Go/Python/C++</td><td style="text-align:left">✅</td></tr><tr><td style="text-align:left">pinecone</td><td style="text-align:left"><a href="https://www.pinecone.io/">https://www.pinecone.io/</a></td><td style="text-align:left">❌</td><td style="text-align:left">❌</td><td style="text-align:left">✅</td></tr><tr><td style="text-align:left">qdrant</td><td style="text-align:left"><a href="https://github.com/qdrant/qdrant">https://github.com/qdrant/qdrant</a></td><td style="text-align:left">11.8K</td><td style="text-align:left">Rust</td><td style="text-align:left">✅</td></tr><tr><td style="text-align:left">typesense</td><td style="text-align:left"><a href="https://github.com/typesense/typesense">https://github.com/typesense/typesense</a></td><td style="text-align:left">12.9K</td><td style="text-align:left">C++</td><td style="text-align:left">❌</td></tr><tr><td style="text-align:left">weaviate</td><td style="text-align:left"><a href="https://github.com/weaviate/weaviate">https://github.com/weaviate/weaviate</a></td><td style="text-align:left">6.9K</td><td style="text-align:left">Go</td><td style="text-align:left">✅</td></tr></tbody></table><p><strong>影响最后实际效果的因素很多</strong></p><blockquote><p><strong>文本分割算法、embedding、向量的存储 搜索 匹配 召回 排序、大模型本身的生成能力</strong></p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>如何解决检索出错：embedding算法是关键之一<span class="hljs-symbol">2 </span>如何解决检索到相关但不根据知识库回答而是根据模型自有的预训练知识回答<span class="hljs-symbol">3 </span>如何针对结构化文档采取更好的chunk分割：基于规则<span class="hljs-symbol">4 </span>如何解决非结构化文档分割不够准确的问题：比如最好按照语义切分<span class="hljs-symbol">5 </span>如何确保召回结果的全面性与准确性：多路召回与最后的去重/精排<span class="hljs-symbol">6 </span>如何解决基于文档中表格的问答</code></pre></div></blockquote><blockquote><p>1.知识库本身语料的格式问题。如果有大量的短文本占据一行或冗余的数据，其表示的意思和信息很有限。因此在做本地知识库的时候，如果前后语句的语义是连贯的但又不在一行，我们需要人工将这些段落做一下整理，将短的文本凑到一行。尽量避免多行的短文本</p><p>2.文本分割的效果。很多文本分割的处理方式比较粗暴，就是单纯的按照标点如句号、分号来分割，这其实打断了原本比较连贯的文本，效果不一定好。当然，如果多加上前后几句文本，效果可能会有改善，但是这个度不好控制。比较理想的方式是采用语义分割</p><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-number">1.</span>中文标点符号(正则匹配标点符号)<span class="hljs-number">2.</span>Langchain 的 text_splitter<span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> CharacterTextSplitter  # 按照指定分隔符分割 默认<span class="hljs-string">&quot;\n\n&quot;</span>chunk_size=字符长度,chunk_overlap=重复字符(中间重复)<span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> MarkdownTextSplitter   # 沿着Markdown的标题,代码块或水平规则来分割文本<span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> PythonCodeTextSplitter  # 沿着Python类和方法的定义分割文本<span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter # 用于通用文本的分割器。它以一个字符列表为参数，尽可能地把所有的段落(然后是句子，然后是单词)放在一起<span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> TokenTextSplitter      # 根据openAI的token分割器<span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> SpacyTextSplitter   # spaCy是一个NLP领域的文本预处理Python库(包括分词,词性标注,依存分析,词性还原,命名实体识别)<span class="hljs-keyword">from</span> langchain.text_splitter <span class="hljs-keyword">import</span> NLTKTextSplitter   # 或处理html的分块方式<span class="hljs-number">3.</span>Spacy Text Splitter阿里达摩院开源的语义分割:nlp_bert_document-segmentation_chinese-base(https:<span class="hljs-comment">//modelscope.cn/models/damo/nlp_bert_document-segmentation_chinese-base/summary)</span>百度PaddleNLP</code></pre></div><p>3.Embedding 模型计算向量以及向量间的相似度，选择不同的模型，这个效果肯定会有差异</p><p>MTEB: Massive Text Embedding Benchmark 大规模文本嵌入基准测试</p><p>榜单地址:<a href="https://huggingface.co/spaces/mteb/leaderboard">https://huggingface.co/spaces/mteb/leaderboard</a></p><p>**<a href="https://github.com/huggingface/text-embeddings-inference">text-embeddings-inference</a>**加速推理</p><div class="code-wrapper"><pre><code class="hljs routeros">1.BAAI/bge-large-zh-v1.5         # HuggingFaceBgeEmbeddings(<span class="hljs-attribute">model</span>=<span class="hljs-string">&quot;BAAI/bge-large-zh-v1.5&quot;</span>)2.text2vec-large-chinese /text2vec-base-chinese    #  开源版本3.text-embedding-ada-002            # openai 需要付费4.models/embedding-001            # google embedding ```result = genai.embed_content(<span class="hljs-attribute">model</span>=<span class="hljs-string">&quot;models/embedding-001&quot;</span>,<span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;What is the meaning of life?&quot;</span>,<span class="hljs-attribute">task_type</span>=<span class="hljs-string">&quot;retrieval_document&quot;</span>,<span class="hljs-attribute">title</span>=<span class="hljs-string">&quot;Embedding of single string&quot;</span>)```5.GanymedeNil/text2vec-large-chinese</code></pre></div><p>4.大模型本身的能力，如现在 chatgpt-4 应该是傲视群雄，大模型基本是分为 chatgpt-4 和其他了。当然，使用 chatgpt 本身有信息安全问题以及费用问题。国内清华开源的 chatGLM-6b 是一个效果和性价比尚可的替代</p></blockquote><p><strong>1.语料处理</strong></p><blockquote><p><a href="https://github.com/run-llama/llama_index">llama_index</a></p><p>LlamaIndex (formerly GPT Index) is a data framework for your LLM applications</p></blockquote><p><strong>2.Text Splitter</strong></p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/670771195">适合的文本分块策略</a></p></blockquote><p><strong>3.Embedding选择</strong></p><p><strong>4.LLM选择和集成</strong></p><blockquote><p>打造智能客服：LLM和本地 知识库的完美协同原理</p><p><strong>召回文档怎么结合LLM</strong></p><ol><li class="lvl-3"><p>Sutff：将检索retrieval的相应文档给到prompt上下文context中</p></li><li class="lvl-3"><p>refine: 不断拿出一个检索的文档给到prompt的上下文，在将这个过程进行迭代</p></li><li class="lvl-3"><p>map reduce: 每个文档给到prompt得到答案，将所有答案合并再去推理</p></li><li class="lvl-3"><p>map re-rank: 每个文档的回答进行打分，rank后拿到最佳</p></li></ol></blockquote><p><strong>RAG优化</strong></p><p><strong>检索增强生成（RAG）有什么好的优化方案？</strong></p><blockquote><p><a href="https://www.zhihu.com/question/628651389/answer/3321989558?utm_psn=1730185514337189888">参考</a></p><p><strong>基础</strong></p><div class="code-wrapper"><pre><code class="hljs inform7">文档块切分:设置适当的块间重叠、多粒度文档块切分、基于语义的文档切分、文档块摘要\文本嵌入模型：基于新语料微调嵌入模型、动态表征。提示工程优化：优化模板增加提示词约束、提示词改写。大模型迭代：基于正反馈微调模型、量化感知训练、提供大context window的推理模型还可对query召回的文档块集合进行处理，比如：元数据过滤<span class="hljs-comment">[7]</span>、重排序减少文档块数量<span class="hljs-comment">[2]</span></code></pre></div><p><strong>RAG架构优化</strong></p><blockquote><p>经典的RAG架构中，context增强只用到了向量<a href="https://www.zhihu.com/search?q=%E6%95%B0%E6%8D%AE%E5%BA%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B">数据库</a>。这种方法有一些缺点，比如无法获取<a href="https://www.zhihu.com/search?q=%E9%95%BF%E7%A8%8B%E5%85%B3%E8%81%94&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B">长程关联</a>知识[3]、信息密度低（尤其当LLM context window较小时不友好）</p><p>那此题是否可解？答案是肯定的。一个比较好的方案是增加一路与向量库平行的KG（<a href="https://www.zhihu.com/search?q=%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B">知识图谱</a>）上下文增强策略。其技术架构图大致如下</p></blockquote></blockquote><p><img src="https://pic2.zhimg.com/100/v2-e5beb6ea9c08cdcf4ae4d5cdaefa0541_r.jpg" alt="RAG"></p><p><img src="https://pic4.zhimg.com/v2-cfeaf2d1288b2851752a6a463c35b427_b.jpg" alt="RAG技术细节"></p><p><strong>RAG(更适合知识密集性场景)三种类型</strong></p><blockquote><p><strong>Naive RAG</strong></p><p><strong>Advanced RAG</strong></p><p><strong>Modular RAG</strong></p></blockquote><p><strong>论文地址</strong><a href="https://arxiv.org/pdf/2312.10997.pdf">https://arxiv.org/pdf/2312.10997.pdf</a></p><p><strong>RAG的成功要求</strong>：一个成功的RAG系统应该有两个主要功能：检索必须找到与用户查询最相关的文档，生成必须有效地利用这些文档来回答用户查询</p><blockquote><p><strong>Naive RAG索引问题优化: 增强数据粒度,优化索引结构,添加元数据,对齐优化,混合索引</strong></p><p><strong>索引问题优化的目标是: 提高文本的标准化(去除不相关的信息和特殊字符)/一致性(消除实体和术语中的歧义和重复或冗余的信息),确保事实的准确性以及上下文的丰富性,以保证RAG系统的性能</strong></p><p><strong>1.数据索引</strong></p><div class="code-wrapper"><pre><code class="hljs awk">包括:数据提取和清洗原始数据<span class="hljs-regexp">/分块chunking(LLM有上下文长度限制)/</span>向量化embedding 等方面</code></pre></div><blockquote><p><strong>1.增强数据粒度</strong></p><div class="code-wrapper"><pre><code class="hljs gcode">采用不同的分块方式<span class="hljs-number">1.</span>基本的字符数分割<span class="hljs-comment">(chunk_overlap中间重复字符)</span><span class="hljs-number">2.</span>标点符号<span class="hljs-comment">(换行符/句号)</span>/文档的固有结构分割<span class="hljs-comment">(Markdown/html)</span><span class="hljs-number">3.</span>语义分割<span class="hljs-comment">(SpacyTextSplitter/NLTKTextSplitter/或阿里达摩院nlp_bert_document-segmentation_chinese-base分割模型)</span></code></pre></div><p><strong>2.优化索引结构</strong></p><div class="code-wrapper"><pre><code class="hljs">调整块的大小,尽可能收集相关信息并减少上下文噪声</code></pre></div><p><strong>3.添加元数据信息</strong></p><div class="code-wrapper"><pre><code class="hljs">将引用的元数据嵌入到块中,例如用户筛选的日期和目的，通过过滤元数据来提高效率和相关性</code></pre></div><p><strong>4.对齐优化</strong></p><div class="code-wrapper"><pre><code class="hljs">解决对齐问题和之间的差异文件,包括引入假设问题,创建适合每个文档回答的问题</code></pre></div></blockquote><p><strong>2.检索召回retriever(5-10个Topk最优)</strong></p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">检索召回存在的问题:主要是检索质量问题</span>1.精度低,检索集中并非所有块都与查询相关2.低召回率,所有相关块没有全部被召回,LLM没有获得足够的上下文</code></pre></div><blockquote><p><strong>1.元数据过滤</strong></p><div class="code-wrapper"><pre><code class="hljs">过滤掉不相关的文本,以便于减小检索范围提高检索结果的相关性</code></pre></div><p><strong>2.混合搜索</strong></p><div class="code-wrapper"><pre><code class="hljs">利用不同搜索技术的优势,如基于关键字的搜索,语义搜索和矢量搜素来适应不同的查询类型和信息需求,确保对最相关和上下文丰富的信息的一致搜索。混合检索可以作为检索策略的有力补充，增强RAG管道的整体性能</code></pre></div><p><strong>3.重排</strong></p><div class="code-wrapper"><pre><code class="hljs"></code></pre></div></blockquote><p><strong>3.生成generation</strong></p><blockquote><p><strong>1.Prompt压缩</strong></p><div class="code-wrapper"><pre><code class="hljs">压缩不相关的上下文，突出关键段落，减少整体上下文长度</code></pre></div><p><strong>2.指令instruction优化</strong></p><div class="code-wrapper"><pre><code class="hljs gcode">将问题进行分解<span class="hljs-comment">(查询转换)</span><span class="hljs-number">1.</span>查询语句的相关性复制:<span class="hljs-comment">(通过LLM将查询转换为多个相似但不同的查询)</span><span class="hljs-number">2.</span>并发的向量搜素:<span class="hljs-comment">(对所有查询执行并发的向量搜索)</span><span class="hljs-number">3.</span>智能重新排名:<span class="hljs-comment">(聚合和细化所有结果使用倒数排序融合RRF)</span>倒数排序融合<span class="hljs-comment">(RRF)</span>：是一种将具有不同相关性指标的多个结果集组合成单个结构集的方法,组合来自不同查询的排名,非常适合组合来自可能具有不同分数尺度或分布的查询结果倒数排序融合RRF<span class="hljs-comment">(https://zhuanlan.zhihu.com/p/664143375)</span></code></pre></div><p><strong>3.嵌入Prompt</strong></p><div class="code-wrapper"><pre><code class="hljs vhdl"><span class="hljs-number">1</span>.stuff:所有检索的文档填充到<span class="hljs-keyword">Context</span>中<span class="hljs-number">2</span>.refine: 迭代：每个文档填充到<span class="hljs-keyword">Context</span><span class="hljs-number">3</span>.<span class="hljs-keyword">map</span> reduce: 合并推理(每个文档填充到<span class="hljs-keyword">Context</span>给LLM得到Answer)<span class="hljs-number">4</span>.<span class="hljs-keyword">map</span> re-rank: 每个文档的回答进行打分，rank后拿到最佳</code></pre></div><p><strong>3.专家LLMs选择</strong></p></blockquote></blockquote><p><strong>参考项目</strong></p><blockquote><p><strong>LangChain-ChagGLM-Webui</strong></p><p><a href="https://github.com/X-D-Lab/LangChain-ChatGLM-Webui/tree/master">https://github.com/X-D-Lab/LangChain-ChatGLM-Webui/tree/master</a></p><p><strong>Langchain-Chatchat</strong></p><p><a href="https://github.com/chatchat-space/Langchain-Chatchat?tab=readme-ov-file">https://github.com/chatchat-space/Langchain-Chatchat?tab=readme-ov-file</a></p><p><strong>LongChainKBQA</strong></p><p><a href="https://github.com/wp931120/LongChainKBQA">https://github.com/wp931120/LongChainKBQA</a></p><p><a href="https://blog.csdn.net/zyqytsoft/article/details/131159174">https://blog.csdn.net/zyqytsoft/article/details/131159174</a></p><p><a href="https://blog.csdn.net/sunhua93/article/details/102764783">一文读懂BERT</a></p><p><a href="https://zhuanlan.zhihu.com/p/50443871">NLP的巨人肩膀</a></p><p><a href="https://www.youtube.com/watch?v=ugWDIIOHtPA&amp;list=PLJV_el3uVTsOK_ZK5L0Iv_EQoL1JefRL4&amp;index=61">李宏毅Transformer</a></p><div class="code-wrapper"><pre><code class="hljs sqf"><span class="hljs-number">1</span>.AIGC生成系统<span class="hljs-number">2</span>.GPT和AI <span class="hljs-built_in">agent</span><span class="hljs-number">3</span>.知识库问答</code></pre></div></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;前言&quot;&gt;前言&lt;/h4&gt;
&lt;p&gt;RAG(&lt;strong&gt;Retrieval Augmented Generation&lt;/strong&gt;)，检索增强生成（RAG）指的是在使用LLMs回答问题之前，从外部知识库中检索相关信息，本质还是基于提示词工程，根据问题和相关文档进</summary>
      
    
    
    
    <category term="机器学习" scheme="https://centyuan.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="ML" scheme="https://centyuan.github.io/tags/ML/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://centyuan.github.io/2023/12/25/%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/"/>
    <id>https://centyuan.github.io/2023/12/25/%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/%E5%8A%A0%E5%AF%86%E4%B8%8E%E5%AE%89%E5%85%A8/</id>
    <published>2023-12-25T13:19:46.917Z</published>
    <updated>2023-12-25T13:19:20.892Z</updated>
    
    <content type="html"><![CDATA[<h4 id="编码算法">编码算法</h4><h5 id="ASCII">ASCII</h5><blockquote><p>字母<code>A</code>的编码是十六进制的<code>0x41</code>，字母<code>B</code>是<code>0x42</code></p><p>ASCII编码最多只能有128个字符，要想对更多的文字进行编码，就需要用Unicode。而中文的中使用Unicode编码就是<code>0x4e2d</code>，使用UTF-8则需要3个字节编码x</p></blockquote><h5 id="UTF-8">UTF-8</h5><blockquote><div class="code-wrapper"><pre><code class="hljs leaf">&gt;<span class="hljs-punctuation">#</span> Unicode,以&amp;<span class="hljs-punctuation">#</span><span class="hljs-params">(&amp;#<span class="hljs-variable">X</span>为<span class="hljs-variable">Unicode</span> 16进制)</span>&gt;<span class="hljs-punctuation">#</span> &amp;<span class="hljs-punctuation">#</span>20170;&amp;<span class="hljs-punctuation">#</span>20599;&gt;<span class="hljs-punctuation">#</span> UTF-8,以\u开头&gt;e = &#x27;\u89e3\u6790\u5305\u5f02\u5e38&#x27;&gt;<span class="hljs-punctuation">#</span> 显示为中文&gt;print(&quot;\u89e3\u6790\u5305\u5f02\u5e38&quot;)  <span class="hljs-punctuation">#</span> 解析包异常&gt;<span class="hljs-punctuation">#</span> 显示为中文&gt;result = e.encode(&quot;utf-8&quot;).decode()</code></pre></div></blockquote><h5 id="URL编码">URL编码</h5><blockquote><p>URL编码是浏览器发送数据给服务器时使用的编码，它通常附加在URL的参数部分，</p><p>例如：<a href="https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87">https://www.baidu.com/s?wd=%E4%B8%AD%E6%96%87</a></p><p>之所以需要URL编码，是因为出于兼容性考虑，很多服务器只识别ASCII字符。但如果URL中包含中文、日文这些非ASCII字符怎么办？不要紧，URL编码有一套规则：</p><ul class="lvl-1"><li class="lvl-2"><p>如果字符是<code>A</code><sub>`Z`，`a`</sub><code>z</code>，<code>0</code>~<code>9</code>以及<code>-</code>、<code>_</code>、<code>.</code>、<code>*</code>，则保持不变；</p></li><li class="lvl-2"><p>如果是其他字符，先转换为UTF-8编码，然后对每个字节以<code>%XX</code>表示。</p></li></ul><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># URL编码,以%开头</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">import json</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">from urllib import parse</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">ss = <span class="hljs-string">&quot;http://www.baidu.com&quot;</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">print</span>(parse.quote(ss))  <span class="hljs-comment"># 编码:http%3A//www.baidu.com</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># print(parse.unquote()) 解码</span></span></code></pre></div></blockquote><h5 id="Base64编码">Base64编码</h5><blockquote><p>base64 编码,以=结尾</p><p>URL编码是对字符进行编码，表示成<code>%xx</code>的形式，而Base64编码是对二进制数据进行编码，表示成文本格式</p></blockquote><h4 id="哈希算法">哈希算法</h4><blockquote><p>哈希算法（Hash）又称摘要算法（Digest），它的作用是：对任意一组输入数据进行计算，得到一个固定长度的输出摘要</p><p>哈希算法最重要的特点就是：</p><ul class="lvl-1"><li class="lvl-2"><p>相同的输入一定得到相同的输出；</p></li><li class="lvl-2"><p>不同的输入大概率得到不同的输出。</p></li></ul></blockquote><p><strong>常用的哈希算法有：</strong></p><table><thead><tr><th style="text-align:left">算法</th><th style="text-align:left">输出长度（位）</th><th style="text-align:left">输出长度（字节）</th></tr></thead><tbody><tr><td style="text-align:left">MD5</td><td style="text-align:left">128 bits</td><td style="text-align:left">16 bytes</td></tr><tr><td style="text-align:left">SHA-1</td><td style="text-align:left">160 bits</td><td style="text-align:left">20 bytes</td></tr><tr><td style="text-align:left">RipeMD-160</td><td style="text-align:left">160 bits</td><td style="text-align:left">20 bytes</td></tr><tr><td style="text-align:left">SHA-256</td><td style="text-align:left">256 bits</td><td style="text-align:left">32 bytes</td></tr><tr><td style="text-align:left">SHA-512</td><td style="text-align:left">512 bits</td><td style="text-align:left">64 bytes</td></tr></tbody></table><p>根据碰撞概率，哈希算法的输出长度越长，就越难产生碰撞，也就越安全。</p><p><strong>使用哈希口令时，还要注意防止彩虹表攻击</strong></p><blockquote><p>什么是彩虹表呢？上面讲到了，如果只拿到MD5，从MD5反推明文口令，只能使用暴力穷举的方法</p><p>可以采取措施来抵御彩虹表攻击，方法是对每个口令额外添加随机数，这个方法称之为加盐（salt）</p></blockquote><h4 id="HAMC算法">HAMC算法</h4><blockquote><p>Hmac算法就是一种基于密钥的消息认证码算法，它的全称是Hash-based Message Authentication Code，是一种更安全的消息摘要算法。</p><p>我们回顾一下哈希算法：</p><div class="code-wrapper"><pre><code class="hljs isbl">&gt;<span class="hljs-variable">digest</span> = <span class="hljs-function"><span class="hljs-title">hash</span>(<span class="hljs-variable">input</span>)</span></code></pre></div><p>正是因为相同的输入会产生相同的输出，我们加盐的目的就在于，使得输入有所变化：</p><div class="code-wrapper"><pre><code class="hljs isbl">&gt;<span class="hljs-variable">digest</span> = <span class="hljs-function"><span class="hljs-title">hash</span>(<span class="hljs-variable">salt</span> + <span class="hljs-variable">input</span>)</span></code></pre></div><p>这个salt可以看作是一个额外的“认证码”，同样的输入，不同的认证码，会产生不同的输出。因此，要验证输出的哈希，必须同时提供“认证码”</p></blockquote><p>Hmac算法总是和某种哈希算法配合起来用的。例如，我们使用MD5算法，对应的就是HmacMD5算法，它相当于“加盐”的MD5：</p><div class="code-wrapper"><pre><code class="hljs pgsql">HmacMD5 ≈ md5(secure_random_key, <span class="hljs-keyword">input</span>)</code></pre></div><p>因此，HmacMD5可以看作带有一个安全的key的MD5。使用HmacMD5而不是用MD5加salt，有如下好处：</p><ul class="lvl-0"><li class="lvl-2"><p>HmacMD5使用的key长度是64字节，更安全；</p></li><li class="lvl-2"><p>Hmac是标准算法，同样适用于SHA-1等其他哈希算法；</p></li><li class="lvl-2"><p>Hmac输出和原有的哈希算法长度一致。</p></li></ul><blockquote><p>总结:Hmac算法是一种标准的基于密钥的哈希算法，可以配合MD5、SHA-1等哈希算法，计算的摘要长度和原摘要算法长度相同,Hmac本质上就是把key混入摘要的算法。验证此哈希时，除了原始的输入数据，还要提供key</p></blockquote><h4 id="对称加密">对称加密</h4><blockquote><p>对称加密算法就是传统的用一个密码进行加密和解密</p></blockquote><p>常用的对称加密算法有：</p><table><thead><tr><th style="text-align:left">算法</th><th style="text-align:left">密钥长度</th><th style="text-align:left">工作模式</th><th style="text-align:left">填充模式</th></tr></thead><tbody><tr><td style="text-align:left">DES</td><td style="text-align:left">56/64</td><td style="text-align:left">ECB/CBC/PCBC/CTR/…</td><td style="text-align:left">NoPadding/PKCS5Padding/…</td></tr><tr><td style="text-align:left">AES</td><td style="text-align:left">128/192/256</td><td style="text-align:left">ECB/CBC/PCBC/CTR/…</td><td style="text-align:left">NoPadding/PKCS5Padding/PKCS7Padding/…</td></tr><tr><td style="text-align:left">IDEA</td><td style="text-align:left">128</td><td style="text-align:left">ECB</td><td style="text-align:left">PKCS5Padding/PKCS7Padding/…</td></tr></tbody></table><p>密钥长度直接决定加密强度，而工作模式和填充模式可以看成是对称加密算法的参数和格式选择</p><p><strong>AES:</strong></p><blockquote><p>ECB模式是最简单的AES加密模式，它只需要一个固定长度的密钥，固定的明文会生成固定的密文，这种一对一的加密方式会导致安全性降低，更好的方式是通过CBC模式，它需要一个随机数作为IV参数，这样对于同一份明文，每次生成的密文都不同</p></blockquote><h4 id="非对称加密算法">非对称加密算法</h4><blockquote><p>非对称加密就是加密和解密使用的不是相同的密钥：只有同一个公钥-私钥对才能正常加解密</p><p>非对称加密的典型算法就是RSA算法，它是由Ron Rivest，Adi Shamir，Leonard Adleman这三个哥们一起发明的，所以用他们仨的姓的首字母缩写表示。</p></blockquote><p>因为非对称加密的缺点就是运算速度非常慢，比对称加密要慢很多</p><blockquote><p>非对称加密实际上应用在第一步，即加密“AES口令”。这也是我们在浏览器中常用的HTTPS协议的做法，即浏览器和服务器先通过RSA交换AES口令，接下来双方通信实际上采用的是速度较快的AES对称加密，而不是缓慢的RSA非对称加密</p></blockquote><h4 id="签名算法">签名算法</h4><blockquote><p>如果使用私钥加密，公钥解密是否可行呢？实际上是完全可行的。</p><p>不过我们再仔细想一想，私钥是保密的，而公钥是公开的，用私钥加密，那相当于所有人都可以用公钥解密。这个加密有什么意义？</p><p>数字签名:  私钥加密得到的密文实际上就是数字签名，要验证这个签名是否正确，只能用私钥持有者的公钥进行解密验证。使用数字签名的目的是为了确认某个信息确实是由某个发送方发送的，任何人都不可能伪造消息，并且，发送方也不能抵赖。</p><p>在实际应用的时候，签名实际上并不是针对原始消息，而是针对原始消息的哈希进行签名</p></blockquote><h5 id="常用数字签名算法有">常用数字签名算法有</h5><ul class="lvl-0"><li class="lvl-2"><p>MD5withRSA</p></li><li class="lvl-2"><p>SHA1withRSA</p></li><li class="lvl-2"><p>SHA256withRSA</p></li></ul><p>它们实际上就是指定某种哈希算法进行RSA签名的方式。</p><h5 id="DSA签名">DSA签名</h5><p>除了RSA可以签名外，还可以使用DSA算法进行签名。DSA是Digital Signature Algorithm的缩写，它使用ElGamal数字签名算法。</p><p>DSA只能配合SHA使用，常用的算法有：</p><ul class="lvl-0"><li class="lvl-2"><p>SHA1withDSA</p></li><li class="lvl-2"><p>SHA256withDSA</p></li><li class="lvl-2"><p>SHA512withDSA</p></li></ul><p>和RSA数字签名相比，DSA的优点是更快。</p><h5 id="ECDSA签名">ECDSA签名</h5><p>椭圆曲线签名算法ECDSA：Elliptic Curve Digital Signature Algorithm也是一种常用的签名算法，它的特点是可以从私钥推出公钥。比特币的签名算法就采用了ECDSA算法，使用标准椭圆曲线secp256k1。BouncyCastle提供了ECDSA的完整实现</p><h4 id="数字证书">数字证书</h4><blockquote><p>我们知道，摘要算法用来确保数据没有被篡改，非对称加密算法可以对数据进行加解密，签名算法可以确保数据完整性和抗否认性，把这些算法集合到一起，并搞一套完善的标准，这就是数字证书。</p><p>因此，数字证书就是集合了多种密码学算法，用于实现数据加解密、身份认证、签名等多种功能的一种安全标准。</p><p>数字证书可以防止中间人攻击，因为它采用链式签名认证，即通过根证书（Root CA）去签名下一级证书，这样层层签名，直到最终的用户证书。而Root CA证书内置于操作系统中，所以，任何经过CA认证的数字证书都可以对其本身进行校验，确保证书本身不是伪造的</p><p>我们在上网时常用的HTTPS协议就是数字证书的应用。浏览器会自动验证证书的有效性</p></blockquote><p>参考:<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1304227859136546">加密与安全</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;编码算法&quot;&gt;编码算法&lt;/h4&gt;
&lt;h5 id=&quot;ASCII&quot;&gt;ASCII&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;字母&lt;code&gt;A&lt;/code&gt;的编码是十六进制的&lt;code&gt;0x41&lt;/code&gt;，字母&lt;code&gt;B&lt;/code&gt;是&lt;code&gt;0x42&lt;/co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Python项目中日志处理</title>
    <link href="https://centyuan.github.io/2023/12/09/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/Python%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/"/>
    <id>https://centyuan.github.io/2023/12/09/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/Python%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%97%A5%E5%BF%97%E5%A4%84%E7%90%86/</id>
    <published>2023-12-09T07:34:22.249Z</published>
    <updated>2023-12-09T07:34:03.312Z</updated>
    
    <content type="html"><![CDATA[<h4 id="logging">logging</h4><blockquote><p>logging是Python内置的标准模块，可以设置输出日志等级，时间，其他信息(进程ID,进程名词,线程ID,线程名称)</p><p>参考:</p><p><a href="https://docs.python.org/zh-cn/3/library/logging.html">Python的日志记录工具</a></p><p><a href="https://docs.python.org/zh-cn/3/howto/logging.html">Python日志指南</a></p></blockquote><h5 id="输出到控制台">输出到控制台</h5><div class="code-wrapper"><pre><code class="hljs haml">import logging logging.basicConfig(level=logging.DEBUG,format=&quot;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s:%(message)s&quot;)logging.info(&quot;this is a loggging info message&quot;)logging.debug(&quot;this is a loggging debug message&quot;)logging.warning(&quot;this is loggging a warning message&quot;)logging.error(&quot;this is an loggging error message&quot;)logging.critical(&quot;this is a loggging critical message&quot;)-<span class="language-ruby">-----------------------------------------------------------------------------------------------------------</span>logging.DEBUG：DEBUG以上的日志会输出format常用格式说明:<span class="hljs-tag">%(levelno)<span class="hljs-selector-tag">s</span></span>: 日志级别<span class="hljs-tag">%(levelname)<span class="hljs-selector-tag">s</span></span>: 日志级别名词<span class="hljs-tag">%(pathname)<span class="hljs-selector-tag">s</span></span>: 执行程序的路径,就是sys.argv[0]<span class="hljs-tag">%(funcName)<span class="hljs-selector-tag">s</span></span>: 当前函数<span class="hljs-tag">%(lineno)<span class="hljs-selector-tag">d</span></span>: 当前行号<span class="hljs-tag">%(asctime)<span class="hljs-selector-tag">s</span></span>: 时间<span class="hljs-tag">%(thread)<span class="hljs-selector-tag">d</span></span>: 线程ID<span class="hljs-tag">%(threadName)<span class="hljs-selector-tag">s</span></span>: 线程名称<span class="hljs-tag">%(process)<span class="hljs-selector-tag">d</span></span>: 进程ID<span class="hljs-tag">%(message)<span class="hljs-selector-tag">s</span></span>: 日志信息</code></pre></div><h5 id="输出到文件">输出到文件</h5><div class="code-wrapper"><pre><code class="hljs makefile">import logging <span class="hljs-comment"># 1.创建一个logger</span>logger = logging.getLogger()<span class="hljs-comment"># 2.创建一个handler，用于日志写入文件</span>log_file = <span class="hljs-string">&quot;logging-test.log&quot;</span>fh = logging.FileHandler(log_file)fh.setLevel(logging.DEBUG)<span class="hljs-comment"># 3.定义handler输出格式</span>log_formatter = logging.Formatter( <span class="hljs-string">&quot;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&quot;</span>)fh.setFormatter(log_formatter)<span class="hljs-comment"># 4.将logger添加到handler里面</span>logger.addHandler(fh)logger.info(<span class="hljs-string">&quot;Finish&quot;</span>)</code></pre></div><h5 id="输出到ES">输出到ES</h5><blockquote><p>三种方案:</p><p>​flume+kafka+spark准实时写入ES</p><p>​logging+CMRESHanlder实时写入ES</p><p>​通过python elasticsearch包</p></blockquote><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> cmreslogging.handlers import CMRESHandler  # noqa: E402logger = logging.getLogger(<span class="hljs-string">&quot;ES_log&quot;</span>)logger.setLevel(logging.INFO)<span class="hljs-comment"># ES handler </span>cm_handler = CMRESHandler( hosts=[&#123;<span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>: 9200&#125;],    <span class="hljs-attribute">es_index_name</span>=<span class="hljs-string">&quot;log_index&quot;</span>,    <span class="hljs-attribute">auth_type</span>=CMRESHandler.AuthType.NO_AUTH,)    logger.addHandler(cm_handler)logger.<span class="hljs-built_in">info</span>(<span class="hljs-string">&quot;ES日志&quot;</span>)</code></pre></div><h5 id="logging项目中使用">logging项目中使用</h5><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> logging<span class="hljs-keyword">from</span> logging.handlers <span class="hljs-keyword">import</span> RotatingFileHandler  <span class="hljs-comment"># noqa: E402</span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span>:    __instance = <span class="hljs-literal">None</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):        <span class="hljs-keyword">if</span> cls.__instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            cls.__instance = <span class="hljs-built_in">object</span>.__new__(cls)        <span class="hljs-keyword">return</span> cls.__instance    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self,</span><span class="hljs-params">             log_path:<span class="hljs-built_in">str</span> = <span class="hljs-literal">None</span>, </span><span class="hljs-params">             log_name: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;application.log&quot;</span>, </span><span class="hljs-params">             log_level=logging.DEBUG,</span><span class="hljs-params">             To_console = <span class="hljs-literal">True</span>,</span><span class="hljs-params">             To_file = <span class="hljs-literal">False</span>,</span><span class="hljs-params">             To_ES = <span class="hljs-literal">False</span>,</span><span class="hljs-params">             ROTA = <span class="hljs-literal">False</span>,</span><span class="hljs-params">             </span>):        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> log_path:            log_path = os.getcwd() + os.sep + <span class="hljs-string">&quot;logs&quot;</span>+os.sep <span class="hljs-comment"># os.sep 路径分隔符(Linux使用/,window使用\)</span>              log_formatter = logging.Formatter(            fmt=<span class="hljs-string">&quot;[%(asctime)s.%(msecs)03d][%(levelname)s][%(filename)s][%(lineno)d] %(message)s&quot;</span>,            datefmt=<span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,        )        self.logger = logging.getLogger()        self.logger.setLevel(log_level)        <span class="hljs-comment"># 1.console流handler 输出到sys.stdout,sys.stderr输出到控制台</span>        <span class="hljs-keyword">if</span> To_console:            stream_handler = logging.StreamHandler()            stream_handler.setFormatter(log_formatter)            self.logger.addHandler(stream_handler)                <span class="hljs-comment"># 2.文件</span>        <span class="hljs-keyword">if</span> To_file:            <span class="hljs-comment">#self.logger = logging.getLogger(log_path)</span>            <span class="hljs-keyword">if</span> ROTA: <span class="hljs-comment"># RotatingFileHandler 循环日志文件</span>                rota_log = log_path+<span class="hljs-string">&quot;rotate_&quot;</span>+log_name                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(rota_log):                    os.makedirs(rota_log)                rotate_handler = RotatingFileHandler(rota_log, maxBytes=<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">50</span>, backupCount=<span class="hljs-number">5</span>)                <span class="hljs-comment"># maxBytes 最大字节数,backupCount 超过最大字节数保留5个</span>                self.logger.addHandler(rotate_handler)            <span class="hljs-keyword">else</span>:                log_file = log_path+log_name                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(log_file):                    os.makedirs(log_file)                fh = logging.FileHandler(log_file)                fh.setFormatter(log_formatter)                self.logger.addHandler(fh)        <span class="hljs-comment"># TimedRotatingFileHandler 定时生成新日志文件</span>        <span class="hljs-comment"># 3. ES</span>        <span class="hljs-keyword">if</span> To_ES:            cm_handler = CMRESHandler(                hosts=[&#123;<span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>: <span class="hljs-number">9200</span>&#125;],                es_index_name=<span class="hljs-string">&quot;log_index&quot;</span>,                auth_type=CMRESHandler.AuthType.NO_AUTH,            )            cm_handler.setFormatter(log_formatter)            self.logger.addHandler(cm_handler)             <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_logger</span>(<span class="hljs-params">self</span>):        <span class="hljs-keyword">return</span> self.loggerlogger = Logger().get_logger()logger.info(<span class="hljs-string">&quot;日志&quot;</span>)</code></pre></div><blockquote><p><strong>RotatingFileHandler:</strong></p><p>自带的日志处理器,将日志写入到指定的文件中，并控制文件大小和数量,实现日志轮转(及备份旧日志并创建新的日志)</p><div class="code-wrapper"><pre><code class="hljs routeros">&gt;<span class="hljs-keyword">from</span> logging.handlers import RotatingFileHandler&gt;RotatingFileHandler(filename, <span class="hljs-attribute">mode</span>=<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-attribute">maxBytes</span>=0, <span class="hljs-attribute">backupCount</span>=0, <span class="hljs-attribute">encoding</span>=None, <span class="hljs-attribute">delay</span>=<span class="hljs-literal">False</span>)&gt;filename: 指定日志的文件路径和名称&gt;model: 模式,可选值为 ‘a’ 或 ‘w’,追加或覆盖&gt;maxBytes: 单个日志文件调度最大大小(单位:字节),当日志文件达到该大小时，会自动备份旧日志并创建新的日志文件。默认值为 0，表示不限制日志文件大小。&gt;backupCount: 备份文件数量,当生成的日志文件数量超过该数目时，会自动删除旧的备份日志文件。默认值为 0，表示不备份&gt;encoding: 日志文件的编码格式,默认为None,表示使用系统编码&gt;delay: <span class="hljs-literal">True</span>(延时打开文件,即在第一次写入日志时才打开日志文件),<span class="hljs-literal">False</span>(表示在初始化时即打开日志文件。默认值为 <span class="hljs-literal">False</span>)&gt;为maxBytes指定了&gt;0的值，则mode指定为w是没有意义的，RotatingFileHandler初始化时会自动将mode强制改为a</code></pre></div><p><strong>TimedRotatingFileHandler:</strong></p><p>与RotatingFileHandler类似,按照时间对文件进行切割，例如每天或每个小时生成一个新的日志文件</p><div class="code-wrapper"><pre><code class="hljs routeros">&gt;<span class="hljs-keyword">from</span> logging.handlers import TimedRotatingFileHandler&gt;TimedRotatingFileHandler(filename, <span class="hljs-attribute">when</span>=<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-attribute">interval</span>=1, <span class="hljs-attribute">backupCount</span>=0, <span class="hljs-attribute">encoding</span>=None, <span class="hljs-attribute">delay</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">utc</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">atTime</span>=None)&gt;filename: 指定日志文件的路径和名称&gt;when: 日志轮转的时间间隔，可选值为 ‘S’、‘M’、‘H’、‘D’、‘W’ 和 ‘midnight’，分别表示秒、分、时、天、周和每天的午夜；默认值为 ‘midnight’，即每天的午夜轮转，值不区分大小&gt;internal: 时间间隔的数量，默认为 1；例如，当 <span class="hljs-attribute">when</span>=‘D’ 且 <span class="hljs-attribute">interval</span>=7 时，表示每周轮转一次&gt;backupCount: 备份文件数目；当生成的日志文件数量超过该数目时，会自动删除旧的备份日志文件；默认值为 0，表示不备份&gt;encoding: 日志文件的编码格式，默认为 None，表示使用系统默认编码&gt;delay: 可选值为 <span class="hljs-literal">True</span> 和 <span class="hljs-literal">False</span>；当为 <span class="hljs-literal">True</span> 时，表示延时打开文件，即在第一次写入日志时才打开日志文件；当为 <span class="hljs-literal">False</span> 时，表示在初始化时即打开日志文件；默认值为 <span class="hljs-literal">False</span>&gt;utc：是否使用 UTC 时间，默认为 <span class="hljs-literal">False</span>，表示使用本地时间&gt;atTime：用来设置轮转时间，格式为 ‘%H:%M:%S’，默认为午夜 12 点；需要注意的是该参数仅在when为W/midnight时有效</code></pre></div></blockquote><h5 id="异步线程写日志">异步线程写日志</h5><blockquote><p>独立开启线程，将待写的日志信息异步放入队列，做到日志输出不影响主流程性能</p><p>参考:</p><p><a href="https://www.cnblogs.com/yindianhaidao/p/13201074.html">异步线程写日志</a></p></blockquote><h4 id="logru"><a href="https://github.com/Delgan/loguru">logru</a></h4><blockquote><p>支持Python3.5以上，日志格式输出更加优雅简洁,配置将半结构化和彩色化的输出记录到标准错误，可以使用装饰器对<strong>异常进行追溯</strong></p><p>参考:</p><p><a href="https://loguru.readthedocs.io/en/stable/overview.html">logru docs</a></p><p><a href="https://www.cnblogs.com/struggleMan/p/17510494.html#%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%AE%89%E5%85%A8">logru doc汉化</a></p></blockquote><h4 id="logbook"><a href="https://github.com/getlogbook/logbook">logbook</a></h4><blockquote><p>自称是 Python 标准库<code>logging</code>模块的酷炫替代品，其目的是让日志记录变得有趣</p><p>参考：</p><p><a href="https://logbook.readthedocs.io/en/stable/">Logbook docs</a></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;logging&quot;&gt;logging&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;logging是Python内置的标准模块，可以设置输出日志等级，时间，其他信息(进程ID,进程名词,线程ID,线程名称)&lt;/p&gt;
&lt;p&gt;参考:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https</summary>
      
    
    
    
    <category term="Python从入门到放弃" scheme="https://centyuan.github.io/categories/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    
    
    <category term="Logging" scheme="https://centyuan.github.io/tags/Logging/"/>
    
  </entry>
  
  <entry>
    <title>项目管理Note</title>
    <link href="https://centyuan.github.io/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    <id>https://centyuan.github.io/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/</id>
    <published>2023-12-06T14:28:49.986Z</published>
    <updated>2023-12-06T14:34:15.738Z</updated>
    
    <content type="html"><![CDATA[<h4 id="软件项目管理的定义">软件项目管理的定义</h4><blockquote><p>软件工程的活动包括<strong>需求分析、问题定义、可行性研究、设计、实现、确认、支持</strong>等，所有这些活动都必须进行管理，软件项目管理贯穿于软件工程的演化过程之中</p></blockquote><h4 id="软件项目管理的过程">软件项目管理的过程</h4><blockquote><p>管理的过程分为如下几个步骤</p></blockquote><h5 id="启动软件项目"><strong>启动软件项目</strong></h5><blockquote><p>启动软件项目是指必须明确项目的目标和范围、考虑可能的解决方案以及技术和管理上的要求等，这些信息是软件项目运行和管理的基础</p></blockquote><h5 id="制定项目计划"><strong>制定项目计划</strong></h5><blockquote><p>软件项目一旦启动，就必须制定项目计划。计划的制定以下面的活动为依据。</p><ul class="lvl-1"><li class="lvl-2">估算项目所需要的工作量</li><li class="lvl-2">估算项目所需要的资源</li><li class="lvl-2">根据工作量制定进度计划，继而进行资源分配</li><li class="lvl-2">做出配置管理计划</li></ul><p>在项目计划制定的时候，我们通常会使用到甘特图或者是路线图进行可视化跟踪展示</p></blockquote><h5 id="跟踪及控制项目计划"><strong>跟踪及控制项目计划</strong></h5><blockquote><p>在软件项目进行过程中，严格遵守项目计划，对于一些不可避免的变更，要进行适当的控制和调整，但要确保计划的完整性和一致性</p></blockquote><h5 id="评审项目计划"><strong>评审项目计划</strong></h5><blockquote><p>对项目计划的完成程度进行评审。并对项目的执行情况进行评价</p></blockquote><h5 id="编写管理文档"><strong>编写管理文档</strong></h5><blockquote><p>项目管理人员根据软件合同确定软件项目是否完成。项目一旦完成，则检查项目完成的结果和中间记录文档，并把所有的结果记录下来形成文档而保存</p></blockquote><h4 id="软件项目管理的内容">软件项目管理的内容</h4><blockquote><p>软件项目管理的内容涉及上述软件项目管理过程的方方面面，概括起来主要有如下几项</p></blockquote><h5 id="目标">目标</h5><blockquote><p>需求管理的目的是在客户和处理客户需求的软件项目组之间建立对客户需求的共同理解。需求管理的目标有两个：</p><ul class="lvl-1"><li class="lvl-2">使软件需求受控，并建立供软件工程和管理使用的需求基线。</li><li class="lvl-2">使软件计划、产品和活动与软件需求保持一致。</li></ul></blockquote><h5 id="原则">原则</h5><blockquote><p>为进行有效的需求管理，一般要遵循如下五条原则：</p><ul class="lvl-1"><li class="lvl-2">需求一定要分类管理：进行软件项目管理的时候，一定要将软件需求分出层次。不同层次需求的侧重点、描述方式、管理方式是不同的。</li><li class="lvl-2">需求必须分优先级：在软件项目中，如果出现过多的需求，通常会导致项目超出预算和预定进度，最终导致软件项目的失败，因而需求的优先级可能比需求本身更加重要。</li><li class="lvl-2">需求必须文档化：需求必须有文档记录。该文档必须是正确的、最新的、可管理的、可理解的，是经过验证的，是在受控的状态下变更的。</li><li class="lvl-2">需求一旦变化，就必须对需求变更的影响进行评估：无论需求变化的程度如何，只要需求变化了就必须进行评估，这是基本的原则。</li><li class="lvl-2">需求管理必须与需求工程的其他活动紧密整合：进行需求管理一定不能脱离需求工程，需求工程包括了需求获取、需求分析、需求描述、需求验证、需求管理，因而需求管理必须与前面的几个需求阶段保持密切相关。</li></ul></blockquote><h5 id="需求管理活动">需求管理活动</h5><blockquote><p>需求管理是一个对系统需求变更了解和控制的过程。初始需求导出的同时就启动了需求管理规划， 一旦形成了需求文档的草稿版本， 需求活动就开始了</p></blockquote><h4 id="软件项目估算与进度管理">软件项目估算与进度管理</h4><h5 id="软件项目估算">软件项目估算</h5><blockquote><p>软件项目估算包括工作量估算和成本估算两个方面。软件估算作为软件项目管理的一项重要内容，是确保软件项目成功的关键因素。估算是指通过预测构造软件项目所需要的工作量的过程。初步的估算用于确定软件项目的可行性，详细的估算用于指导项目计划的制定。</p></blockquote><h5 id="软件规模——工作分解结构"><strong>软件规模——工作分解结构</strong></h5><blockquote><p>对软件项目进行估算遇到的第一个问题就是软件规模，即软件的程序量。软件规模是软件工作量的主要影响因素。软件项目的设计有一个分层结构，这一分层结构就对应着工作分解结构（WBS,Work Breakdown Structure ），它将软件过程和软件产品结构联系起来。图是一个典型的WBS结构</p></blockquote><h5 id="软件项目成本估算">软件项目成本估算</h5><blockquote><p>成本估算是对完成软件项目所需费用的估计和计划，是软件项目计划中的一个重要组成部分。成本估算步骤如下：</p><ol><li class="lvl-3">建立目标</li><li class="lvl-3">规划需要的数据和资源</li><li class="lvl-3">确定软件需求</li><li class="lvl-3">拟定可行的细节</li><li class="lvl-3">运用多种独立的技术和原始资料</li><li class="lvl-3">比较并迭代各个估算值</li><li class="lvl-3">随访跟踪</li></ol></blockquote><h5 id="软件项目进度管理">软件项目进度管理</h5><blockquote><ul class="lvl-1"><li class="lvl-2"><p>制定项目计划：项目计划在项目开始的时候制定，并随着项目的进展不断发展。软件项目计划的要素包括目标、合理的概念设计、工作分解结构、规模设计、工作量估计和项目进度安排。项目计划为管理者提供了根据计划定期评审和跟踪项目进展的基础。</p></li><li class="lvl-2"><p>进度安排：在确定了项目的资源（总成本及时间等）后，把其分配到各个项目开发阶段中，即确定项目的进度。项目各阶段的工作量可以参考表</p></li></ul></blockquote><h4 id="软件开发过程">软件开发过程</h4><h4 id="软件开发各生命周期阶段与文档、角色间的关系">软件开发各生命周期阶段与文档、角色间的关系</h4><blockquote><p><strong>项目经理：</strong></p><p>管理整个项目过程。包括制定计划、项目跟踪、项目成员的角色分配、协调、管理，软件配置管理，文挡标准制定，文挡审查等。</p><p><strong>技术经理：</strong></p><p>对项目的技术及方案总体把握，配合系统分析员做一些大的工作，审查系统分析员做好的各种设计，对系统分析员提出的问题一起去解决。</p><p><strong>系统分析员：</strong></p><p>和项目经理一起参与需求分析，形成需求规格说明文档。根据需求规格说明文挡做概要设计，形成概要设计文挡。根据概要设计文挡做详细设计文挡。在编码及测试阶段协助程序员、测试人员编码和测试。</p><p><strong>程序员：</strong></p><p>根据详细设计文档进行编码，并对自己的代码模块进行单元测试，形成单元测试报告。</p><p><strong>测试员：</strong></p><p>在编码完成后，做系统测试，形成测试报告，通知项目经理测试结果。</p><p><strong>文档管理员：</strong></p><p>对所有项目文档进行管理，保持所有文挡的同步与一致</p></blockquote><h4 id="软件项目的实施阶段">软件项目的实施阶段</h4><blockquote><p>整个项目分为三个阶段：开始阶段、实施阶段、收尾阶段。</p><h3 id="1、项目开始阶段">1、项目开始阶段</h3><ul class="lvl-1"><li class="lvl-2"><p>确定项目组成员</p></li><li class="lvl-2"><p>确定组织结构</p></li><li class="lvl-2"><p>确定项目组成员在项目中的具体角色及其工作职责。</p></li></ul><h3 id="2、项目实施阶段">2、项目实施阶段</h3><ul class="lvl-1"><li class="lvl-2"><p>项目经理制定项目开发计划。</p></li><li class="lvl-2"><p>准备基础设施（软件、文档摸板、工具）。</p></li><li class="lvl-2"><p>按照项目开发计划由项目经理组织实施。</p></li><li class="lvl-2"><p>每周定期召开项目组全体成员会议。会议内容包括：阶段总结、当前项目开发进度、下阶段计划安排、当前遇到的各种困难（技术上的、或组织上的或人力上的等等） 。</p></li><li class="lvl-2"><p>项目组成员每周撰写周计划、周总结。</p></li><li class="lvl-2"><p>项目所有相关文档、代码要保持同步更新及版本一致。</p></li><li class="lvl-2"><p>项目组成员在每天开始工作前，下载所有最新文档与代码。在每天工作结束后上传所有自己更新的文档与代码。</p></li></ul><h3 id="3、项目收尾阶段">3、项目收尾阶段</h3><ul class="lvl-1"><li class="lvl-2"><p>总结</p></li><li class="lvl-2"><p>文件存档</p></li></ul></blockquote><blockquote><p>参考<a href="https://zhuanlan.zhihu.com/p/586370096">软件项目管理</a></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;软件项目管理的定义&quot;&gt;软件项目管理的定义&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;软件工程的活动包括&lt;strong&gt;需求分析、问题定义、可行性研究、设计、实现、确认、支持&lt;/strong&gt;等，所有这些活动都必须进行管理，软件项目管理贯穿于软件工程的演化过程之中&lt;</summary>
      
    
    
    
    <category term="软件工程与项目管理" scheme="https://centyuan.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="项目管理" scheme="https://centyuan.github.io/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>开发模式Note</title>
    <link href="https://centyuan.github.io/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    <id>https://centyuan.github.io/2023/12/06/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E4%B8%8E%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/</id>
    <published>2023-12-06T13:51:10.851Z</published>
    <updated>2023-12-06T14:34:51.084Z</updated>
    
    <content type="html"><![CDATA[<h4 id="瀑布型开发模式-Waterfall">瀑布型开发模式(Waterfall)</h4><blockquote><p>在1970年由温斯顿·罗伊斯（Winston Royce）提出，作为最早出现的软件开发模型,它把项目分解成一系列可管理的步骤或阶段。每个阶段完成后才能进行到下一个阶段。这种类型的开发过程通常用于大型系统中</p><p>例如:</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.需求分析Requirements</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.设计Design</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.开发编码Development</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.测试Testing</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">5.部署Deployment</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">6.维护Maintenance</span></code></pre></div><p>优点：易于理解与规划;明确性强，便于人员间分工合作,有利于控制风险;适合于大规模复杂应用场景。</p><p>缺点：不适合小规模或者快速原型制作;缺乏灵活度，难以适应变化;对团队协作要求高。</p></blockquote><p><img src="https://pic1.zhimg.com/v2-f2d80010dd243fcf0be79b4912336928_b.jpg" alt="瀑布"></p><h4 id="迭代式开发">迭代式开发</h4><blockquote><p>迭代式开发也被称为迭代增量式开发，是一种与传统的瀑布式开发相反的软件开发过程，它弥补了传统开发方式的一些弱点，有更高的成功率。在迭代式开发中，整个开发工作被组织为一系列短小的、固定长度的小项目，每次迭代都包括需求分析、设计、实现与测试。采用迭代式开发时，工作可以在需求被完整地确定之前启动，并在一次迭代种完成系统的一部分功能或业务，再通过客户的反馈来细化需求，并开始新一轮的迭代。</p><p>迭代式开发有如下特点：</p><ul class="lvl-1"><li class="lvl-2"><p>每次只设计和实现产品的一部分。</p></li><li class="lvl-2"><p>一步一步地完成。</p></li><li class="lvl-2"><p>每次设计和实现一个阶段，这叫作一个迭代。</p></li></ul></blockquote><p><img src="https://pic2.zhimg.com/v2-d298635b8709380c43d2586e89743f49_b.jpg" alt="迭代"></p><h4 id="螺旋式开发">螺旋式开发</h4><blockquote><p>螺旋式开发是由巴利·波姆（Barry Boehm）在1988年正式发表的软件系统开发模型，它兼顾了快速原型的迭代特征及瀑布模型的系统化和严格监控，其最大的特点是引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减少损失。同时，在每个迭代阶段构建原型是螺旋模型用来减少风险的方法。螺旋模型更适合大型的昂贵的系统级的软件开发，一开始应用的规模很小，当项目被定义得更好、更稳定时逐渐展开。其核心在于不需要在刚开始时就把所有事情都定义清楚，可以先定义最重要的功能去实现它，然后听取客户的意见，再进入下一个阶段，入此不断循环、重复，直到得到满意的产品。螺旋模型在很大程度上是一种风险驱动的方法体系，因为在每个阶段及经常发生的循环之前，都必须先进行风险评估</p><p>螺旋式开发有如下特点：</p><ul class="lvl-1"><li class="lvl-2"><p>制定计划：确定软件目标，选定实施方案，弄清楚项目开发的限制条件。</p></li><li class="lvl-2"><p>风险分析：分析、评估所选方案，考虑如何识别和消除风险。</p></li><li class="lvl-2"><p>实施工程：实施软件开发和验证。</p></li><li class="lvl-2"><p>客户评估：评价开发工作，提出修正建议，制定下一步计划</p></li></ul></blockquote><p><img src="https://pic2.zhimg.com/v2-c2d09dc5651246d63e7670ca05537939_b.jpg" alt="螺旋"></p><h4 id="敏捷开发-Agile">敏捷开发(Agile)</h4><blockquote><p>“敏捷”一词来源于2001年在美国犹他州举行的雪鸟会议，在这次会议上，Martin Fowler，Jim Highsmith等17位著名的软件开发专家提出了Agile(敏捷开发)这个概念，并共同签署了《敏捷宣言》。敏捷宣言的主要价值观如下：</p><ul class="lvl-1"><li class="lvl-2">个体和互动高于流程和工具。</li><li class="lvl-2">工作的软件高于详尽的文档。</li><li class="lvl-2">客户合作高于合同谈判。</li><li class="lvl-2">响应变化高于遵循计划</li></ul><p>简单地说，“敏捷开发”是把原有模式下的大需求拆分成多个小需求，并采用小步快跑的方式进行开发与迭代，原来的一个大环改为一个个小的闭环。在新迭代开始前，产品经理会将需求拆分成具体的开发任务，研发人员进行任务认领，每日站会进行任务的review，直到开发完成，发布新的可用版本</p><p>注重客户反馈及时调整，采用短平快的迭代开发形式去达成目标。其核心思想就是“速度比完美重要”。</p><p>优点：更加关注用户价值；响应能力强；允许变更；具有良好沟通机制。</p><p>缺点：过于重视短期利益，范围仅限于开发和测试阶段，并没有覆盖到部署端,加重了运维的负担，因为运维追求的目标是稳定，而频繁的变更往往就是出现问题的根源，这与敏捷的理念产生了冲突。</p></blockquote><p><img src="https://pic3.zhimg.com/v2-29bcef534ecc9ddc2c60eb6f3ff47356_b.jpg" alt="敏捷"></p><h4 id="DevOps">DevOps</h4><blockquote><p>DevOps 运动始于 2007 年左右，当时技术社区对于开发与运维之间分开工作的方式，随着越来越多问题的出现，大家逐渐认识到，为了按时交付软件产品和服务，开发和运维必须紧密合作。2009年10月，在比利时根特市举办了首届DevOpsDays大会，这届会议出乎意料的成功，并引起了人们广泛的讨论。后面为了在Twitter上更好的传播，由DevOpsDays缩写为DevOps。</p><p>DevOps的英文发音是/ de’vops/，这个词是由Development和Operations两个词的简写组合而成。</p><p>在维基百科中对于DevOps的定义是：一种重视“软件开发人员（Dev）”和“IT运维技术人员（Ops）”之间沟通合作的文化、运动或惯例， 通过自动化“软件交付”和“架构变更”的流程，来使得构建、测试、发布软件能够更加地快捷、频繁和可靠。可以说，DevOps的出现正是为了打破开发和运维人员之间的壁垒，让两者得以更加通畅的沟通，以清除部门间存在的对立,DevOps完善了敏捷开发存在的短板，实现了真正的闭环。</p><p>优点：显著提升生产力；增强可靠性和安全性；简化操作和监控任务。</p><p>缺点：初始投资大；学习曲线陡峭；不太适用于高度定制的解决方案</p></blockquote><p><img src="https://pic2.zhimg.com/v2-908b1911e1e41b750a987ffd3e1471d9_b.jpg" alt="DevOps"></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;瀑布型开发模式-Waterfall&quot;&gt;瀑布型开发模式(Waterfall)&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;在1970年由温斯顿·罗伊斯（Winston Royce）提出，作为最早出现的软件开发模型,它把项目分解成一系列可管理的步骤或阶段。每个阶段完成后</summary>
      
    
    
    
    <category term="软件工程和项目管理" scheme="https://centyuan.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%92%8C%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
    
    <category term="开发模式" scheme="https://centyuan.github.io/tags/%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>签名/证书/CA</title>
    <link href="https://centyuan.github.io/2023/12/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E6%9D%82%E7%83%A9/%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6CA/"/>
    <id>https://centyuan.github.io/2023/12/06/%E6%9C%89%E8%B6%A3%E7%9A%84%E6%9D%82%E7%83%A9/%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6CA/</id>
    <published>2023-12-06T12:45:07.373Z</published>
    <updated>2023-12-07T12:09:22.409Z</updated>
    
    <content type="html"><![CDATA[<h4 id="公钥私钥">公钥私钥</h4><blockquote><p>是概念上的区分，发出去的为公钥，自己手上的为私钥，实际生成RSA秘钥时，其中一份包含另一份的完整信息成为私钥，且公私钥都可以做加密方和解密方</p></blockquote><h4 id="CA">CA</h4><blockquote><p>CA是证书的签发机构，被称为证书授权中心，它是公钥基础设施（Public Key Infrastructure，PKI）的核心。<strong>CA是负责签发证书、认证证书、管理已颁发证书的机关。CA 拥有一个证书（内含公钥和私钥）</strong></p><p>**根证书:**是CA认证中心给自己颁发的证书，是信任链的起始点，安装根证书意味对这个CA认证中心的信任</p></blockquote><h4 id="证书">证书</h4><blockquote><p>采用第三方(CA证书商)担保，确保证书中发出来的公钥是服务器提供的，在用证书中服务器的公钥加密信息与服务器通信</p><p><strong>证书颁发过程</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.服务器把公钥和个人信息发送给证书商CA,证书商用私钥对其签名,形成CA证书，确保证书内的公钥是服务器提供的</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.证书商把CA证书给服务器</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.用户访问服务器,先向服务器申请证书，并用证书商的公钥解密，拿到服务器的信息和服务器公钥</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.用户使用服务器公钥和服务器通信(由于非对称加密较慢,实际中服务器和客户端会相互协商，指定某对称加密秘钥来进行通信加密)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">5.用证书中的服务器公钥加密通信加密使用的对称秘钥</span></code></pre></div><p><strong>如何对数字证书进行校验</strong></p><div class="code-wrapper"><pre><code class="hljs stata">&gt;要验证数字证书的真伪，就需要找到签发这个证书的<span class="hljs-keyword">CA</span>证书，要验证<span class="hljs-keyword">CA</span>证书的真伪则需要找到签发<span class="hljs-keyword">CA</span>证书的<span class="hljs-keyword">CA</span>证书，就这样一直找到根证书</code></pre></div><p>CA的公钥一般来说由浏览器开发商内置在浏览器或操作系统的内部。于是，该前提条件在各种信任机制上，基本保证成立</p></blockquote><h4 id="SSL证书">SSL证书</h4><blockquote><p>称为服务器 SSL 证书，是遵守 SSL 协议的一种数字证书，由全球信任的证书颁发机构(CA)验证服务器身份后颁发。将 SSL 证书安装在网站服务器上，可实现网站身份验证和数据加密传输双重功能。SSL 协议及其继任者 TLS 协议，是一种实现网络通信加密的安全协议，可在客户端(浏览器)和服务器端(网站)之间建立一条加密通道，保证数据在传输过程中不被窃取或篡改</p><div class="code-wrapper"><pre><code class="hljs abnf">这个证书总共有 <span class="hljs-number">3</span> 个测评等级，其中，EV SSL 证书最高，OV SSL 证书其次，而 DV SSL 证书最弱。DV SSL 证书只验证域名所有权，仅为加密传输信息的作用，并不能证明网站的真实身份<span class="hljs-comment">;OV SSL 证书是需要验证网站所有单位的真实身份的标准型 SSL 证书，而 EV SSL 证书则是遵循全球统一严格身份验证标准办法的 SSL 证书，是目前业界最高安全级别的 SSL 证书。其中，OV SSL 主要在国内网站应用，而 EV SSL 则在国外网站应用更多。靠谱的商用网站一般都会部署 EV SSL 证书或 OV SSL 证书，绝对不会部署已经被欺诈网站滥用的 DV SSL 证书</span></code></pre></div></blockquote><h5 id="SSL证书分类和文件种类">SSL证书分类和文件种类</h5><blockquote><p><strong>证书的分类</strong></p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">CA证书: 就是根证书。如果不安全该证书，即使安装了其他证书，浏览器也会提示不安全，但是在单向https认证中，该证书的安装是可选的。</span><span class="hljs-section">服务器证书: SSL证书中必须要安装的证书之一，通过证书的key生成csr文件，然后再通过CA证书签名，生成服务器的证书。</span><span class="hljs-section">客户端证书: 在双向https验证中，就必须有客户端证书，生成方式同服务器证书一样，单向证书则不用生成</span></code></pre></div><p><strong>证书的格式</strong></p><div class="code-wrapper"><pre><code class="hljs jboss-cli">CER：服务器证书、CA根证书链。CRT证书的微软型式，可以在微软系统环境下将<span class="hljs-string">.crt</span>转换为<span class="hljs-string">.cer</span>（<span class="hljs-string">.both</span> DER编码的<span class="hljs-string">.cer</span>，或base64 [PEM]编码的<span class="hljs-string">.cer</span>）。KEY：私钥。KEY扩展名用于私钥。 键可以被编码为二进制DER或ASCII PEM。CRT：中间证书、证书文件。可以是二进制格式，可以是文本格式，与 <span class="hljs-string">.DER</span> 格式相同，不保存私钥。常用于 Apache，Nginx 等。CRT扩展用于证书。 证书可以被编码为二进制DER或ASCII PEM。 CER和CRT扩展几乎是同义词。 最常见的于Unix 或类Unix系统。CSR：证书签名请求，认证请求由三个主要部分组成:认证请求信息、签名算法标识符和认证请求信息上的数字签名。第一部分包含重要信息，包括公钥。请求者的签名防止实体请求他人公钥的伪造证书。因此，生成CSR需要私钥，但私钥不是CSR的一部分。PEM：一般是文本格式，可保存证书，可保存私钥。DER <span class="hljs-string">.CER</span>：文件是二进制格式，只保存证书，不保存私钥。PFX <span class="hljs-string">.P12</span>：二进制格式，同时包含证书和私钥，一般有密码保护。JKS：二进制格式，同时包含证书和私钥，一般有密码保护。常用于 Weblogic，Tomcat，Jboss。PFK：常用于 IIS 等。KDB：常用于 IHS，Webspphere</code></pre></div></blockquote><h4 id="SSL和TSL">SSL和TSL</h4><blockquote><p>提供的主要服务:</p><ol><li class="lvl-3">认证用户和服务器，确保数据发送到正确的客户机和服务器；</li><li class="lvl-3">加密数据以防止数据中途被窃取；</li><li class="lvl-3">维护数据的完整性，确保数据在传输过程中不被改变</li></ol></blockquote><p><strong>SSL：</strong></p><blockquote><p>**Secure Socket Layer安全套接字层: **为Netscape所研发，用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。SSL协议位于TCP/IP协议与各种应用层协议之间,为数据通讯提供安全支持。</p><p><strong>SSL协议可分为两层：</strong></p><p><code>1.SSL记录协议（SSL Record Protocol）：</code>它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。</p><p><code>2.SSL握手协议（SSL Handshake Protocol）：</code>它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等</p></blockquote><p><strong>TLS：</strong></p><blockquote><p>Transport Layer Security传输层安全协议:用于两个应用程序之间提供保密性和数据完整性</p><p>该协议由两层组成：<strong>TLS记录协议，TLS握手协议</strong></p><p>TLS（传输层安全）是更为安全的升级版 SSL，由于 SSL 这一术语更为常用，因此我们仍然将我们的安全证书称作 SSL</p></blockquote><p><strong>TLS与SSL区别</strong></p><blockquote><ol><li class="lvl-3"><p>版本号：TLS记录格式与SSL记录格式相同，但版本号的值不同，TLS的版本1.0使用的版本号为SSLv3.1。</p></li><li class="lvl-3"><p>报文鉴别码：SSLv3.0和TLS的MAC算法及MAC计算的范围不同。TLS使用了RFC-2104定义的HMAC算法。SSLv3.0使用了相似的算法，两者差别在于SSLv3.0中，填充字节与密钥之间采用的是连接运算，而HMAC算法采用的是异或运算。但是两者的安全程度是相同的。</p></li><li class="lvl-3"><p>伪随机函数：TLS使用了称为PRF的伪随机函数来将密钥扩展成数据块，是更安全的方式。</p></li><li class="lvl-3"><p>报警代码：TLS支持几乎所有的SSLv3.0报警代码，而且TLS还补充定义了很多报警代码，如解密失败（decryption_failed）、记录溢出（record_overflow）、未知CA（unknown_ca）、拒绝访问（access_denied）等。</p></li><li class="lvl-3"><p>密文族和客户证书：SSLv3.0和TLS存在少量差别，即TLS不支持Fortezza密钥交换、加密算法和客户证书。</p></li><li class="lvl-3"><p>certificate_verify和finished消息：SSLv3.0和TLS在用certificate_verify和finished消息计算MD5和SHA-1散列码时，计算的输入有少许差别，但安全性相当。</p></li><li class="lvl-3"><p>加密计算：TLS与SSLv3.0在计算主密值（master secret）时采用的方式不同。</p></li><li class="lvl-3"><p>填充：用户数据加密之前需要增加的填充字节。在SSL中，填充后的数据长度要达到密文块长度的最小整数倍。而在TLS中，填充后的数据长度可以是密文块长度的任意整数倍（但填充的最大长度为255字节），这种方式可以防止基于对报文长度进行分析的攻击。</p></li></ol><p>TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：</p><ol><li class="lvl-3"><p>更安全的MAC算法</p></li><li class="lvl-3"><p>更严密的警报</p></li><li class="lvl-3"><p>“灰色区域”规范的更明确的定义</p></li></ol></blockquote><h4 id="HTTPS单向认证">HTTPS单向认证</h4><blockquote><p>1.客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</p><p>2.服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</p><p>3.客户端使用服务端返回的信息验证服务器的合法性，包括：</p><ul class="lvl-1"><li class="lvl-2"><p>证书是否过期;</p></li><li class="lvl-2"><p>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</p></li><li class="lvl-2"><p>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</p></li><li class="lvl-2"><p>服务器证书上的域名是否和服务器的实际域名相匹配;</p></li><li class="lvl-2"><p>验证通过后，将继续进行通信，否则，终止通信;</p></li></ul><p>4.客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择;</p><p>5.服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</p><p>6.服务器将选择好的加密方案通过<strong>明文</strong>方式返回给客户端;</p><p>7.客户端接收到服务端返回的加密方式后，使用该加密方式生成产生随机码，用作通信过程中对称加密的密钥，使用服务端返回的公钥进行加密，将加密后的随机码发送至服务器;</p><p>8.服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥;<br>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全;</p></blockquote><h4 id="HTTPS双向认证">HTTPS双向认证</h4><p>相对于单向认证，增加了服务端对客户端的认证</p><blockquote><p>1.客户端向服务端发送SSL协议版本号、加密算法种类、随机数等信息;</p><p>2.服务端给客户端返回SSL协议版本号、加密算法种类、随机数等信息，同时也返回服务器端的证书，即公钥证书;</p><p>3.客户端使用服务端返回的信息验证服务器的合法性，包括：</p><ul class="lvl-1"><li class="lvl-2"><p>证书是否过期;</p></li><li class="lvl-2"><p>发行服务器证书的CA是否可靠;(通过查询浏览器或本机内的CA证书)</p></li><li class="lvl-2"><p>返回的公钥是否能正确解开返回证书中的数字签名;（通过使用本机或浏览器内置的CA公钥进行解密）</p></li><li class="lvl-2"><p>服务器证书上的域名是否和服务器的实际域名相匹配;</p></li><li class="lvl-2"><p>验证通过后，将继续进行通信，否则，终止通信;</p></li></ul><p>4.<strong>服务端要求客户端发送客户端的证书即客户端证书公钥，客户端会将自己的证书发送至服务端；</strong></p><p>5.<strong>验证客户端的证书，通过验证后，会获得客户端的公钥；</strong></p><p>6.客户端向服务端发送自己所能支持的对称加密方案，供服务器端进行选择</p><p>7.服务器端在客户端提供的加密方案中选择加密程度最高的加密方式;</p><p>8.<strong>将加密方案通过使用之前获取到的公钥进行加密，返回给客户端</strong></p><p>9.服务器收到客户端返回的加密信息后，使用自己的私钥进行解密，获取对称加密密钥;<br>在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全;</p><p>10.服务端收到客户端发送的消息后，使用自己的私钥进行解密，获取对称加密的密钥，在接下来的会话中，服务器和客户端将会使用该密码进行对称加密，保证通信过程中信息的安全；</p></blockquote><h4 id="证书申请方式">证书申请方式</h4><blockquote><p>阿里云</p><p>腾讯云</p><p>certbot：：Let’s Encrypt是免费、开放和自动化的世界知名证书颁发机构，由非盈利组织互联网安全研究小组（ISRG）运营</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;公钥私钥&quot;&gt;公钥私钥&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;是概念上的区分，发出去的为公钥，自己手上的为私钥，实际生成RSA秘钥时，其中一份包含另一份的完整信息成为私钥，且公私钥都可以做加密方和解密方&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&quot;CA&quot;</summary>
      
    
    
    
    <category term="证书签名" scheme="https://centyuan.github.io/categories/%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D/"/>
    
    
    <category term="证书签名" scheme="https://centyuan.github.io/tags/%E8%AF%81%E4%B9%A6%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes Note</title>
    <link href="https://centyuan.github.io/2023/12/05/K8s%E5%92%8CDocker/Kubernetes-Note/"/>
    <id>https://centyuan.github.io/2023/12/05/K8s%E5%92%8CDocker/Kubernetes-Note/</id>
    <published>2023-12-05T12:16:55.776Z</published>
    <updated>2023-12-07T15:03:45.988Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念和术语">基本概念和术语</h4><h5 id="Mater">Mater</h5><blockquote><p>指集群的控制节点,运行着一组关键进程</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">&gt;Kube-apiserver: 提供了HTTP Rest接口服务，是Kubernetes所有资源的增删改查等操作的唯一入口</span><span class="hljs-section">&gt;Kube-controller-manager: Kubernetes所有资源对象的自动化控制中心</span><span class="hljs-section">&gt;Kube-scheduler: 负责资源调度(Pod调度)的进程</span><span class="hljs-section">&gt;Etcd: Kubernetes所有资源对象数据都保存在etcd中</span></code></pre></div></blockquote><h5 id="Node">Node</h5><blockquote><p>可以在运行期间动态加入kubernetes集群,一加入集群，Node上的kubelet进程会定时向Master节点汇报自身情报(如操作系统信息，Docker版本，CPU内存情况，Pod信息)，Node超时不上报信息，会被Master判定为“失联&quot;,Node被标记为Not Ready，随后Master触发”工作负载大转移&quot;</p></blockquote><h5 id="Pod">Pod</h5><blockquote><p>最基本的概念,每个Pod都有一个特殊容器Pause，还包含一个或多个紧密相关的用户业务容器，Pod里的多个业务容器共享Pause容器的IP和Volume,每个Pod都有一个Pod IP,且集群内任意两个Pod可以通过Pod IP通信</p><p><strong>Endpoint</strong>: PodIP+ContainerPort</p><p><code>分类</code>:普通Pod和静态Pod(不会存放在Etcd里，而是存放在Node的一个具体文件中，并只在此Node上启动运行)</p><p><code>资源限制</code>:</p><p>​</p><div class="code-wrapper"><pre><code class="hljs dts">&gt;spec:<span class="hljs-symbol"> containers:</span>   -name: db<span class="hljs-symbol">    image:</span> mysql<span class="hljs-symbol">    resources:</span> <span class="hljs-symbol">      requests:</span>    <span class="hljs-meta"># 资源最小申请</span><span class="hljs-symbol">        memory:</span> <span class="hljs-string">&quot;64Mi&quot;</span><span class="hljs-symbol">        cpu:</span> <span class="hljs-string">&quot;250m&quot;</span><span class="hljs-symbol">      limits:</span>      <span class="hljs-meta"># 资源最大申请</span><span class="hljs-symbol">        memory:</span> <span class="hljs-string">&quot;120Mi&quot;</span><span class="hljs-symbol">        cpu:</span> <span class="hljs-string">&quot;500m&quot;</span> <span class="hljs-meta"># m表示千分之一CPU,500m就是0.5个CPU</span></code></pre></div></blockquote><h5 id="Label">Label</h5><blockquote><p><strong>Label Selector</strong></p><div class="code-wrapper"><pre><code class="hljs routeros">&gt;基于等式的(Equality-based): <span class="hljs-attribute">name</span>=redis-slave 匹配所有具有标签<span class="hljs-attribute">name</span>=redis-slave的资源对象 env!=production 匹配所有不具有标签<span class="hljs-attribute">env</span>=production的资源对象&gt;基于集合的(Set-based):  name <span class="hljs-keyword">in</span> (redis-master,redis-slave) 匹配所有具有标签<span class="hljs-attribute">name</span>=redis-master或name=redis-slave的资源对象 name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (php-frontend) 匹配所有不具有标签<span class="hljs-attribute">name</span>=php-fronted的资源对象&gt;多个表达式之间用“,”进行分割,关系是<span class="hljs-keyword">AND</span> <span class="hljs-attribute">name</span>=redis-slave,env!=production</code></pre></div></blockquote><h5 id="RC">RC</h5><blockquote><p>Kubernetes最核心的概念，管理Pod的副本数量</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">&gt;apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><span class="hljs-attribute">&gt;kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">ReplicationController</span><span class="hljs-attribute">&gt;metadata</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">frontend</span><span class="hljs-attribute">&gt;spec</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">replicas</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span> <span class="hljs-attribute">selector</span><span class="hljs-punctuation">: </span>   <span class="hljs-attribute">tier</span><span class="hljs-punctuation">:</span> <span class="hljs-string">frontend</span> <span class="hljs-attribute">template</span><span class="hljs-punctuation">:</span>   <span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span>     <span class="hljs-attribute">labels</span><span class="hljs-punctuation">:</span>       <span class="hljs-attribute">app</span><span class="hljs-punctuation">:</span> <span class="hljs-string">app-demo</span>       <span class="hljs-attribute">tier</span><span class="hljs-punctuation">:</span> <span class="hljs-string">frontend</span>   <span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span>     <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">name: tomcat-demo</span>        <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">tomcat</span>        <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span>        <span class="hljs-attribute">env</span><span class="hljs-punctuation">:</span>         <span class="hljs-bullet">-</span> <span class="hljs-string">name: GET_HOSTS_FROM</span>           <span class="hljs-attribute">value</span><span class="hljs-punctuation">:</span> <span class="hljs-string">dns</span>        <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>         <span class="hljs-bullet">-</span> <span class="hljs-string">containerPort: 80</span></code></pre></div><p><code>手动scale</code></p><div class="code-wrapper"><pre><code class="hljs routeros">&gt;kubectl scale rc redis-slave <span class="hljs-attribute">--replicas</span>=3</code></pre></div><p>通过RC的机制，Kubernetes很容易实现滚动升级(Rolling Update)</p></blockquote><h5 id="RS">RS</h5><blockquote><p>Kubernetes1.2后支持Replication Set，下一代的RC，最大的区别RS支持基于集合的Label Selector(Set-based selector),RC只支持基于等式的Label Selector(Equality-based selector)</p></blockquote><h5 id="Deployment">Deployment</h5><blockquote><p>Kubernetes1.2后引入的概念,是为了更好的解决Pod的编排问题，相对于RC的一个最大升级是我们可以随时知道当前Pod&quot;部署&quot;进度</p><p><code>例子</code></p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">&gt;apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">extensions/v1beta1</span><span class="hljs-attribute">&gt;kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Deployment</span><span class="hljs-attribute">&gt;metadata</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">frontend</span><span class="hljs-attribute">&gt;spec</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">replicas</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1</span> <span class="hljs-attribute">selector</span><span class="hljs-punctuation">:</span>   <span class="hljs-attribute">matchLabels</span><span class="hljs-punctuation">:</span>     <span class="hljs-attribute">tier</span><span class="hljs-punctuation">:</span> <span class="hljs-string">frontend</span>   <span class="hljs-attribute">matchExpressions</span><span class="hljs-punctuation">:</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">&#123;key: tier, operator: In, values: [frontend]&#125;</span> <span class="hljs-attribute">template</span><span class="hljs-punctuation">:</span>   <span class="hljs-attribute">metadata</span><span class="hljs-punctuation">:</span>     <span class="hljs-attribute">labels</span><span class="hljs-punctuation">:</span>       <span class="hljs-attribute">app</span><span class="hljs-punctuation">:</span> <span class="hljs-string">app-demo</span>       <span class="hljs-attribute">tier</span><span class="hljs-punctuation">:</span> <span class="hljs-string">frontend</span>   <span class="hljs-attribute">spec</span><span class="hljs-punctuation">:</span>     <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span>      <span class="hljs-bullet">-</span> <span class="hljs-string">name: tomcat-demo</span>        <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">tomcat</span>        <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span>        <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>         <span class="hljs-bullet">-</span> <span class="hljs-string">containerPort: 8080</span></code></pre></div><p><code>创建查看</code></p><div class="code-wrapper"><pre><code class="hljs routeros">&gt;kubectl create -f tomcat-deployment.yaml&gt;kubectl <span class="hljs-built_in">get</span> deployments &gt;kubectl <span class="hljs-built_in">get</span> rs</code></pre></div></blockquote><h5 id="HPA">HPA</h5><blockquote><p>Horizontal Pod Autoscalinig Pod横向自动扩容，与RC,Deployment一样属于Kubernetes的资源对象，通过追踪分析所有RC控制的所有Pod的负载变化，来针对性调整目标Pod的副本数</p><p><strong>Pod负载度量标准</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">CPUUtilizationPercentage</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">应用程序自定义的度量指标，比如服务在每秒内的相应的请求数(TPC或QPS)</span></code></pre></div></blockquote><h5 id="Service">Service</h5><blockquote><p>每个Service就是微服务架构中的一个&quot;微服务&quot;,定义了一个服务的访问入口地址</p><p>Service一旦创建，Kubernetes就会自动为它分配一个可用Cluster IP,在Service的整个生命周期,Cluster IP不会发生改变</p><p>服务发现: 用Service Name与Service Cluster IP做一个DNS域名映射</p><p><code>例子</code></p><div class="code-wrapper"><pre><code class="hljs yaml"><span class="hljs-string">&gt;apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-string">&gt;kind:</span> <span class="hljs-string">Service</span><span class="hljs-string">&gt;metadata:</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat-service</span><span class="hljs-string">&gt;spec:</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">service-port</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>         <span class="hljs-comment"># 定义了Service的虚端口</span>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8080</span>   <span class="hljs-comment"># 容器所暴露EXPOSE</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">shutdown-port</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">8005</span>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">8005</span> <span class="hljs-attr">selector:</span>   <span class="hljs-attr">tier:</span> <span class="hljs-string">frontend</span></code></pre></div><p><code>查看Endpoint</code></p><div class="code-wrapper"><pre><code class="hljs routeros">&gt;kubectl <span class="hljs-built_in">get</span> endpoints</code></pre></div><p><code>查看svc</code></p><div class="code-wrapper"><pre><code class="hljs armasm">&gt;kubectl <span class="hljs-meta">get</span> <span class="hljs-keyword">svc</span> tomcat-service -o yaml</code></pre></div><h5 id="三种IP">三种IP</h5><blockquote><p><strong>Node IP:</strong> Node节点的IP地址是Kubernetes集群中每个节点的物理网卡的IP地址</p><p><strong>Pod IP:</strong></p><p>​Docker Engine 根据docker0网桥的ip地址段进行分配的，通常是一个虚拟的二层网络</p><p><strong>Cluster IP:</strong></p><p>​Service的虚拟IP,无法被Ping,没有一个“实体网络对象&quot;来响应，Cluster IP 只能结合Service Port组成一个具体的通信端口</p></blockquote><p><strong>NodePort</strong></p><p>在每个Node上为需要外部访问的Service开启一个对应的TCP监听端口</p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">&gt;apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><span class="hljs-attribute">&gt;kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">Service</span><span class="hljs-attribute">&gt;metadata</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">tomcat-service</span><span class="hljs-attribute">&gt;spec</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">type</span><span class="hljs-punctuation">:</span> <span class="hljs-string">NodePort</span> <span class="hljs-attribute">ports</span><span class="hljs-punctuation">:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">port: 8080</span>    <span class="hljs-attribute">nodePort</span><span class="hljs-punctuation">:</span> <span class="hljs-string">31002</span> <span class="hljs-attribute">selector</span><span class="hljs-punctuation">:</span>   <span class="hljs-attribute">tier</span><span class="hljs-punctuation">:</span> <span class="hljs-string">frontend</span></code></pre></div></blockquote><h5 id="Volume">Volume</h5><blockquote><p>是Pod中能够被多个容器访问的共享目录</p><p><code>例子</code></p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">&gt;spec</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">volumes</span><span class="hljs-punctuation">:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: datavol</span>    <span class="hljs-attribute">emptyDir</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;&#125;</span> <span class="hljs-attribute">containers</span><span class="hljs-punctuation">:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">name: tomcat-demo</span>    <span class="hljs-attribute">image</span><span class="hljs-punctuation">:</span> <span class="hljs-string">tomcat</span>    <span class="hljs-attribute">volumeMounts</span><span class="hljs-punctuation">:</span>     <span class="hljs-bullet">-</span> <span class="hljs-string">mountPath: /mydata-data</span>     <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">datavol</span>    <span class="hljs-attribute">imagePullPolicy</span><span class="hljs-punctuation">:</span> <span class="hljs-string">IfNotPresent</span></code></pre></div><p><strong>Volume类型:</strong></p><div class="code-wrapper"><pre><code class="hljs crmsh">&gt;emptyDir:一个emptyDir Volume是在pod分配到<span class="hljs-keyword">Node</span><span class="hljs-title">时创建的,无需指定宿主机上对应的目录,由Kubernetes</span>自动分配，当Pod从<span class="hljs-keyword">Node</span><span class="hljs-title">上移除时,emptyDir</span>也被永久删除&gt;使用场景:临时空间&gt;volumes:- name: datavol  emptyDir: &#123;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">&gt;hostPath:</span>为在Pod上挂载宿主机上的文件或目录<span class="hljs-section">&gt;使用场景:容器生成的日志文件需要永久保存在宿主机上的文件系统</span><span class="hljs-section">&gt;注意:</span>1.不同Node的具有相同配置的Pod可能会因为宿主机上的目录和文件不同而导致对Volume上目录和文件的访问结果不一致2.使用了资源管理，Kubernetes无法将hostPath在宿主机上是使用的资源纳入管理<span class="hljs-section">&gt;volumes:</span>- name: <span class="hljs-string">&quot;persistent-storage&quot;</span>  hostPath:     path: <span class="hljs-string">&quot;/data&quot;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">&gt;NFS</span><span class="hljs-punctuation">:</span><span class="hljs-attribute">使用网络文件系统</span><span class="hljs-attribute"></span><span class="hljs-attribute">&gt;volumes</span><span class="hljs-punctuation">:</span><span class="hljs-bullet">-</span> <span class="hljs-string">name: nfs</span>  <span class="hljs-attribute">nfs</span><span class="hljs-punctuation">: </span>    <span class="hljs-attribute">server</span><span class="hljs-punctuation">:</span> <span class="hljs-string">nfs-server.localhost</span>    <span class="hljs-attribute">path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/&quot;</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-operator">&gt;</span><span class="hljs-variable">gcePersistentDisk</span>使用谷歌公有云提供的永久磁盘<span class="hljs-punctuation">(</span><span class="hljs-variable">Persistent</span> <span class="hljs-built_in">Disk</span><span class="hljs-operator">,</span><span class="hljs-variable">PD</span><span class="hljs-punctuation">)</span></code></pre></div><div class="code-wrapper"><pre><code class="hljs dockerfile">&gt;awsElasticBlockStor使用亚马逊公有云提供的EBS <span class="hljs-keyword">Volume</span><span class="language-bash">存储数据</span></code></pre></div></blockquote><h5 id="Persistent-Volume">Persistent Volume</h5><blockquote><p>网络存储，可以理解成Kubernetes集群中的某个网络存储中对应的一块存储</p><p><strong>类型:</strong></p><div class="code-wrapper"><pre><code class="hljs mipsasm">&gt;GCE Persistent <span class="hljs-keyword">Disks,NFS,RBD,iSCSCI,AWS </span>ElasticBlockStor,GlusterFS</code></pre></div><p><code>NFS类型PV yaml例子</code></p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">&gt;apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><span class="hljs-attribute">&gt;kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">PersistentVolume</span><span class="hljs-attribute">&gt;metadata</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">pv03</span><span class="hljs-attribute">&gt;spec</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">capacity</span><span class="hljs-punctuation">:</span>   <span class="hljs-attribute">storage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">5Gi</span> <span class="hljs-attribute">accessModes</span><span class="hljs-punctuation">:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span> <span class="hljs-attribute">nfs</span><span class="hljs-punctuation">:</span>   <span class="hljs-attribute">path</span><span class="hljs-punctuation">:</span> <span class="hljs-string">/somepath</span>   <span class="hljs-attribute">server</span><span class="hljs-punctuation">:</span> <span class="hljs-string">172.17.0.2</span><span class="hljs-attribute">&gt;# accessModes属性</span><span class="hljs-punctuation">: </span><span class="hljs-attribute">&gt;# ReadWriteOnce</span><span class="hljs-punctuation">:</span> <span class="hljs-string">读写权限，只能被单个Node挂载</span><span class="hljs-attribute">&gt;# ReadOnlyMany</span><span class="hljs-punctuation">:</span> <span class="hljs-string">只读权限，允许被多个Node挂载</span><span class="hljs-attribute">&gt;# ReadWriteMany</span><span class="hljs-punctuation">:</span> <span class="hljs-string">读写权限，允许被多个Node挂载</span></code></pre></div><p><strong>PV状态</strong></p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">&gt;Available: 空闲状态</span><span class="hljs-section">&gt;Bound: 已经绑定大道某个PVC上</span><span class="hljs-section">&gt;Released: 对应的PVC已经删除，单资源还没被集群收回</span><span class="hljs-section">&gt;Failed: PV自动回收失败</span></code></pre></div><p><strong>某个Pod想申请某种条件的PV，首先需要定义一个PVC(PersistentVolumeClaim)</strong></p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">&gt;apiVersion</span><span class="hljs-punctuation">:</span> <span class="hljs-string">v1</span><span class="hljs-attribute">&gt;kind</span><span class="hljs-punctuation">:</span> <span class="hljs-string">PersistentVolumeClaim</span><span class="hljs-attribute">&gt;metadata</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">myclaim</span><span class="hljs-attribute">&gt;spec</span><span class="hljs-punctuation">:</span> <span class="hljs-attribute">accessModes</span><span class="hljs-punctuation">:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">ReadWriteOnce</span> <span class="hljs-attribute">resources</span><span class="hljs-punctuation">:</span>   <span class="hljs-attribute">requests</span><span class="hljs-punctuation">:</span>     <span class="hljs-attribute">storage</span><span class="hljs-punctuation">:</span> <span class="hljs-string">8Gi</span></code></pre></div><p><strong>然后再Pod的Volume定义中引用上述PVC</strong></p><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">&gt;volumes</span><span class="hljs-punctuation">:</span><span class="hljs-bullet">-</span> <span class="hljs-string">name: mypd</span>  <span class="hljs-attribute">persistentVolumeClaim</span><span class="hljs-punctuation">:</span>    <span class="hljs-attribute">claimName</span><span class="hljs-punctuation">:</span> <span class="hljs-string">myclaim</span></code></pre></div></blockquote><h5 id="Namespace命名空间">Namespace命名空间</h5><blockquote><p>实现多租房的资源隔离，集群启动后，会创建一个名为“default&quot;的Namespace,如果不指名Namespace，资源会被创建到default的空间上</p><p>通过命令查看: kubectl get namespaces</p></blockquote><h5 id="Annotation注解">Annotation注解</h5><blockquote><p>用户任意定义的“附加&quot;信息，用来记录如下信息</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">build信息，release信息，Docker镜像信息</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">日志库,监控库</span></code></pre></div></blockquote><h4 id="安装配置">安装配置</h4><h5 id="Kubeadm工具快速安装">Kubeadm工具快速安装</h5><h5 id="二进制方式安装">二进制方式安装</h5><h5 id="Kubernetes集群的安全设置">Kubernetes集群的安全设置</h5><blockquote><p>在一个安全的内网环境中，Kubernetes的各个组件与Master之间可以通过kube-apiserver的非安全端口http://<kube-apiserver-ip>:8080进行访问。但如果API Server需要对外提供服务，或者集群中的某些容器也需要访问API Server以获取集群中的某些信息，则更安全的做法是启用HTTPS安全机制。Kubernetes提供了基于CA签名的双向数字证书认证方式和简单的基于HTTP Base或Token的认证方式，其中CA证书方式的安全性最高。本节先介绍如何以CA证书的方式配置Kubernetes集群，要求Master上的kube-apiserver、kube-controller-manager、kube-scheduler进程及各Node上的kubelet、kube-proxy进程进行CA签名双向数字证书安全设置。</p></blockquote><h4 id="kubectl命令用法详解">kubectl命令用法详解</h4><blockquote><p><strong>kubectl [command] [TYPE] [NAME] [flags]</strong></p><p><strong>command:</strong> 子命令，用于操作Kubernetes集群资源对象,如create/delete/describe/get/apply</p><p><strong>TYPE:</strong> 资源对象类型，单数，复数，简写形式表示</p><p><strong>NAME:</strong> 资源对象的名称，不指定名称,返回TYPE的全部对象</p><p><strong>flags:</strong> kubectl子命令的可选参数,</p></blockquote><p><strong>参考资料</strong></p><blockquote><p><a href="https://github.com/kubernetes/kubernetes/blob/v1.25.10/pkg/scheduler/scheduler.go">https://github.com/kubernetes/kubernetes/blob/v1.25.10/pkg/scheduler/scheduler.go</a></p><p>官方文档：</p><ul class="lvl-1"><li class="lvl-2"><p>调度：<a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/kube-scheduler/">https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/kube-scheduler/</a></p></li><li class="lvl-2"><p>调度器配置：<a href="https://kubernetes.io/zh-cn/docs/reference/scheduling/config/">https://kubernetes.io/zh-cn/docs/reference/scheduling/config/</a></p></li></ul><p>可供学习的资料</p><p><a href="https://granulate.io/blog/a-deep-dive-into-kubernetes-scheduling/">https://granulate.io/blog/a-deep-dive-into-kubernetes-scheduling/</a></p><p><a href="https://www.infoq.cn/article/or7crphtdlx1ivhsfngk">https://www.infoq.cn/article/or7crphtdlx1ivhsfngk</a></p><p><a href="https://www.cnblogs.com/zhangmingcheng/p/16324140.html">https://www.cnblogs.com/zhangmingcheng/p/16324140.html</a></p><p><a href="https://xie.infoq.cn/article/33fb565b66b825a9683abf864">https://xie.infoq.cn/article/33fb565b66b825a9683abf864</a></p><p><a href="https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/">https://kubernetes.io/zh-cn/docs/concepts/scheduling-eviction/pod-priority-preemption/</a></p><p><a href="https://kubernetes.io/docs/concepts/scheduling-eviction/scheduler-perf-tuning/">https://kubernetes.io/docs/concepts/scheduling-eviction/scheduler-perf-tuning/</a></p><p><a href="https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity">https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity</a></p><p><a href="https://www.infoq.cn/article/3S9hqoOX0mODAVyM0VH3?utm_source=related_read_bottom&amp;utm_medium=article">https://www.infoq.cn/article/3S9hqoOX0mODAVyM0VH3?utm_source=related_read_bottom&amp;utm_medium=article</a></p><p><a href="https://www.qikqiak.com/k3s/scheduler/overview/">https://www.qikqiak.com/k3s/scheduler/overview/</a></p><p><a href="https://www.jianshu.com/p/91f4c8967a92">https://www.jianshu.com/p/91f4c8967a92</a></p><p><a href="https://rx-m.com/kube-scheduler-kubecon-cloudnativecon-na-2021/">https://rx-m.com/kube-scheduler-kubecon-cloudnativecon-na-2021/</a></p><p><a href="https://blog.csdn.net/i_want_to_be_a_god/article/details/106969992">https://blog.csdn.net/i_want_to_be_a_god/article/details/106969992</a></p><p><a href="http://www.iceyao.com.cn/post/2020-08-31-k8s-scheduler-framework/">http://www.iceyao.com.cn/post/2020-08-31-k8s-scheduler-framework/</a></p><p><a href="https://qiankunli.github.io/2020/09/03/scheduler_score.html">https://qiankunli.github.io/2020/09/03/scheduler_score.html</a></p><p><a href="https://blog.crazytaxii.com/posts/k8s_scheduler_bind/">https://blog.crazytaxii.com/posts/k8s_scheduler_bind/</a></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基本概念和术语&quot;&gt;基本概念和术语&lt;/h4&gt;
&lt;h5 id=&quot;Mater&quot;&gt;Mater&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;指集群的控制节点,运行着一组关键进程&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;h</summary>
      
    
    
    
    <category term="K8s和Docker" scheme="https://centyuan.github.io/categories/K8s%E5%92%8CDocker/"/>
    
    
    <category term="K8s" scheme="https://centyuan.github.io/tags/K8s/"/>
    
  </entry>
  
  <entry>
    <title>Python源码分析</title>
    <link href="https://centyuan.github.io/2023/11/30/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/Python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://centyuan.github.io/2023/11/30/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/Python%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2023-11-30T06:59:21.506Z</published>
    <updated>2023-11-30T06:59:11.385Z</updated>
    
    <content type="html"><![CDATA[<h4 id="相关资料">相关资料</h4><blockquote><p><a href="https://juejin.cn/post/7031139112321024031">Python源码剖析</a></p><p><a href="https://fasionchan.com/python-source/preface/intra/">Python源码</a></p><p><a href="https://github.com/python/cpython">Cpython-github</a></p><p><a href="https://realpython.com/cpython-source-code-guide/">Your Guide to the CPython Source Code</a></p><p><a href="https://groups.google.com/g/python-cn">CPyUG</a></p></blockquote><h4 id="主要内容">主要内容</h4><h5 id="编译Python">编译Python</h5><blockquote><p>1 Python总体架构<br>2 Python源代码的组织<br>3 Windows环境下编译Python<br>4 Unix/Linux环境下编译Python<br>5 修改Python源代码<br>6 通往Python之路<br>7 一些注意事项</p></blockquote><h5 id="Python内建对象">Python内建对象</h5><h6 id="Python中的整数对象">Python中的整数对象</h6><blockquote><p>1 初识PyIntObject对象<br>2 PyIntObject对象的创建和维护<br>3 Hack PyIntObject</p></blockquote><h6 id="Python中的字符串对象">Python中的字符串对象</h6><blockquote><p>1 PyStringObject与PyString_Type<br>2 创建PyStringObject对象<br>3 字符串对象的intern机制<br>4 字符缓冲池<br>5 PyStringObject效率相关问题<br>6 Hack PyStringObject</p></blockquote><h6 id="Python中List对象">Python中List对象</h6><blockquote><p>1 PyListObject对象<br>2 PyListObject对象的创建与维护<br>3 PyListObject对象缓冲池<br>4 Hack PyListObject</p></blockquote><h6 id="Python中的Dict对象">Python中的Dict对象</h6><blockquote><p>1 散列表概述<br>2 PyDictObject<br>3 PyDictObject的创建和维护<br>4 PyDictObject对象缓冲池<br>5 Hack PyDictObject</p></blockquote><h6 id="Python模拟">Python模拟</h6><blockquote><p>1 Small Python<br>2 对象机制<br>3 解释过程<br>4 交互式环境</p></blockquote><h5 id="Python虚拟机">Python虚拟机</h5><h6 id="Python的编译结果—Code对象与pyc文件">Python的编译结果—Code对象与pyc文件</h6><blockquote><p>1 Python程序的执行过程<br>2 Python编译器的编译结果——PyCodeObject对象<br>3 Pyc文件的生成<br>4 Python的字节码<br>5 解析pyc文件</p></blockquote><h5 id="Python虚拟机框架">Python虚拟机框架</h5><blockquote><p>1 Python虚拟机中的执行环境<br>2 名字、作用域和名字空间<br>3 Python虚拟机的运行框架<br>4 Python运行时环境初探</p></blockquote><h6 id="Python虚拟机中的一般表达式">Python虚拟机中的一般表达式</h6><blockquote><p>1 简单内建对象的创建<br>2 复杂内建对象的创建<br>3 其他一般表达式</p></blockquote><h6 id="Python虚拟机中的控制流">Python虚拟机中的控制流</h6><blockquote><p>1 Python虚拟机中的if控制流<br>2 Python虚拟机中的for循环控制流<br>3 Python虚拟机中的while循环控制结构<br>4 Python虚拟机中的异常控制流</p></blockquote><h6 id="Python虚拟机中的函数机制">Python虚拟机中的函数机制</h6><blockquote><p>1 PyFunctionObject对象<br>2 无参函数调用<br>3 函数执行时的名字空间<br>4 函数参数的实现<br>5 函数中局部变量的访问<br>6 嵌套函数、闭包与decorator</p></blockquote><h6 id="Python虚拟机中的类机制">Python虚拟机中的类机制</h6><blockquote><p>1 Python中的对象模型<br>2 从type对象到class对象<br>3 用户自定义class<br>4 从class对象到instance对象<br>5 访问instance对象中的属性<br>6 千变万化的descriptor</p></blockquote><h6 id="Python运行环境初始化">Python运行环境初始化</h6><blockquote><p>1 线程环境初始化<br>2 系统module初始化<br>3 激活Python虚拟机</p></blockquote><h6 id="Python模块的动态加载机制">Python模块的动态加载机制</h6><blockquote><p>1 import前奏曲<br>2 Python中import机制的黑盒探测<br>3 import机制的实现<br>4 Python中的import操作<br>5 与module有关的名字空间问题</p></blockquote><h6 id="Python多线程机制">Python多线程机制</h6><blockquote><p>1 GIL与线程调度<br>2 初见Python Thread<br>3 Python线程的创建<br>4 Python线程的调度<br>5 Python子线程的销毁<br>6 Python线程的用户级互斥与同步<br>7 高级线程库——threading</p></blockquote><h6 id="Python的内存管理机制">Python的内存管理机制</h6><blockquote><p>1 内存管理架构<br>2 小块空间的内存池<br>3 循环引用的垃圾收集<br>4 Python中的垃圾收集</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;相关资料&quot;&gt;相关资料&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7031139112321024031&quot;&gt;Python源码剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://fasionch</summary>
      
    
    
    
    <category term="Python从入门到放弃" scheme="https://centyuan.github.io/categories/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    
    
    <category term="Python" scheme="https://centyuan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Docker Note</title>
    <link href="https://centyuan.github.io/2023/11/27/K8s%E5%92%8CDocker/Docker_Note/"/>
    <id>https://centyuan.github.io/2023/11/27/K8s%E5%92%8CDocker/Docker_Note/</id>
    <published>2023-11-27T07:53:58.390Z</published>
    <updated>2023-11-27T07:52:51.589Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本命令">基本命令</h4><blockquote><p>创建容器</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker run ubuntu:15.10 /bin/echo <span class="hljs-string">&quot;Hello world&quot;</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">以ubuntu15.10镜像创建一个新容器,然后在容器里执行 bin/echo <span class="hljs-string">&quot;Hello world&quot;</span>(容器里面运行一个程序)，然后输出结果。</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">ubuntu:15.10指定要运行的镜像，Docker首先从本地主机上查找镜像是否存在，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</span></code></pre></div><p>启动容器</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker run -d ubuntu:15.10 /bin/sh -c <span class="hljs-string">&quot;while true; do echo hello world; sleep 1; done&quot;</span>  --name my_ubunut</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker run -i -t ubuntu:15.10 /bin/bash -p 8080:80</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-t:在新容器内指定一个伪终端或终端。</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-i:允许你对容器内的标准输入 (STDIN) 进行交互。</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-d:后台运行容器,并返回容器<span class="hljs-built_in">id</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-p:指定端口映射,格式为本机端口8080:容器端口80,将本机8080端口映射到容器80的端口</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-P:会随机映射一个端口到内部容器开放的网络端口</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-v:volume,绑定一个卷,格式为主机路径:容器路径</span></code></pre></div><p>查看容器</p><div class="code-wrapper"><pre><code class="hljs livecodeserver">&gt;docker ps -<span class="hljs-keyword">a</span>&gt;docker <span class="hljs-built_in">start</span> <span class="hljs-number">2</span>b1b7a428627 <span class="hljs-comment"># 启动已停止运行的容器</span>&gt;docker <span class="hljs-built_in">stop</span> <span class="hljs-number">2</span>b1b7a428627  <span class="hljs-comment"># 停止容器</span></code></pre></div><p>查看日志</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker logs 2b1b7a428627/docker-name</span></code></pre></div><p>进入容器</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -ti 容器ID /bin/bash</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">在使用 -d 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(1.docker attach</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker attach 容器名称/ID</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 多个窗口同时attach到同一个容器的时候，所有窗口都会同步显示。当某个窗口因命令阻塞时，其他窗口也无法执行操作了。</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(2.docker <span class="hljs-built_in">exec</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker <span class="hljs-built_in">exec</span> -it 容器ID /bin/bash</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 推荐大家使用 docker exec 命令，因为此命令会退出容器终端，但不会导致容器的停止。</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(3.nsenter工具</span></code></pre></div><p>打包容器为镜像</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker commit -m  <span class="hljs-string">&quot;提示信息&quot;</span>   -a  <span class="hljs-string">&quot;作者centyuan&quot;</span>   容器ID（可以简写）  image_name(镜像名称)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-m:提示信息</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-a:作者</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker push image_name <span class="hljs-comment"># 上传镜像到hub.docker.com</span></span></code></pre></div><p>镜像导入导出</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker save -o imagename.tar  nginx:latest</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker save &gt; imagename.tar nginx:latest</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker <span class="hljs-built_in">export</span> -o name.tar nginx:latest</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-o/&gt;:表示输出到文件</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">nginx:latest 表示源镜像名</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker load  -i imagename.tar</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker load  &lt;  imagename.tar</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker import nginx-test.tar nginx:imp</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">-i和&lt;表示从文件输入</span></code></pre></div><p>文件拷贝</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1宿主机拷贝到容器：</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sudo docker <span class="hljs-built_in">cp</span> /home/centyuan/file(文件) or /home/centyuan/dir(目录) 容器name or ID:/root/</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2容器拷贝到宿主机：</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sudo docker <span class="hljs-built_in">cp</span> mycontainer:/root/fiel.txt /home/centyuan/</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">需要注意的是不管容器有没有启动，拷贝命令都会生效</span></code></pre></div><p>others</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">获取一个新的镜像： docker pull ubuntu:13.10</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">查找镜像：docker search httpd</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">搜索镜像：docker search centos</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">获取镜像：docker pull registry.cn-hangzhou.aliyuncs.com/1hpc/centos</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">查看本地所有镜像：docker images</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">查看镜像<span class="hljs-built_in">id</span>：docker images -q</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">删除镜像：docker rmi image_id</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">删除所有镜像：docker rmi $(docker images -q)</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">创建容器：docker run --name &lt;container_name&gt; centos:7,container_name是自己定义的容器名</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">查看所有容器：docker ps -a</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">查看运行容器：docker ps</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">查看容器<span class="hljs-built_in">id</span>：docker ps -q</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">进入容器：docker <span class="hljs-built_in">exec</span> -it &lt;container_id&gt; bash</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">退出容器：<span class="hljs-built_in">exit</span></span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">删除容器：docker <span class="hljs-built_in">rm</span> &lt;container_id&gt;</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">删除所有容器：docker <span class="hljs-built_in">rm</span> $(docker ps -aq)</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">端口映射：docker run -d -p 8080:80 hub.c.163.com/library/nginx</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">启动/停止/重启容器：docker start/stop/restart &lt;container_id&gt;</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">获取容器/镜像的元数据：docker inspect &lt;container_id&gt;</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">挂载数据卷：docker run -v host/machine/dir :container/path/dir --name volume_test_container centos:7</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">启动mysql容器：docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=qwerasdf -d mysql:5.7 <span class="hljs-comment"># 默认用户为root，密码qwerasdf</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">容器连接：docker run --name some-app --<span class="hljs-built_in">link</span> some-mysql:mysql -d application-that-uses-mysql  mysql容器启动后，其他容器就可以来连接使用了，方法如下：</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">查看容器ip地址:docker inspect 容器名称/容器<span class="hljs-built_in">id</span> | grep IPAddress   <span class="hljs-comment"># docker会每个容器分配一个ip地址</span></span></code></pre></div></blockquote><h4 id="Dockerfile">Dockerfile</h4><blockquote><p>用来构建镜像的文本文件</p><p><strong>ADD和COPY区别</strong></p><div class="code-wrapper"><pre><code class="hljs oxygene">&gt;都是复制文件/目录到容器&gt;<span class="hljs-keyword">ADD</span>:<span class="hljs-number">1</span>.支持url远程复制(推送使用curl/wget,使用<span class="hljs-keyword">ADD</span>会创建更多的镜像层),<span class="hljs-number">2</span>.压缩文件会自动解压,不太稳定,尽量使用<span class="hljs-keyword">COPY</span>&gt;<span class="hljs-keyword">COPY</span>:复制本地文件或目录到容器的文件系统只能用于处理本地文件&gt;<span class="hljs-keyword">ADD</span>命令在实践过程中，有很多功能问题出现，不稳定，官方建议尽可能使用<span class="hljs-keyword">COPY</span></code></pre></div><p><strong>一般格式</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">FROM centos:6.7  <span class="hljs-comment"># 指定使用那个镜像</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">MAINTAINER  Fisher <span class="hljs-string">&quot;centyuan@outlook.com&quot;</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">RUN /bin/echo <span class="hljs-string">&#x27;root:123456&#x27;</span> | chpasswd  <span class="hljs-comment"># RUN后面build时执行</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">RUN useradd centyuan</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">RUN /bin/echo <span class="hljs-string">&#x27;centyuan:123456&#x27;</span>| chpasswd</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">RUN /bin/echo -e <span class="hljs-string">&quot;LANG=\&quot;en_US.UTF-8\&quot;&quot;</span> &gt;/etc/default/local</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">EXPOSE 22</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">EXPOSR 80</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">CMD /usr/sbin/sshd -D   <span class="hljs-comment"># CMD后面docker run时执行</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">ENTERYPOINT</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">tail</span> -f /dev/null       <span class="hljs-comment"># 防止容器启动后,主线程命令执行完退出</span></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 使用Dockerfile构建镜像, . 为上下文路径 -t为镜像名字及标签,name:tag</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">docker build -t centos:V3 .</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">exec</span> /bin/bash <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span></span></code></pre></div></blockquote><h4 id="Docker-compose">Docker-compose</h4><blockquote><p>使用步骤:</p><p>1.dockerfile定义应用程序环境镜像<br>2.docker-compose.yml定义构成应用程序的服务<br>3.docker-compose up启动并运行整个应用程序</p></blockquote><h4 id="Docker网络模式">Docker网络模式</h4><blockquote><div class="code-wrapper"><pre><code class="hljs xl">&gt;<span class="hljs-number">1</span>.host模式(--net=host):共享主机的网络空间,使用主机的ip/端口,多个container使用相同的端口会发生端口冲突,没有独立ip,没有network namespace&gt;<span class="hljs-number">2</span>.bridge模式(默认的网络模式):没有--net参数默认网桥模式,通过veth-pair实现内部网卡和docker0网桥通信<span class="hljs-function"><span class="hljs-title">eth0</span> &lt;---&gt;</span> <span class="hljs-function"><span class="hljs-title">docker0</span>(bridge) &lt;-veth--ehto-&gt;</span> docker containerN<span class="hljs-function"><span class="hljs-title">etwork</span> namespace---&gt;</span><span class="hljs-function"><span class="hljs-title">veth</span>&lt;---&gt;</span><span class="hljs-function"><span class="hljs-title">veth</span>-br---&gt;</span><span class="hljs-function"><span class="hljs-title">bridge</span>---&gt;</span><span class="hljs-function"><span class="hljs-title">etho</span>(nat转换)---&gt;</span>公网Docker server启动时,会在主机上创建一个名为docker0的虚拟网桥(类似于物理交换机),主机上的所有容器就通过虚拟网桥连在了一个二层网络中,&gt;<span class="hljs-number">3</span>.container模式(--net=container:容器<span class="hljs-keyword">name</span>/id):新创建容器没有网卡和ip,而是和指定容器共享ip和端口范围&gt;<span class="hljs-number">4</span>.none模式,封闭的网络环境&gt;<span class="hljs-number">5</span>.overlay模式</code></pre></div><p>Linux通过network namespace，把网络划分成一个个的独立空间，再通过虚拟网络设备将这些独立空间连接起来形成一个虚拟网络</p><p>参考</p><p><a href="https://zhuanlan.zhihu.com/p/199298498">手撕Docker网络1</a><br><a href="https://zhuanlan.zhihu.com/p/206512720">手撕Docker网络2</a></p><div class="code-wrapper"><pre><code class="hljs arduino">&gt;Network Namespace:网络命名空间&gt;Linux <span class="hljs-built_in">Bridge</span>:Linux网桥设备，是Linux提供的一种虚拟网络设备，类似物理的网络交换机&gt;<span class="hljs-built_in">VETH</span>(Virtual <span class="hljs-built_in">Ethernet</span>):虚拟网卡，总是成对出现，两个veth组成一个veth-pair</code></pre></div><p>启用bridge的路由功能连通主机和虚拟网络空间</p><div class="code-wrapper"><pre><code class="hljs armasm">&gt;<span class="hljs-number">1</span>.给vbridge-<span class="hljs-number">0</span>一个<span class="hljs-built_in">ip</span>地址(该地址需要和虚拟网络空间在同一个子网)</code></pre></div></blockquote><h4 id="Docker文件结构">Docker文件结构</h4><blockquote><p>container其实是一个进程,与普通进程不同，container通过隔离技术做到了container之间的互相隔离</p><p>主要三个隔离核心技术: namespace, cgroups, rootfs</p><p>**Namespace:**是Linux内核的一项功能,用于对内核资源进行分区，使一组进程看到一组资源</p><p>主要以下几种:</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">&gt;IPC: SystemV IPC（信号量,消息队列和共享内存)和POSIX message queues</span><span class="hljs-section">&gt;Network: 网络设备，网络栈，端口</span><span class="hljs-section">&gt;Mount: 文件挂载点</span><span class="hljs-section">&gt;PID: 进程编号</span><span class="hljs-section">&gt;User: User 和Group IDs</span><span class="hljs-section">&gt;UTS: 主机名和NIS域名</span><span class="hljs-section">&gt;Cgroup: cgroup的根目录</span></code></pre></div><p>**Cgroups:**control groups，是Linux内核提供的一种可以限制，记录，隔离进程组(process groups)所使用物理资源的机制，主要功能有：资源限制(Resource limiting)，优先级分配(Prioritization)，资源统计（Accounting)，进程控制（Control）</p><p><a href="https://zhuanlan.zhihu.com/p/271808319">Cgroups</a></p><p><strong>Rootfs:</strong> 是 docker 容器在启动时<strong>内部进程可见的文件系统</strong>，即 docker 容器的根目录</p><p><strong>overlayFS:</strong></p><div class="code-wrapper"><pre><code class="hljs arcade">&gt;docker deamon会利用联合挂载技术（<span class="hljs-built_in">Union</span> Mount）在已有的rootfs上再挂一个读写层,overlayFS则是联合挂载技术的一种实现</code></pre></div><p>一个容器完整的层应由三个部分组成:</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.镜像层：也称为rootfs，提供容器启动的文件系统。rootfs也就是我们上一节中分析的image文件。镜像层属于roLayer。</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.init层： 用于修改容器中一些文件如/etc/hostname，/etc/hosts，/etc/resolv.conf等。init层属于mountedLayer。</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.容器层：使用联合挂载统一给用户提供的可读写目录。容器层属于mountedLayer</span></code></pre></div></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基本命令&quot;&gt;基本命令&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;创建容器&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs shell&quot;&gt;&lt;span class=&quot;hljs-meta prompt_&quot;&gt;&amp;gt</summary>
      
    
    
    
    <category term="K8s和Docker" scheme="https://centyuan.github.io/categories/K8s%E5%92%8CDocker/"/>
    
    
    <category term="Docker" scheme="https://centyuan.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Cookie|Session|Token|JWT</title>
    <link href="https://centyuan.github.io/2023/11/25/%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/CookieSessionTokenJWT/"/>
    <id>https://centyuan.github.io/2023/11/25/%E8%AE%A4%E8%AF%81%E5%92%8C%E6%8E%88%E6%9D%83/CookieSessionTokenJWT/</id>
    <published>2023-11-25T07:22:04.025Z</published>
    <updated>2023-11-25T08:32:43.781Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述">概述</h4><blockquote><p>认证(Authentication), 就是验证当前用户的身份，证明&quot;你是你自己&quot;</p><p>授权(Authorization),用户授予第三方应用访问该用户某些资源的权限</p></blockquote><p>HTTP是无状态协议,需要去维护一个状态，去告诉服务器请求是那个用户的</p><h4 id="Cookie">Cookie</h4><blockquote><p>cookie是服务器发送到用户浏览器并保存在本地的一小块用户相关的数据,随着每次请求时自动带上，用于服务器对请求做标识</p><p>cookie是不许跨域的，每个cookie都会绑定到单一域名，一级二级域名允许共享使用</p><p>服务端通过响应头:Set-Cookie，来设置cookie</p><p>expires: cookie过期时间</p><p>secure: cookie是否仅被使用安全协议传输(为true则在https才有效)</p><p>httpOnly: 为true，则无法通过js脚本读取cookie信息,一定程度上可以防止xss攻击</p></blockquote><h4 id="Session">Session</h4><blockquote><p>记录服务器和客户端的会话，session基于cookie实现的，session存储在服务端,sessionID则存储在cookie中</p><p>Session比Cookie更安全,因为用户相关的数据存储在服务端</p></blockquote><h4 id="Token">Token</h4><blockquote><p>全称是Access Token,访问资源接口（API）时所需要的资源凭证,Token 使服务端无状态化，不会存储会话信息</p><p>简单的Token组成:</p><p>​uid: 用户的唯一标识​time: 当前时间戳​    sign: 签名,由token的前几位+盐以哈希算法压缩成一定长的十六进制字符串</p><p><strong>refresh token</strong>：</p><p>用于刷新access token的token</p><p>参考<a href="https://segmentfault.com/a/1190000013010835">Token认证的来龙去脉</a></p></blockquote><h4 id="JWT">JWT</h4><blockquote><p>Json Web Token是目前最流行的跨域认证解决方案,是一种认证授权机制</p><p>参考:<a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html">JWT</a></p><p>**原理:**服务器认证后，生成一个json对象发送给用户</p><p><strong>数据结构</strong>:类似这样，中间用三个点分割成三部分,JWT内部是没有换行的</p><div class="code-wrapper"><pre><code class="hljs gcode">&gt;eyJhbGciOiJIUzI<span class="hljs-number">1</span><span class="hljs-symbol">NiIsInR5</span>cCI<span class="hljs-number">6</span>IkpX<span class="hljs-attr">VCJ9</span>.gR<span class="hljs-name">G91</span>IiwiaX<span class="hljs-symbol">NTb2</span><span class="hljs-symbol">NpYWwiOnRydWV9</span><span class="hljs-number">.4</span>pcyMD<span class="hljs-number">09</span>olSyX<span class="hljs-symbol">nrXCjTwX</span></code></pre></div><p><strong>JWT组成:</strong></p><p>Header.Payload.Signature</p><p><code>Header:</code>头部,是一个json对象，描述JWT的元数据</p><div class="code-wrapper"><pre><code class="hljs 1c">&gt;&#123;<span class="hljs-string">&quot;alg&quot;</span>:<span class="hljs-string">&quot;HS256&quot;</span>,   <span class="hljs-meta"># 表示签名的算法</span><span class="hljs-string">&quot;typ&quot;</span>: <span class="hljs-string">&quot;JWT&quot;</span>     <span class="hljs-meta"># 表示这个令牌类型</span>&gt;&#125;</code></pre></div><p>最后，将上面的 JSON 对象使用 Base64URL 算法转成字符串</p><p><code>Payload:</code> 负载，也是一个json对象，用来存放实际传递的数据</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># JWT官方规定的7个字段</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">iss: 签发人issuer</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">exp: 过期时间expiration time</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sub: 主题subject</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">aud: 受众audience</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">nbf: 生效时间Not Before</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">iat: 签发时间Issued At</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">jti: 编号JWT ID</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">除了以上字段，还可以定义私有字段</span></code></pre></div><p>JSON 对象也要使用 Base64URL 算法转成字符串</p><p><code>Signature:</code>签名，对Header和Payload签名，防止数据篡改</p><div class="code-wrapper"><pre><code class="hljs less">&gt;需要指定一个秘钥<span class="hljs-selector-tag">secret</span>，存储在服务器上,使用<span class="hljs-selector-tag">Header</span>指定的签名算法按照一下方式签名&gt;签名算法(<span class="hljs-built_in">base64UrlEncode</span>(Header)+<span class="hljs-string">&quot;.&quot;</span>+<span class="hljs-built_in">base64UrlEncode</span>(Payload))</code></pre></div><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（<code>.</code>）分隔，就可以返回给用户</p><p><strong>最大缺点</strong></p><p>因为服务器不保存状态,token一旦签发，不能在使用过程中废止某个token，直到到期</p><p><strong>JWT和Token</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 相同点</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">都是访问资源的令牌</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">都可以记录用户的信息</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">都是服务端无状态化</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 不通点</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Token验证完后还需要查询数据库</span></code></pre></div></blockquote><h4 id="OAuth认证">OAuth认证</h4><blockquote><p>OAuth2.0是一种授权机制, <strong>核心就是向第三方应用颁发令牌</strong></p><p>参考<a href="http://www.ruanyifeng.com/blog/2019/04/oauth-grant-types.html">OAuth2.0的四种方式</a></p><p>规定了四种：</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">授权码authorization-code</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">隐藏式implict</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">密码式password</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">客户端凭证client credentials</span></code></pre></div><p><strong>授权码</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">指第三方应用先申请一个授权码，使用授权码申请令牌，最常用安全性最高</span></code></pre></div><p><strong>隐藏式</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">允许前端颁发令牌，中间没有授权码</span></code></pre></div><p><strong>密码式</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">允许用户直接把账号密码直接给第三方应用，应用使用账号密码直接申请令牌</span></code></pre></div><p><strong>凭证式</strong></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概述&quot;&gt;概述&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;认证(Authentication), 就是验证当前用户的身份，证明&amp;quot;你是你自己&amp;quot;&lt;/p&gt;
&lt;p&gt;授权(Authorization),用户授予第三方应用访问该用户某些资源的权限&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="权限和认证" scheme="https://centyuan.github.io/categories/%E6%9D%83%E9%99%90%E5%92%8C%E8%AE%A4%E8%AF%81/"/>
    
    
    <category term="权限和认证" scheme="https://centyuan.github.io/tags/%E6%9D%83%E9%99%90%E5%92%8C%E8%AE%A4%E8%AF%81/"/>
    
  </entry>
  
  <entry>
    <title>mysql常用操作命令和性能优化</title>
    <link href="https://centyuan.github.io/2023/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql_Note/"/>
    <id>https://centyuan.github.io/2023/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql_Note/</id>
    <published>2023-11-23T14:56:56.447Z</published>
    <updated>2023-12-11T12:59:00.553Z</updated>
    
    <content type="html"><![CDATA[<p>mysql常用操作命令</p><p>mysql:单进程多线程模型,一个SQL语句无法利用多个cpu core</p><h3 id="一-基本命令">一:基本命令</h3><p><strong>0.查看当前连接数</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> status <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;Thread$&#x27;</span>;<span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;%timeout%&quot;;<span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> &quot;log_%&quot;;</code></pre></div><p><strong>1.查看当前连接状态</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> processlist; # 或者<span class="hljs-keyword">show</span> <span class="hljs-keyword">full</span> processlist 或 <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.processlist# 查看正在运行的线程以及命令</code></pre></div><p><strong>2.数据库连接</strong></p><div class="code-wrapper"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>h 主机名 <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>ppassword</code></pre></div><p><strong>3.添加用户</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">user</span> (host,<span class="hljs-keyword">user</span>,password,select_priv,insert_priv,update_priv) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-string">&#x27;guest&#x27;</span>,password(<span class="hljs-string">&#x27;guest123&#x27;</span>),<span class="hljs-string">&#x27;Y&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>,<span class="hljs-string">&#x27;Y&#x27;</span>);</code></pre></div><p><strong>4.创建用户</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;password&#x27;</span>;<span class="hljs-keyword">create</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> identified <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;password&#x27;</span>;</code></pre></div><div class="code-wrapper"><pre><code class="hljs sql">#新创建用户无法登陆问题?use mysql；<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span>;flush privileges;# 对db_name下所有表都有查询(<span class="hljs-keyword">SELECT</span>)权限<span class="hljs-keyword">grant</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">on</span> db_name.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;# 对所有表有全部权限<span class="hljs-keyword">grant</span> <span class="hljs-keyword">all</span> <span class="hljs-keyword">on</span> <span class="hljs-operator">*</span>.<span class="hljs-operator">*</span> <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;</code></pre></div><p><strong>5.删除用户</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">user</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span>;</code></pre></div><p><strong>6.修改用户密码</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> password <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;username&#x27;</span>@<span class="hljs-string">&#x27;host&#x27;</span> <span class="hljs-operator">=</span> password(<span class="hljs-string">&#x27;123password&#x27;</span>);<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> password<span class="hljs-operator">=</span>password(&quot;你的新密码&quot;) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span><span class="hljs-operator">=</span>&quot;root&quot;;</code></pre></div><p><strong>7.创建数据库病设置字符集和排序规则</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database data_name;<span class="hljs-keyword">create</span> database data_name <span class="hljs-type">character</span> <span class="hljs-keyword">set</span> utf8 <span class="hljs-keyword">collate</span> utf8_general_ci;</code></pre></div><p><strong>8.删除数据库</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> database data_name;</code></pre></div><h3 id="二-操作命令">二:操作命令</h3><p><strong>1.删除表</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> concat(<span class="hljs-string">&#x27;DROP TABLE IF EXISTS &#x27;</span>, table_name, <span class="hljs-string">&#x27;;&#x27;</span>)<span class="hljs-keyword">FROM</span> information_schema.tablesWHERE table_schema <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;mydb&#x27;</span>;# 或者<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> table_name;</code></pre></div><p><strong>2.显示表属性</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">desc</span> user_table;<span class="hljs-keyword">show</span> columns <span class="hljs-keyword">from</span> user_table;</code></pre></div><p><strong>3.显示数据表的索引信息</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> index <span class="hljs-keyword">from</span> user_table;</code></pre></div><p><strong>4.显示数据库所有以run开头的表信息</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">table</span> status <span class="hljs-keyword">like</span><span class="hljs-string">&#x27;run%&#x27;</span>;</code></pre></div><p><strong>5.创建表,engine=指定存储引擎,每张表都可以指定存储引擎</strong></p><div class="code-wrapper"><pre><code class="hljs sql"># <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> `table_test`(<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span>  `table_test`(   `t_id` <span class="hljs-type">INT</span> UNSIGNED AUTO_INCREMENT,   `t_title` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,   `t_author` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">40</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,   `sub_date` <span class="hljs-type">DATE</span>,   <span class="hljs-keyword">PRIMARY</span> KEY(`t_id`))ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;</code></pre></div><p><strong>6.插入数据</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table_name(field1,field2,field3,field4) <span class="hljs-keyword">values</span>(value1,value2,value3,value4);</code></pre></div><p><strong>7.更改字段类型</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> system_info modify <span class="hljs-keyword">column</span> ip <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>) ;</code></pre></div><p><strong>8.更改字段为非空</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> system_info <span class="hljs-keyword">alter</span> <span class="hljs-keyword">column</span> ip <span class="hljs-keyword">set</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span>;</code></pre></div><p><strong>9.添加字段</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> system_info <span class="hljs-keyword">add</span> email <span class="hljs-type">varchar</span>(<span class="hljs-number">30</span>);</code></pre></div><p><strong>10.删除字段</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> system_info <span class="hljs-keyword">drop</span> <span class="hljs-keyword">column</span> email;</code></pre></div><p><strong>11.字段改名</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> system_info rename email <span class="hljs-keyword">to</span> new_email;</code></pre></div><p><strong>12.清空表或删除记录</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-comment">/* 清空表记录三种方式 */</span># <span class="hljs-number">1.</span> <span class="hljs-keyword">delete</span><span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> table_name; 或 <span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> table_name <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;# 删除<span class="hljs-keyword">select</span>记录报错:mysql不允许对同一个表同时进行查询和更新# 解决方案:对查询结果生产一个派生表,对派生表查询<span class="hljs-keyword">delete</span> <span class="hljs-keyword">from</span> table_user  <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> id  <span class="hljs-keyword">from</span> table_user <span class="hljs-keyword">where</span> sex <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>) <span class="hljs-keyword">as</span> tmp);# <span class="hljs-number">2.</span><span class="hljs-keyword">truncate</span><span class="hljs-keyword">truncate</span> table_name # <span class="hljs-number">3.</span>use information_schema 清空所有表记录<span class="hljs-keyword">select</span> table_name,table_schema <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;alphacapture_bigai&#x27;</span><span class="hljs-keyword">select</span> table_name,table_schema <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%alphacapture_bigai%&#x27;</span><span class="hljs-keyword">select</span> concat(<span class="hljs-string">&#x27;truncate table&#x27;</span>,table_schema,<span class="hljs-string">&#x27;.&#x27;</span>,table_name,<span class="hljs-string">&#x27;;&#x27;</span>) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema <span class="hljs-keyword">in</span> (<span class="hljs-string">&#x27;数据库1&#x27;</span>,<span class="hljs-string">&#x27;数据库2&#x27;</span>)</code></pre></div><p><strong>13.插入记录</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table_name(field1,field2,field3) <span class="hljs-keyword">values</span>(value1,value2,value3);</code></pre></div><p><strong>1.更新记录</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> table_name <span class="hljs-keyword">set</span> field2<span class="hljs-operator">=</span>&quot;张三&quot; <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">3</span>;``</code></pre></div><p><strong>15.修改表名</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name rename <span class="hljs-keyword">to</span> new_table_name;</code></pre></div><p><strong>16.模糊查询,%表示任意字符</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>  <span class="hljs-keyword">from</span> Student <span class="hljs-keyword">where</span> name <span class="hljs-keyword">like</span> &quot;%三%&quot;</code></pre></div><p><strong>17.多条件查询and,or</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> Sudent <span class="hljs-keyword">where</span> age <span class="hljs-keyword">between</span> <span class="hljs-number">18</span> <span class="hljs-keyword">and</span> <span class="hljs-number">50</span>;<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> Student <span class="hljs-keyword">where</span> age <span class="hljs-operator">&gt;</span><span class="hljs-number">18</span> <span class="hljs-keyword">and</span> age <span class="hljs-operator">&lt;</span><span class="hljs-number">60</span> <span class="hljs-keyword">and</span> address<span class="hljs-operator">=</span><span class="hljs-string">&#x27;上海&#x27;</span></code></pre></div><p><strong>18.去重</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> address <span class="hljs-keyword">from</span> Student;</code></pre></div><p><strong>19.排序:asc升序,desc倒序</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> Student <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> age <span class="hljs-keyword">desc</span>;</code></pre></div><p><strong>20.查询上做计算</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> age<span class="hljs-operator">*</span><span class="hljs-number">3</span> name <span class="hljs-keyword">from</span> Student;</code></pre></div><p><strong>21.最大max,最小min,平均avg,求和sum,个数count</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(id) <span class="hljs-keyword">from</span> Student;</code></pre></div><p><strong>22.分组查询 group by 将某一列相同数据视为一组</strong></p><div class="code-wrapper"><pre><code class="hljs sql">#使用了<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>,<span class="hljs-keyword">select</span>后只能跟分组列和聚合函数#查询人数大于<span class="hljs-number">3</span>的地区的最大年龄<span class="hljs-keyword">select</span> address,<span class="hljs-built_in">max</span>(age) <span class="hljs-keyword">from</span> Student <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> address <span class="hljs-keyword">having</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">3</span>;</code></pre></div><p><strong>23.分页</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> Student limit <span class="hljs-number">3</span>,<span class="hljs-number">5</span>; # 从第三条记录,查询五条<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> Student limit (n<span class="hljs-number">-1</span>)<span class="hljs-operator">*</span>m,m; # 第n也查询m条记录</code></pre></div><p><strong>24.join连表查询 on 条件</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> Sites.id,Sites.name,Log.count,Log.date <span class="hljs-keyword">from</span> Sites <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> Log <span class="hljs-keyword">on</span> Sites.id<span class="hljs-operator">=</span>Log.site_id;</code></pre></div><p><strong>24.查看表占用磁盘空间大小,M单位</strong></p><div class="code-wrapper"><pre><code class="hljs sql"># 查看单个表<span class="hljs-keyword">select</span> concat(round(<span class="hljs-built_in">sum</span>(DATA_LENGTH<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>),<span class="hljs-number">2</span>),<span class="hljs-string">&#x27;M&#x27;</span>) <span class="hljs-keyword">as</span> table_size  <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;csjdemo&#x27;</span> <span class="hljs-keyword">AND</span> table_name<span class="hljs-operator">=</span><span class="hljs-string">&#x27;demo2&#x27;</span>;<span class="hljs-keyword">SELECT</span> (`DATA_LENGTH`<span class="hljs-operator">+</span> `INDEX_LENGTH`)<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>  <span class="hljs-keyword">as</span> `table_data_size`  <span class="hljs-keyword">from</span> `TABLES` <span class="hljs-keyword">WHERE</span> TABLE_NAME <span class="hljs-operator">=</span><span class="hljs-string">&#x27;tableName&#x27;</span> <span class="hljs-keyword">and</span> TABLE_SCHEMA<span class="hljs-operator">=</span><span class="hljs-string">&#x27;dbName&#x27;</span>;#查看数据库<span class="hljs-keyword">SELECT</span> (<span class="hljs-built_in">sum</span>(`DATA_LENGTH`) <span class="hljs-operator">+</span><span class="hljs-built_in">sum</span>(`INDEX_LENGTH`))<span class="hljs-operator">/</span><span class="hljs-number">1024</span><span class="hljs-operator">/</span><span class="hljs-number">1024</span>   <span class="hljs-keyword">as</span> `db_data_size`  <span class="hljs-keyword">from</span> `TABLES` <span class="hljs-keyword">where</span> `TABLE_SCHEMA`<span class="hljs-operator">=</span><span class="hljs-string">&#x27;dbName&#x27;</span>;</code></pre></div><p><strong>25.创建主键primary三种方式</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table_name(    uid <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY,    uname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),)<span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table_name(    uid <span class="hljs-type">INT</span>,    uname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),    <span class="hljs-keyword">PRIMARY</span> KEY(uid),  # 或者<span class="hljs-keyword">PRIMARY</span> KEY(uid,uname)联合主键)<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">add</span> PRIAMRY KEY(udi);  # 添加主键约束<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">drop</span> <span class="hljs-keyword">PRIMARY</span> KEY;      # 删除主键约束</code></pre></div><p><strong>26.创建唯一索引三种方式</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> table_name(    uid <span class="hljs-type">INT</span>,    uname <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">10</span>),    <span class="hljs-keyword">UNIQUE</span> [])<span class="hljs-keyword">alter</span> <span class="hljs-keyword">table</span> table_name <span class="hljs-keyword">unique</span> index(filed_name,filed_name)<span class="hljs-keyword">create</span> <span class="hljs-keyword">UNIQUE</span> INDEX indexName <span class="hljs-keyword">on</span> table_name(filed_name,filed_name)</code></pre></div><h3 id="数据-复制-导入-导出-操作">数据(复制|导入|导出)操作</h3><p><strong>1.复制n条记录并创建</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">into</span> reyo (num,overtime) <span class="hljs-keyword">SELECT</span> num,overtime <span class="hljs-keyword">from</span> reyo <span class="hljs-keyword">where</span> id <span class="hljs-keyword">IN</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>);<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">into</span> reyo (`num`,`overtime`) <span class="hljs-keyword">SELECT</span> `num`,`overtime` <span class="hljs-keyword">from</span> reyo <span class="hljs-keyword">where</span> id <span class="hljs-keyword">IN</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>);</code></pre></div><p>2.导出整个数据库</p><div class="code-wrapper"><pre><code class="hljs sql">mysqldump <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>ppassword dbname<span class="hljs-operator">&gt;</span>dbname.sqlmysqldump <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <span class="hljs-comment">--all-databases &gt;all-data-$(date+%F).sql  # 备份所有数据库</span>mysqldump <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <span class="hljs-comment">--databases auth mysql &gt;auth-mysql.sql    # 备份auth和mysql数据库</span>mysqldump <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p dbname table_name <span class="hljs-operator">&gt;</span>table_name.sql        # 备份数据库mysqldump <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <span class="hljs-operator">-</span>d dbname table_name <span class="hljs-operator">&gt;</span> table_name.sql    # 仅备份表结构mysqldump <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <span class="hljs-operator">-</span>t dbname table_name <span class="hljs-operator">&gt;</span> table_name.sql    # 仅备份数据https:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>zhuanlan.zhihu.com<span class="hljs-operator">/</span>p<span class="hljs-operator">/</span><span class="hljs-number">396005871</span></code></pre></div><p><strong>3.导出表 show variables like '%secure%'查看安全目录</strong></p><div class="code-wrapper"><pre><code class="hljs sql">mysqldump <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p dbname users<span class="hljs-operator">&gt;</span>dbname_users.sql<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> runoob_tbl  <span class="hljs-keyword">INTO</span> OUTFILE <span class="hljs-string">&#x27;/var/lib/mysql-files/Dbug_manangement.txt&#x27;</span>;<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users  <span class="hljs-keyword">INTO</span> OUTFILE <span class="hljs-string">&#x27;/var/lib/mysql-files/users.sql&#x27;</span>;</code></pre></div><p><strong>4.导入备份的整个数据库</strong></p><div class="code-wrapper"><pre><code class="hljs sql">mysql <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <span class="hljs-operator">&lt;</span> Detector.sql     # 需要再<span class="hljs-keyword">sql</span>文件创建或指定数据库mysql<span class="hljs-operator">&gt;</span>source <span class="hljs-operator">/</span>home<span class="hljs-operator">/</span>abc<span class="hljs-operator">/</span>abc.sql      # 进入数据库下use Detector</code></pre></div><p><strong>5.插入数据到某个表</strong></p><div class="code-wrapper"><pre><code class="hljs sql">load data <span class="hljs-keyword">local</span> infile &quot;/var/lib/mysql-files/CaseUrl.sql&quot; <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> CaseUrl;load data <span class="hljs-keyword">local</span> infile &quot;/var/lib/mysql-files/CaseUrl.sql&quot; <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> CaseUrl(id,name, url, status_code, <span class="hljs-keyword">result</span>, processresult, proposal,<span class="hljs-variable">@create_time</span>,test_time,case_id) FIELDS TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;, &#x27;</span><span class="hljs-keyword">set</span> create_time<span class="hljs-operator">=</span>DATE_FORMAT(<span class="hljs-variable">@create_time</span>,&quot;%Y-%m-%d %H:%i:%s&quot;)</code></pre></div><h3 id="Mysql性能优化">Mysql性能优化</h3><blockquote><p>四个维度:</p><p>1.架构</p><p>2.硬件</p><p>3.DB优化</p><p>4.sql优化</p></blockquote><h5 id="架构">架构</h5><blockquote><p>使用集群负载(MariaDB Galera Cluster，Mysql innoDB cluster，Percona XtraDB cluster )，读写分离，数据库切分</p></blockquote><h5 id="硬件">硬件</h5><blockquote><p>高效的磁盘读写性能</p></blockquote><h5 id="DB">DB</h5><blockquote><p>参数优化(日志不能笑,缓存足够大,连接够用)</p><p>my.ini或my.cnf配置文件</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.<span class="hljs-built_in">sort</span>/join/read/rnd buffer:4M或8M或16M</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.tmp/heap table:96M或128M</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.innodb_flush_log_at_trx_commit  <span class="hljs-comment"># 对redo日志刷盘频率的设定</span></span>0:缓冲区的redo log会每秒写入到磁盘的日志文件。但每次事务提交不会有任何影响，也就是 log buffer 的刷写操作和事务提交操作没有关系。在这种情况下，MySQL性能最好，但如果 mysqld 进程崩溃，通常会导致最后 1s 的日志丢失1:每次事务提交时,缓冲区redo log保证一定会被写入到磁盘的日志文件。这也是默认值。这是最安全的配置，但由于每次事务都需要进行磁盘I/O，所以也最慢2:每次事务提交时,缓冲区redo log异步写入(不保证)到磁盘的日志文件。这时如果 mysqld 进程崩溃，由于日志已经写入到系统缓存，所以并不会丢失数据；在操作系统崩溃的情况下，通常会导致最后 1s 的日志丢失。<span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sync_binlog:binlog刷盘的频率</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.innodb_flush_log_at_trx_commit和sync_binlog都设置为1 (保证主库和主从库的一致性)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">5.interactive_timeout:交互模式下超时时间,五分钟或十分钟</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">6.lock_wait_timeout:表锁锁定时间</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">7.time_zone:使用datetime减少性能消耗</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">8.wait_timeout:程序连接mysql超时时间,五分钟或十分钟</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">9.innodb_buffer_pool_size:缓冲池大小(越大,磁盘I/O减少)2个G左右</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">10.innodb_buffer_pool_instances:配置多个缓冲池实例</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">11.tmp_table_size:临时表的最大大小</span></code></pre></div></blockquote><h5 id="sql语句优化">sql语句优化</h5><blockquote><p><a href="https://www.zhihu.com/question/486105337/answer/2538190061">mysql</a></p><p>**explain:**查看sql的执行计划,检查sql语句定位优化点或开启慢查询定位优化点</p><p>优化方向:(避免不要的列|分页优化|索引优化|JOIN优化|排序优化|union优化)</p><p><strong>优化表结构</strong></p><div class="code-wrapper"><pre><code class="hljs scss">&gt;<span class="hljs-number">1</span>.尽量使用数字型字段(引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了)&gt;<span class="hljs-number">2</span>.尽可能的使用 varchar 代替 char(变长字段存储空间小，可以节省存储空间)&gt;<span class="hljs-number">3</span>.索引列大量重复数据时，可以把索引删除掉(比如)</code></pre></div><p><strong>索引优化</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 合理使用索引(一个表索引不超过5个),避免索引失效</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 利用覆盖索引</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 正确使用联合索引</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 避免索引失效情况</span></code></pre></div><p><strong>避免不要的列</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 避免使用<span class="hljs-keyword">select</span> *</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 多用<span class="hljs-built_in">limit</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 选择合理的字段类型</span></code></pre></div><p><strong>分页优化(数据量较大)</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 延迟关联</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 书签方式</span></code></pre></div><p><strong>JOIN优化</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- <span class="hljs-built_in">join</span>表不宜过多(不超过5个)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 小表驱动大表</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">- 用连接查询代替子查询</span></code></pre></div><p><strong>排序优化</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">利用索引排序</span></code></pre></div><p><strong>union优化</strong></p><div class="code-wrapper"><pre><code class="hljs scss">&gt;使用UNION <span class="hljs-attribute">ALL</span>(不去重,所有数据)替代<span class="hljs-built_in">UNION</span>(去重)</code></pre></div></blockquote><h5 id="索引失效的情况">索引失效的情况</h5><div class="code-wrapper"><pre><code class="hljs xquery">(<span class="hljs-number">1</span>)联合索引不满足最左匹配原则,联合索引最左边字段必须出现在查询条件中(<span class="hljs-number">2</span>)错误使用like,以%开头如 like <span class="hljs-string">&#x27;%abc&#x27;</span>,(当like以%结尾索引有效)(<span class="hljs-number">3</span>)错误使用<span class="hljs-keyword">or</span>,<span class="hljs-keyword">or</span>两边字段有一个没有创建索引(<span class="hljs-keyword">where</span><span class="hljs-built_in"> id</span>=<span class="hljs-number">2</span> <span class="hljs-keyword">or</span><span class="hljs-built_in"> name</span>=<span class="hljs-string">&quot;Tom&quot;</span>)或两边为范围查询(<span class="hljs-keyword">where</span><span class="hljs-built_in"> id</span>&gt;<span class="hljs-number">10</span> <span class="hljs-keyword">or</span><span class="hljs-built_in"> id</span>&lt;<span class="hljs-number">20</span>),导致失效(<span class="hljs-number">4</span>)索引列参与运算, 如<span class="hljs-keyword">where</span><span class="hljs-built_in"> id</span>-<span class="hljs-number">1</span>=<span class="hljs-number">10</span> 或使用了函数 <span class="hljs-keyword">where</span> SUBSTR(id_no,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)=<span class="hljs-number">100</span>(<span class="hljs-number">5</span>)类型隐式转换,<span class="hljs-keyword">where</span>条件上进行了类型转换,比如字段是字符串类型,却填上了数字(<span class="hljs-number">6</span>)两列做比较,即使两列都有索引,也会失效 <span class="hljs-keyword">where</span><span class="hljs-built_in"> id</span>&gt;age(<span class="hljs-number">7</span>)不等于比较,<span class="hljs-keyword">where</span><span class="hljs-built_in"> name</span>!=<span class="hljs-string">&quot;Tom&quot;</span> 或 <span class="hljs-keyword">where</span><span class="hljs-built_in"> id</span>&lt;&gt;<span class="hljs-string">&quot;11&quot;</span> 有可能不走索引,查询结果集较小货走索引否则不走索引(<span class="hljs-number">8</span>)非空判断(<span class="hljs-literal">is</span><span class="hljs-built_in"> not</span> null / <span class="hljs-literal">is</span> null /<span class="hljs-built_in"> not</span> <span class="hljs-keyword">in</span> / <span class="hljs-keyword">in</span> /<span class="hljs-built_in"> exists</span> /<span class="hljs-built_in"> not</span><span class="hljs-built_in"> exists</span>/ )使用<span class="hljs-keyword">where</span> id_no <span class="hljs-literal">is</span><span class="hljs-built_in"> not</span> null不走索引,<span class="hljs-literal">is</span> null走索引使<span class="hljs-built_in">用not</span><span class="hljs-built_in"> exists</span> 不走索引使用<span class="hljs-keyword">where</span><span class="hljs-built_in"> id</span><span class="hljs-built_in"> not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)普通索引则失效,主键走索引(<span class="hljs-number">9</span>)当mysql估计全表扫描速度比索引速度快的时候不会使用索引(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span>就是如果是select *则有大量回表,索引不走索引,走全表扫描到内存去排序)</code></pre></div><h3 id="索引详解">索引详解</h3><blockquote><p>操作系统和磁盘:最小单位是块block<br>操作系统和内存:最小单位是页page</p><p>磁盘I/O:文件系统每次读取一块(默认4K)单位大小到内存<br>InnoDB :存储数据以页(page默认16k)为单位,InnoDB 读取一页页读取</p></blockquote><h4 id="索引演化史">索引演化史</h4><blockquote><p>B树和B+树最大区别:</p><p>B的非叶子节点可以存储数据，而B+树只有叶子结点才可以存储数据,一个节点可以存储很多数据，所以B树的高度大大减小，</p><p>但是B树相对于B+树来说，在查找数据的时候，由于每一个节点都有可能包含目标数据，所以查找总是从根节点进行向下搜索，这个特点会带来大量的随机io。</p><p>而在B+树种，因为叶子结点才会存储数据（InnoDB），这样子相比B树一个页大小存储的索引数据就更多了（16K），并且叶子结点通过双向指针指向相邻的节点，依次连接。</p><p>并且相邻结点是有序的，所以对于范围查找是非常方便的，获取到第一个符合条件的，然后通过指针，往后获取数据，直到最后一个不满足条件为止。</p></blockquote><blockquote><p><strong>二叉查找树-&gt;AVL平衡二叉树-&gt;B-Tree(多路平衡查找树)-&gt;B+Tree:</strong><br><strong>B-Tree:</strong></p>  <div class="code-wrapper"><pre><code class="hljs haskell">多路平衡查找树,每个节点包含多对(父节点指针,子节点指针,键key,值<span class="hljs-class"><span class="hljs-keyword">data</span>),相比于<span class="hljs-type">AVL</span>缩减了节点数,</span></code></pre></div><p><strong>B+Tree:</strong></p><div class="code-wrapper"><pre><code class="hljs css"><span class="hljs-number">1</span>.非叶子节点(双向链表)只存储键值+叶子节点指针,<span class="hljs-number">2</span>.值data顺序存在同一层的叶子节点上，相比于<span class="hljs-selector-tag">B</span>-Tree每个节点能存储更多的key减少了树的高度和磁盘<span class="hljs-selector-tag">I</span>/O次数，<span class="hljs-number">3</span>.叶子节点之间有指针,链表支持范围查找通过非叶子节点的二分查找以及指针确定数据在哪个页中,进而去数据页查找数据树的高度为<span class="hljs-number">1</span>-<span class="hljs-number">3</span>:  <span class="hljs-number">1</span>.叶子节点<span class="hljs-number">16</span><span class="hljs-built_in">k</span>(一条数据一般<span class="hljs-number">1</span>k)存<span class="hljs-number">16</span>条数据  <span class="hljs-number">2</span>.非叶子节点存<span class="hljs-number">1170</span>个指针=<span class="hljs-number">1170</span>*<span class="hljs-number">1170</span>*<span class="hljs-number">16</span>=<span class="hljs-number">21902400</span>**</code></pre></div></blockquote><h4 id="什么是索引">什么是索引</h4><blockquote><p>对一列或多列值进行排序的数据结构(类似目录排序好了的,在小文件查找)</p></blockquote><h4 id="mysql有哪些索引-那些字段可以建立对应索引">mysql有哪些索引?那些字段可以建立对应索引</h4><blockquote><p>任何标准版最多创建16个索引列</p><p>普通索引：加快查询主键索引：聚簇索引,唯一索引unique唯一且不为NULL<br>复合索引: <strong>多个字段的索引</strong>最多包含16列:where多条件最左原则),可用于包含所有列或第一列,前两列,前三列…等,blob和text也能创建索引, 但是必须指定前面多少位,组合索引查询遵循<strong>最左前缀原则</strong>,能够避免<strong>回表查询</strong><br>全文索引: char、varchar，text 列上可以创建全文索引,一般不使用,不是mysql专长唯一索引: 唯一性空间索引: 对空间数据类型字段建立索引,mysql有四种:GEOMETRY,POINT,LINESTRING,POLYGON<br><strong>聚簇索引</strong>和<strong>非聚簇索引</strong>：聚簇索引和非聚簇索引的概念比上面的概念要大，属于包含和被包含的关系。例如：InnoDB中主键索引使用的就是聚簇索引</p><p>InnoDB存储引擎中，索引分为 <strong>聚簇索引</strong>和<strong>二级索引</strong>，主键索引就是聚簇索引，其它的索引为二级索引</p></blockquote><h4 id="聚集索引和非聚集索引区别">聚集索引和非聚集索引区别</h4><blockquote><p><strong>都是B+Tree数据结构</strong><br>聚簇索引：索引的叶节点就是数据节点，叶子节点中数据域存储数据文件本身，索引和数据存储在一起</p><p>非聚簇索引：叶节点仍然是索引节点，索引文件和数据文件是分开的，只不过有一个指针指向对应的数据块，所以查询数据会多一次查询</p><p>因此聚簇索引的查询速度会快于非聚簇索引的查询速度，在Mysql的存储引擎中，「InnoDB支持聚簇索引，MyISAM支持非聚簇索引</p></blockquote><h4 id="InnoDB-MyISAM区别">InnoDB/MyISAM区别</h4><blockquote><p>MyISAM:不支持事务,支持表级别锁(限制了读/写的性能),拥有较高的插入和查询速度,B+的非聚簇索引,通常用于只读或以读为主的场景.<br>怎么快速向数据库插入100万条数据?先用MyISAM插入数据,然后修改存储引擎为InnoDB<br>InnoDB:支持事务,支持行/表级别锁,/外键(数据的完整性和一致性更高),采用B+的聚簇索引,通常用于经常更新的场景.</p></blockquote><h4 id="InnoDB和MyISAM索引区别">InnoDB和MyISAM索引区别</h4><blockquote><p>InnoBD主键索引采用B+的聚簇索引:</p><p>每个InnoDB表都有且只有一个特殊的索引，称为聚簇索引 ，用于存储行数据。通常，聚簇索引与主键同义 。</p><ol><li class="lvl-3"><p>表定义了主键,则pk就是聚集索引</p></li><li class="lvl-3"><p>没有定义主键,第一个非空唯一索引列就是聚集索引</p></li><li class="lvl-3"><p>否则,InnoDB会创建一个隐藏的row-id作为聚集索引</p></li></ol><p>MyISAM索引采用B+的非聚簇索引:</p><div class="code-wrapper"><pre><code class="hljs">不存储全部数据,只存储数据行的地址</code></pre></div></blockquote><h4 id="什么是回表">什么是回表</h4><blockquote><p>where不在主键上，则通过非主键索引查询,select所获取的字段不能通过非主键索引获取到,只能查到主键,需要回表通过主键索引查到完整的数据。</p></blockquote><h4 id="覆盖索引-非覆盖索引">覆盖索引,非覆盖索引</h4><blockquote><p>覆盖索引:所查的字段在当前索引叶子节点上存在,不用回表,直接作为结果返回</p></blockquote><h4 id="什么是索引下推">什么是索引下推</h4><blockquote><p>where多条件判断,对索引中包含的字段先做判断,再去回表没有索引的字段(减少回表次数)</p></blockquote><h4 id="什么情况下不推荐使用索引">什么情况下不推荐使用索引</h4><blockquote><p><strong>目的是:索引是为了查询更快,占用空间更小</strong><br>1.数据唯一性差(比如性别只有两种数据)<br>2.频繁更新的字段不用索引<br>3.不用无序的的值如身份证,uuid无序不能作为索引<br>4.字段不在where语句后出现(where含IS NULL/IS NULL/IS NOT NULL/like &quot;%&quot;等,不用索引)<br>5.过长的字段使用前缀索引<br>6.参与计算的字段不适合建立索引<br>7.可能产生乱码的字段作为主键或唯一索引</p><p><strong>那些情况适合建立索引?</strong></p><ol><li class="lvl-3"><p>频繁作为where条件语句查询的字段</p></li><li class="lvl-3"><p>关联字段需要建立索引，例如外键字段，student表中的classid,   classes表中的schoolid 等</p></li><li class="lvl-3"><p>排序字段可以建立索引</p></li></ol></blockquote><h3 id="Mysql预编译">Mysql预编译</h3><blockquote><hr><h4 id="Mysql架构">Mysql架构</h4><div class="code-wrapper"><pre><code class="hljs asciidoc"><span class="hljs-strong">**连接层**</span>：处理连接/鉴权/安全管理<span class="hljs-strong">**服务层**</span>：系统管理/sql接口/缓存/解析/预处理/优化<span class="hljs-strong">**引擎层**</span>：具体与文件系统打交道<span class="hljs-strong">**存储层**</span>:</code></pre></div><h4 id="sql语句执行流程">sql语句执行流程:</h4><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-number">1.</span>客户端发送请求<span class="hljs-number">2.</span>连接器（验证用户身份，给予权限）<span class="hljs-number">3.</span>查询缓存（存在缓存则直接返回，不存在则执行后续操作）<span class="hljs-number">4.</span>分析器（对<span class="hljs-keyword">SQL</span>进行词法分析和语法分析操作）<span class="hljs-number">5.</span>优化器（主要对执行的<span class="hljs-keyword">sql</span>优化选择最优的执行方案方法）<span class="hljs-number">6.</span>执行器（执行时会先看用户是否有执行权限，有才去使用这个引擎提供的接口）<span class="hljs-number">7.</span>去引擎层获取数据返回（如果开启查询缓存则会缓存查询结果）</code></pre></div><p><strong>SQL语句预编译</strong></p><p><strong>益处</strong>:加快执行速度,防止sql注入<br><strong>场景</strong>:SQL语句一样,参数不一样,可以对SQL语句预编译</p><p><strong>语法</strong>:prepare name from statement;</p><ol><li class="lvl-3"><p>定义:prepare statement_1 from ‘select * from user where id=?’; # 通过?进行占位</p></li><li class="lvl-3"><p>参数:set @id=2;</p></li><li class="lvl-3"><p>执行.execute statement_1 using @id;</p></li></ol><p>怎么预防sql注入？</p><ol><li class="lvl-3"><p>不信任用户提交的数据(参数过滤,严格检查参数类型,转义,限制长度)</p></li><li class="lvl-3"><p>.mysql预编译(参数化查询,变量绑定)</p></li></ol></blockquote><h3 id="Mysql-事务">Mysql 事务</h3><h4 id="ACID">ACID?</h4><blockquote><p><strong>原子性(Atomicity)</strong>:(undo log回滚日志实现)指一个事务不可分割,是一个最小的操作单元(包含若干个操作),要么全部成功,要么全部失败<br><strong>隔离性(Isolation)</strong>:(锁和mvcc实现)多个事务并发执行,事务之间相互隔离<br><strong>持久性(Durability)</strong>:(redo log实现)InnoDB提供了一个缓存Buffer,读取和写入都先在Buffer中(并同时把操作记录到redo log,防止数据丢失)<br><strong>一致性(Consistency)</strong>:数据处于合法状态(满足预定约束就是合法)<br>从数据库层面，数据库通过原子性、隔离性、持久性来保证一致性。也就是说ACID四大特性之中，C(一致性)是目的，A(原子性)、I(隔离性)、D(持久性)是手段，是为了保证一致性，数据库提供的手段。数据库必须要实现AID三大特性，才有可能实现一致性。从应用层面，通过代码判断数据库数据是否有效，然后决定回滚还是提交数据。</p><p><strong>Innodb如何实现事务的?</strong><br>以update为例:</p><div class="code-wrapper"><pre><code class="hljs scss">(<span class="hljs-number">1</span>).开启事务,Innodb根据接受的update语句,找到数据所在页,并修改该页缓存在Buffer <span class="hljs-built_in">pool</span>(change buffer)中(<span class="hljs-number">2</span>).执行update,修改Buffer pool中数据(<span class="hljs-number">3</span>).记录 undo log日志(便于事务回滚和mvcc)并写入Log Buffer中并关联redo <span class="hljs-built_in">log</span>(可刷盘)(<span class="hljs-number">4</span>).记录 redo <span class="hljs-built_in">log</span>(prepare状态)日志(便于断电恢复数据)并写入Log Buffer中(可刷盘)(<span class="hljs-number">5</span>).记录bin <span class="hljs-built_in">log</span>(数据表结构变更日志:用于主从复制和数据库恢复)(<span class="hljs-number">6</span>-<span class="hljs-number">1</span>).事务提交,redo <span class="hljs-built_in">log</span>(改为commit状态),可触发redo log刷盘机制(<span class="hljs-number">6</span>-<span class="hljs-number">2</span>).事务回滚,则利用undo log日志进行回滚</code></pre></div><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">MVCC多版本控制:实现MVCC时用到了一致性视图，用于支持读提交和可重复读的实现</span>对于一行数据若是想实现可重复读取或者能够读取数据的另一个事务未提交前的原始值，那么必须对原始数据进行保存或者对更新操作进行保存，这样才能够查询到原始值在Mysql的MVCC中规定每一行数据都有多个不同的版本，一个事务更新操作完后就生成一个新的版本，并不是对全部数据的全量备份，因为全量备份的代价太大了</code></pre></div></blockquote><h4 id="事务隔离级别">事务隔离级别</h4><blockquote><p><strong>问题</strong></p><div class="code-wrapper"><pre><code class="hljs less">&gt;<span class="hljs-number">1</span>.脏读:事务<span class="hljs-selector-tag">A</span>读取了事务<span class="hljs-selector-tag">B</span>已修改还没提交的数据&gt;<span class="hljs-number">2</span>.不可重复读:事务<span class="hljs-selector-tag">A</span>中先后多次读取同一个数据，读取的结果不一样(因为另外一个事务也访问该同一数据，并且可能修改这个数据)&gt;<span class="hljs-number">3</span>.幻读:幻读是针对数据插入（<span class="hljs-selector-tag">INSERT</span>）操作来说的。事务<span class="hljs-selector-tag">A</span>对某些行内容更改还未提交，事务<span class="hljs-selector-tag">B</span>插入了与事务<span class="hljs-selector-tag">A</span>更改前的记录相同的记录行，并在事务<span class="hljs-selector-tag">A</span>提交之前先提交了.在事务<span class="hljs-selector-tag">A</span>中查询，会发现好像刚刚的更改对于某些数据未起作用，但其实是事务<span class="hljs-selector-tag">B</span>刚插入进来的，让用户感觉很魔幻，感觉出现了幻觉，这就叫幻读</code></pre></div><p><strong>隔离级别</strong></p><div class="code-wrapper"><pre><code class="hljs pgsql">&gt;读未提交（<span class="hljs-keyword">READ</span> <span class="hljs-keyword">UNCOMMITTED</span>）&gt;读提交 （<span class="hljs-keyword">READ</span> <span class="hljs-keyword">COMMITTED</span>）&gt;可重复读 （<span class="hljs-keyword">REPEATABLE</span> <span class="hljs-keyword">READ</span>）&gt;串行化 （<span class="hljs-keyword">SERIALIZABLE</span>）&gt;InnoDB默认是可重复读</code></pre></div><table><thead><tr><th style="text-align:left">隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td style="text-align:left">读未提交</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td style="text-align:left">读提交</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td style="text-align:left">可重复读</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td style="text-align:left">串行化</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><p><strong>查看数据库隔离级别</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;transaction_isolation&#x27;</span>;<span class="hljs-operator">&gt;</span><span class="hljs-keyword">SELECT</span> @<span class="hljs-variable">@transaction_isolation</span></code></pre></div><p><strong>修改隔离级别</strong></p><div class="code-wrapper"><pre><code class="hljs pgsql">&gt;<span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> <span class="hljs-keyword">transaction</span> <span class="hljs-keyword">isolation</span> <span class="hljs-keyword">level</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">committed</span>; #改为读提交</code></pre></div></blockquote><h3 id="Mysql有几种日志">Mysql有几种日志</h3><blockquote><p>bin log(二进制日志记录sql)</p><div class="code-wrapper"><pre><code class="hljs gauss">记录了数据库所有执行的DDL和DML语句（除了数据查询语句<span class="hljs-built_in">select</span>、<span class="hljs-keyword">show</span>等），以事件形式记录并保存在二进制文件中</code></pre></div><p><strong>redo log(重做日志): InnoDB特有</strong></p><div class="code-wrapper"><pre><code class="hljs">记录了对于InnoDB存储引擎的事务日志,防止数据丢失，以便数据持久化</code></pre></div><p><strong>undo log(回滚日志): InnoDB特有</strong></p><div class="code-wrapper"><pre><code class="hljs sql">事务执行失败或调用了<span class="hljs-keyword">rollback</span>,利用该日志进行回滚</code></pre></div><p>slow uery log(慢查询日志)</p><div class="code-wrapper"><pre><code class="hljs">记录时间内超过long_query_time这个时间的查询语句,用来定位查询语句查询效率，以便进行优化</code></pre></div><p>general log(一般查询日志)</p><div class="code-wrapper"><pre><code class="hljs">一般查询日志记录了所有对MySQL数据库请求的信息，无论请求是否正确执行</code></pre></div><p>error log(错误日志)</p><div class="code-wrapper"><pre><code class="hljs">错误日志文件对MySQL的启动、运行、关闭过程进行了记录，能帮助定位MySQL问题</code></pre></div></blockquote><h4 id="mysql日志是否实时写入磁盘-log-buffer">mysql日志是否实时写入磁盘?(log buffer)</h4><blockquote><p><strong>bin log</strong></p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">sync_binlog</span>=<span class="hljs-number">0</span>:每次提交事务后不会马上写入到磁盘,先写到page cache,由操作系统决定写入什么时候写入磁盘(有丢失事务日志的风险)<span class="hljs-attr">sync_binlog</span>=<span class="hljs-number">1</span>:每次提交事务都会执行fsync写入磁盘(强一致性,性能较低)<span class="hljs-attr">sync_binlog</span>=n:每次提交事务,先写到page cache,积累n个事务才fsync到磁盘(有丢失n个事务日志的风险)</code></pre></div><p><strong>redo log()和undo log</strong></p><div class="code-wrapper"><pre><code class="hljs ini"><span class="hljs-attr">innodb_flush_log_at_trx_commit</span>=<span class="hljs-number">0</span>:每秒(log buffer中提交的事务)写入磁盘,系统并调用fsync写入磁盘(可能丢失一秒的数据)<span class="hljs-attr">innodb_flush_log_at_trx_commit</span>=<span class="hljs-number">1</span>:有事务提交立即调用fsync写入磁盘(不会丢失,性能差)<span class="hljs-attr">innodb_flush_log_at_trx_commit</span>=<span class="hljs-number">2</span>:有事务提交都写给操作系统的page cache,由操作系统决定什么时候调用fsync写入磁盘(一系列丢失)</code></pre></div></blockquote><h4 id="binlog有几种录入格式">binlog有几种录入格式?</h4><blockquote><p>STATEMENT:默认方式,基于SQL语句的复制记录sql语句,文件较小<br>ROW:基于行的复制,文件较大<br>MIXED:前两种混合</p></blockquote><h4 id="为什么将redo-log的数据写到磁盘比将Buffer数据持久化到磁盘要快">为什么将redo log的数据写到磁盘比将Buffer数据持久化到磁盘要快?</h4><blockquote><p>1.Buffer数据持久化是随机写I/O,redo log是追加,顺序IO<br>2.Buffer数据持久化是以页page为单位,redo log只需要写入的真正部分(减少了无效I/O)</p></blockquote><h4 id="bin-log和redo-log-两段提交-区别？">bin log和redo log(两段提交)区别？</h4><blockquote><p>1.写入redo log(prepare状态)<br>2.写入bing log<br>3.提交事务,redo log(改为commit)</p></blockquote><h3 id="锁机制">锁机制</h3><blockquote><p><strong>锁种类</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.锁粒度划分</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">表锁:粒度最大的锁，开销小，加锁快，不会出现死锁，粒度大导致并发性低()</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">页锁：介于行锁和表锁之间的一种锁,页锁是在BDB中支持的一种锁机制，也很少没人提及和使用</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">行锁: 粒度最小，加锁开销性能大，加锁慢，并且会出现死锁，但是行锁的锁冲突的几率低，并发性能高(行锁是InnoDB默认的支持的锁机制，MyISAM不支持行锁)</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.使用方式划分</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">共享锁、排它锁</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.思路划分</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">乐观锁、悲观锁</span></code></pre></div><p><strong>死锁</strong></p><p>指两个或以上的进程，因争夺资源而互相等待的现象</p><p>关键在于:两个会以上的Session加锁的顺序不一致</p><p>解决关键是: 让不同的Session加锁有序</p><p>排查死锁流程</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.查看死锁日志</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">show engine innodb status\G  <span class="hljs-comment"># 查看当前事务内锁的状态</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.找出死锁sql</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.分析sql加锁情况</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.模拟死锁案发</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">5.分析死锁日志</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">6.分析死锁结果</span></code></pre></div><p>死锁在InnoDB中才会出现死锁</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.对表有高并发时，尽量对该表执行串行化</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.调整SQL 执行顺序， 避免 update/delete 长时间持有锁的SQL在事务前面</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.设置参数,innodb_lock_wait_timeout 超时时间</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.innodb_deadlock_detect打开,当发现死锁时，自动回滚某个事务</span></code></pre></div></blockquote><h3 id="主键方案-自增id-uuid-雪花算法">主键方案(自增id/uuid/雪花算法)</h3><blockquote><p><a href="https://www.zhihu.com/question/397289720">https://www.zhihu.com/question/397289720</a><br><a href="https://juejin.cn/post/7153273187366043661">https://juejin.cn/post/7153273187366043661</a></p></blockquote><h4 id="三种方案">三种方案:</h4><div class="code-wrapper"><pre><code class="hljs">1. 自增id2. uuid: uuid导致页分裂,性能问题,存储空间较大3. 雪花算法及其改进算法</code></pre></div><h4 id="分布式id实现方式">分布式id实现方式:</h4><blockquote><p><strong>满足条件</strong>:</p><p>1.全局唯一:必须保证ID是全局性唯一的</p><p>2.高性能:ID生成响应要快</p><p>3.趋势递增</p><p><strong>常见方式</strong></p><p><strong>1.uuid:</strong></p><div class="code-wrapper"><pre><code class="hljs pgsql"><span class="hljs-type">UUID</span>的核心思想是使用「机器的网卡、当地时间、一个随机数」来生成<span class="hljs-type">UUID</span>缺点:<span class="hljs-number">1.</span><span class="hljs-type">UUID</span>生成的无序的字符串，查询效率低下，<span class="hljs-number">2.</span>不具备自增特性,没有实际的业务含义<span class="hljs-number">3.</span>长度过长影响性能所以都不会使用<span class="hljs-type">UUID</span>作为分布式ID来使用</code></pre></div><p><strong>2.单机数据库自增ID+步长R</strong></p><div class="code-wrapper"><pre><code class="hljs angelscript">数据库的<span class="hljs-built_in">auto</span>_increment自增ID完全可以充当分布式ID缺点:<span class="hljs-number">1.</span>DB单点存在宕机风险，无法扛住高并发场景</code></pre></div><p><strong>3.redis自增ID</strong></p><div class="code-wrapper"><pre><code class="hljs tcl">利用redis的 <span class="hljs-keyword">incr</span>命令实现ID的原子性自增</code></pre></div><p><strong>4.雪花算法(Snowflake)及其改进算法</strong></p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">**雪花算法(保证递增性)**:64位</span><span class="hljs-section">1bit: 正数位</span><span class="hljs-section">41bit: 时间戳</span><span class="hljs-section">5bit: 机器id</span><span class="hljs-section">5bit: 数据中心</span><span class="hljs-section">12bit: 自增值</span></code></pre></div></blockquote><h3 id="性能极限">性能极限</h3><p><strong>mysql性能极限</strong></p><blockquote><p>mysql单表字段数:建议20-50<br>mysql默认单字段大小：最大行长度限制是所有字典的总和,(65535)65532—(21845)21844<br>存储最大空间为1M,可以修改max_allowed_packet=16<br>mysql单表：老版mysql3.22中,还是ISAM存储引擎,单表限制为4GB<br>之后为INNODB 单表限制64TB<br>数据库:<br>Cmshelp 团队做CMS 系统评测时的结果来看,<br>MySQL单表大约在2千万条记录（4G）下能够良好运行，经过数据库的优化后5千万条记录（10G）下运行良好。阿里巴巴《Java 开发手册》提出单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p></blockquote><p><strong>PostgreSQL性能极限</strong></p><blockquote><p>最大单个数据库大小:不限最大数据单表大小:32TB<br>单条记录大小:1.6TB<br>单字段最大允许:1GB<br>单表允许最大记录数:不限单表最大字段数:250-1600取决于字段类型单表最大索引数:不限</p></blockquote><h3 id="主从方案">主从方案</h3><blockquote><p>Mysql主从复制中有三个线程:Master(binlog dump thread) Slave(I/O thread,SQL thread)<br>使用binlog+position偏移量进行增量同步</p><p><strong>同步过程</strong></p><ol><li class="lvl-5"><p>Master所有变更都记录到binlog中去(MySQL Server层的实现)</p></li><li class="lvl-5"><p>主节点binlog dump线程,当binlog有变动时,binlog dump线程读取内容并发送给从节点</p></li><li class="lvl-5"><p>从节点I/O线程接收binlog,并写入到relay log(中继日志)中</p></li><li class="lvl-5"><p>从节点SQL线程读取relay log并对数据进行重放</p></li></ol><p><strong>同步策略</strong></p><ul class="lvl-1"><li class="lvl-2"><p>同步策略:Master会等待所有的Slave回应后才提交(这个策略严重影响性能)</p></li><li class="lvl-2"><p>半同步策略:Master至少等待一个Slave回应后才提交</p></li><li class="lvl-2"><p>异步策略:Master不会等待Slave回应就可以提交(默认)</p></li><li class="lvl-2"><p>延迟策略:Slave落后Master指定的时间</p></li></ul><p><strong>同步延迟原因</strong></p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-operator">&gt;</span>从服务器的里面读取binlog的线程仅有一个，从服务器<span class="hljs-keyword">sql</span>执行时间过长或<span class="hljs-keyword">sql</span>对表上锁了，主服务器的<span class="hljs-keyword">SQL</span>大量积压，未被同步到从服务器里</code></pre></div><p><strong>同步延迟解决</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.选择更好的从服务器，或从服务器只做备份</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.sync_binlog=1，innodb_flush_log_at_trx_commit = 1 都设置为1</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.</span></code></pre></div></blockquote><p>mysql如何保证主从数据的一致性的？</p><p>分片中间件:myCat/shardingSphere</p><p><strong>一主多从:缓解读压力</strong></p><ol><li class="lvl-3"><p>主服务配置mysql.cnf:</p><blockquote><p>#主服务还需要创建对应权限的用户用于数据同步</p><p>log-bin=mysql-bin   # 表示启用二进制文件-文件名称<br>server-id=3307      # 表示server编号</p></blockquote></li><li class="lvl-3"><p>从服务执行sql命令</p><blockquote><p># 1.配置主服务</p><p>change master to master_host=“192.168.1.2”,master_port=3306,master_user=“copy”,master_password=“123456”,master_log_file=“mysql-bin.00001”,master_log_pos=154;</p><p># 2.开启主从同步</p><p>start slave</p><p># 3.查看是否成功</p><p>show slave status \G;</p></blockquote></li></ol><p><strong>双主双从:缓解写压力</strong></p><ol><li class="lvl-3"><p>主1配置</p><blockquote><p>log-bin=mysql-bin</p><p>server-id=3301</p><p>auto_increment_increment=2 # 主键递增步长</p><p>auto_increment_offset=1   # 从1开始</p><p>log-slave-updates      # 是否记录binglog</p><p>sync-binlog=1        # 几次事务记录binlog</p></blockquote></li><li class="lvl-3"><p>主2配置</p><blockquote><p>log-bin=mysql-bin</p><p>server-id=3302</p><p>auto_increment_increment=2 # 主键递增步长</p><p>auto_increment_offset=2   # 从1开始</p><p>log-slave-updates      # 是否记录binglog</p><p>sync-binlog=1        # 几次事务记录binlog</p></blockquote></li></ol><h3 id="集群">集群</h3><blockquote><p>raft协议:<br>MariaDB Galera Cluster<br>Mysql innoDB cluster<br>Percona XtraDB cluster</p></blockquote><h3 id="额外问题及思路">额外问题及思路</h3><p><strong>“Lost connection to MySQL server during query” ?</strong></p><blockquote><p>1网络延迟高<br>2.读/写:导致数据传输超时，net_read_timeout/net_write_timeout<br>3.连接初始化超时,connect_timeout 默认30s<br>4.传输中使用了较大的string field或blob field 导致超过了max_allowed_packet<br><a href="https://blog.csdn.net/zyself/article/details/91376690">https://blog.csdn.net/zyself/article/details/91376690</a></p></blockquote><p><strong>数据库的三大范？</strong></p><blockquote><p>为设计冗余小,结构合理的数据库,设计数据库时必须满足一定范式(规则)<br>一般设计都是反范式,通过冗余的数据避免跨表垮库查询,利用空间换时间,提高性能第一范式:表中所有字段是不可分解的原子值第二范式:表中每一列都和主键相关,而不能只与主键一部分相关(针对联合主键)(表中只保存一种数据,不可以把多种数据保存在同一个表中)<br>第三范式:确保每列都和主键直接相关而不是间接相关</p></blockquote><h4 id="varcahr和char区别？"><strong>varcahr和char区别？</strong></h4><blockquote><p>char(最多存放255个字节)适用数据大小固定/较小/经常更新/不容易产生内存碎片:<br>1.长度固定,插入数据小于固定长度则用空格填充<br>2.存取速度比varchar快很多(甚至50%),空间换时间<br>varchar(最多存放(65535)65532个字节,等价于(21845)21844字符):<br>1.varchar=长度+N(实际长度n&gt;255,用两个字节存放长度.小于255,用一个字节存放长度)<br>2.长度可变,按实际插入数据来存储()<br>3.填写2的n次方,varchar(8),varchar(64)<br>4.因为InnoDB 的数据页默认是 16K，每个页中至少存放 2 行数据，因此建议VARCHAR字段的总长度不要超过 8K=8192字节byte。</p></blockquote><blockquote><p>InnoDB表索引前缀长度为767字节,utf-8编码为255(255*3=765)<br>对text,只能添加前缀索引,前缀索引最大能达到1000字节当varchar大于某些值:<br>varchar大于255自动变为tinytext<br>varchar大于500自动变为tinytext<br>varchar大于20000自动变为tinytext<br>当varchar&gt;255,使用varchar或text没有区别</p></blockquote><h4 id="blob和text区别？"><strong>blob和text区别？</strong></h4><blockquote><p>blob:二进制大对象(存储二进制数据,没有字符集)最大长度16k<br>text:大对象,存储大字符串,有字符集(根据字符集的校对规则对值进行排序比较)最大长度16k</p></blockquote><h4 id="DATETIME和TIMESTAMP区别？"><strong>DATETIME和TIMESTAMP区别？</strong></h4><blockquote><p>都表示日期和时间,格式一致,存储秒后6位小数区别日期范围:DATETIME(1000-01-01到9999-12-31),TIMESTAMP(1970-01-01到2038-01-09)<br>存储空间:DATETIM为8字节,TIMESTAMP为4字节时区:DATETIME与时区无关,TIMESTAMP与时区有关默认值:DATETIME默认为null,TIMESTAMP默认为当前时间,不为空(not null)</p></blockquote><h4 id="in和exists的区别？"><strong>in和exists的区别？</strong></h4><blockquote><p><a href="https://blog.csdn.net/jinjiniao1/article/details/92666614">https://blog.csdn.net/jinjiniao1/article/details/92666614</a></p></blockquote><h4 id="DECIMAL记录货币？"><strong>DECIMAL记录货币？</strong></h4><blockquote><p>float和double是二进制存储,有误差<br>decimal是字符串存储</p></blockquote><h4 id="怎么存储表情包emoji"><strong>怎么存储表情包emoji?</strong></h4><blockquote><p>字符串存储utf-8+mb4编码</p></blockquote><h4 id="字符集和排序规则">字符集和排序规则</h4><blockquote><p>参考:</p><p><a href="https://blog.csdn.net/hsuehgw/article/details/128737673">MySQL建立数据库时字符集和排序规则的选择</a></p><p><a href="https://blog.csdn.net/qq_17555933/article/details/101445526">utf8mb4总结</a></p></blockquote><h4 id="大量外键问题？"><strong>大量外键问题？</strong></h4><blockquote><p>不影响select，影响update/insert/delete(当对子表进行写入操作,父表会被加上共享锁,对子表进行高并发时,父表的共享锁长时间不能释放,就不能对父表进行写入而只能读)</p></blockquote><blockquote><p>WAL技术(Write-Ahead Logging)RedoLog(对所有页面的操作写入日志文件,实现事务的持久性)</p></blockquote><h4 id="delete删除记录使用binlog回滚？"><strong>delete删除记录使用binlog回滚？</strong></h4><blockquote><p>恢复数据时可以先备份,在停止所有写入操作:flush tables with read lock或 set global read_only=1同时配置文件里设置read_only防止重启失效</p><ol><li class="lvl-3"><p>查看binglog是否开启</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%log_bin%&#x27;</span>;</code></pre></div></li><li class="lvl-3"><p>查看数据文件存放路径</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%datadir%&#x27;</span>;<span class="hljs-keyword">show</span> master status;  # 查看当前正在写入的binlog<span class="hljs-keyword">show</span> master logs;    # 查看所有binlog  <span class="hljs-keyword">show</span> <span class="hljs-type">binary</span> logs;</code></pre></div></li><li class="lvl-3"><p>查看binlog日志内容</p><div class="code-wrapper"><pre><code class="hljs sql"><span class="hljs-keyword">show</span> binlog events <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;mysql-bin.000001&#x27;</span>\G;  # 确定需要回滚的事务的position</code></pre></div></li><li class="lvl-3"><p>将需要恢复的事务里的操作转为sql</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_"> #</span><span class="language-bash">使用--start-position或--start-datetime=<span class="hljs-string">&quot;2022-03-20 10:00:00&quot;</span></span>/opt/bitnami/mysql/bin/mysqlbinlog  --no-defaults -v --database=database_name --start-position=&quot;966048&quot; --stop-position=&quot;981142&quot; /bitnami/mysql/data/mysql-bin.000007 &gt; /tmp/mysqllog.sql</code></pre></div></li><li class="lvl-3"><p>将导出导出sql的delete转换为insert</p></li></ol><p><code>shell cat srliao.sql.bak| sed -n '/###/p' | sed 's/### //g;s/\/\*.*/,/g;s/DELETE FROM/;INSERT INTO/g;s/WHERE/SELECT/g;' |sed -r 's/(@17.*),/\1;/g' | sed 's/@1=//g'| sed 's/@[1-9]=/,/g' | sed 's/@[1-9][0-9]=/,/g' &gt; mysqllogOK.sql </code></p><ol start="6"><li class="lvl-3"><p>执行insert sql</p><div class="code-wrapper"><pre><code class="hljs shell">source /tmp/mysqllogOK.sql</code></pre></div></li></ol></blockquote><h4 id="大公司为什么不使用外键强关联问题？"><strong>大公司为什么不使用外键强关联问题？</strong></h4><blockquote><p>主要存在以下问题<br>1.在该表进行增删改查会触发查询关联表的记录是否存在,该性能消耗系统是允许的<br>2.数据一致性全部交给数据库,数据库是否能承受<br>3.查询关联表上会做一个内部锁,是否存在高并发死锁情况<br>4.后期的分库分表,外键约束格外离谱这些问题在互联网公司显得很严重,访问量大的时候,mysql系统上无法得到解决的<br><a href="https://www.cnblogs.com/JethroYu/p/13570630.html">https://www.cnblogs.com/JethroYu/p/13570630.html</a></p></blockquote><h4 id="delete-truncate-drop有什么区别"><strong>delete,truncate,drop有什么区别?</strong></h4><blockquote><p><strong>执行速度</strong>:drop&gt;truncate&gt;delete</p></blockquote><p><strong>1.delete</strong></p><blockquote><p>1.属于数据库DML操作语言,只删数据不删表结构,会走事务,执行时触发trigger<br>2.delete执行时,会将删除数据缓存到rollback segement中,事务commit之后生效<br>3.delete删除全部数据,MyISAM会立刻释放磁盘空间,InnoDB不会释放<br>4.delete from table_name where 带条件的MyISAM和InnoDB都不会释放磁盘空间<br>5.delete之后optimize table table_name会立刻释放磁盘空间,不管MyISAM或InnoDB<br>6.delete操作是一行一行删除,且产生删除操作日志,并记录到redo和undo<br>7.delete删除后id会继续递增<br>ALTER TABLE TableName AUTO_INCREMENT=1； # 将auto_increment重置</p></blockquote><p><strong>2.truncate</strong></p><blockquote><p>1.属于DDL定义语言,不走事务,原数据不放到rollback segement中,执行不触发trigger<br>2.truncate table table_name会立刻释放磁盘空间不论MyISAM或InnoDB,类似drop table然后create table,做了优化<br>3.快速清空表,并重置auto_increment的值<br>MyISAM：truncate会重置auto_increment为1,delete后不变<br>InnoDB: truncate会重置auto_incrment为1,delete后不变(delete之后重启则auto_increment为1)<br>也就是说，InnoDB的表本身是无法持久保存auto_increment。delete表之后auto_increment仍然保存在内存，但是重启后就丢失了，只能从1开始。实质上重启后的auto_increment会从 SELECT 1+MAX(ai_col) FROM t 开始。</p></blockquote><blockquote><p>SET FOREIGN_KEY_CHECKS=0;            #取消外键约束<br>TRUNCATE TABLE  table_name;<br>SET FOREIGN_KEY_CHECKS=1;            #设置外键约束:</p></blockquote><p><strong>3.drop</strong></p><blockquote><p>1.属于DDL定义的语言<br>2.drop之后立刻释放磁盘空间,不管是MyISAM或InnoDB<br>3.drop且删除表结构,被依赖的约束(constrain),触发器(trigger),索引(index)<br>4.依赖该表的存储过程/函数将保留,状态为invalid<br>delete是把目录撕了，truncate是把书的内容撕下来烧了，drop是把书烧了</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;mysql常用操作命令&lt;/p&gt;
&lt;p&gt;mysql:单进程多线程模型,一个SQL语句无法利用多个cpu core&lt;/p&gt;
&lt;h3 id=&quot;一-基本命令&quot;&gt;一:基本命令&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;0.查看当前连接数&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;cod</summary>
      
    
    
    
    <category term="数据库" scheme="https://centyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="mysql" scheme="https://centyuan.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Elasticsearch Note</title>
    <link href="https://centyuan.github.io/2023/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch_Note/"/>
    <id>https://centyuan.github.io/2023/11/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Elasticsearch_Note/</id>
    <published>2023-11-23T13:02:23.860Z</published>
    <updated>2023-11-23T14:33:15.265Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本概念">基本概念</h4><blockquote><p><strong>索引Index:</strong></p><div class="code-wrapper"><pre><code class="hljs delphi">&gt;一个索引就是相似特征的文档集合，同比预于mysql的表，mongodb的文档<span class="hljs-comment">(**保存一个文档doc到elasticsearch中的过程也叫索引(indexing)**)</span></code></pre></div><p><strong>映射mapping:</strong></p><div class="code-wrapper"><pre><code class="hljs scss">&gt;处理数据的方式和规则(比如: 字段的数据类型，默认值，分析器，是否被索引，包括设置分片数(number_of_shards)和副本数(number_of_replicas))&gt;ES 的Mapping 类似于传统关系型数据库的表结构定义</code></pre></div><p><strong>分片Shards:</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">一个索引可以存储超出单个节点硬件限制的大量数据，所有索引分片数决定了一个索引的最大存储</span></code></pre></div><p><strong>副本Replicas:</strong></p><p><strong>什么是倒排索引?</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Elasticsearch分别为每个field都建立了一个倒排索引</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Term到所有包含该Term的文档的DocId列表的映射。ES 默认会对写入的数据都建立索引，并且常驻内存</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">我们首先将每个文档的content域拆分成单独的词（我们称它为词条或tokens ），创建一个包含所有不重复词条的排序列表，然后列出每个词条出现在哪个文档</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">总结:文档关键词到文档<span class="hljs-built_in">id</span>的映射</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">主要采用以下几种数据结构</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.倒排索引:保存了每个term对应的docId的列表，采用skipList的结构保存，用于快速跳跃</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.FST（Finite State Transducer）: 原理上可以理解为前缀树，用于保存term字典的二级索引，用于加速查询，可以在FST上实现单Term、Term范围、Term前缀和通配符查询等。内部结构如下</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.BKD-Tree： KD-Tree是一种保存多维空间点的数据结构，主要用于数值类型(包括空间点)的快速查找。</span></code></pre></div><p><strong>动态更新索引</strong></p><p>引入了按段搜索的概念。<strong>每一段本身都是一个倒排索引</strong></p></blockquote><h4 id="路由计算">路由计算</h4><blockquote><p>当索引一个文档的时候,文档会被存储到一个主分片中,<code>需要路由计算来确定文档应该存到那个分片中</code></p><p>计算公式:</p><p>shard = hash(rouging) % number_of_primary_shards   # 最后会得到一个数：0到number_of_primary_shards-1</p><p>routing: 是一个可变值,默认为文档的**_id**</p><p>number_of_primary_shards: 主分片数量</p><p>所以索引创建时候确定了主分片数量后,就永远不能改变了，不然会导致之前所有路由的值都失效，文档在也找不到了</p></blockquote><h4 id="文档操作流程">文档操作流程</h4><h5 id="文档写流程">文档写流程</h5><blockquote><p>1.client向任一节点发送请求</p><p>2.节点通过文档的_id确定文档属于那个分片，将请求转发到对应<code>主分片</code>的节点上</p><p>3.主分片执行成功后，并发将请求转发到副本分片上去，所有副本都成功后，将向客户端返回成功信息</p><p><strong>注意事项</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.对于文档的新建，索引的创建和删除都写操作，必须在主分片上进行，然后在复制到副本上</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.ES为了提高写入能力，采用并发写的方式，为了解决并发写过程中数据冲突问题，ES通过乐观锁控制(每个文档都有一个_version，文档修改时版本号递增)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">并发模式下，只要有副本在，写入延时最小也是两次单分片的写入耗时总和，效率会较低，但是这样的好处也很明显，避免写入后单个机器硬件故障导致数据丢失，在数据完整性和性能方面，一般都是优先选择数据，除非一些允许丢数据的特殊场景</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.一旦所有的副本分片都报告写成功才会向协调节点报告成功，协调节点向客户端报告成功</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.`ES为减少磁盘I/O次数，一般是每隔一段时间才会把数据写入磁盘持久化`</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">对于内存数据丢失问题，ES借鉴数据库处理方式，增加Commitlog，在ES中叫translog(类似于mysql的binlog,用于宕机后内存数据的恢复，保存未持久化数据的操作日志)</span></code></pre></div></blockquote><h5 id="文档读流程">文档读流程</h5><blockquote><p>可以从主分片或任意副本分片检索文档</p><p>1.向任一节点发送请求</p><p>2.通过文档_id确定分片，由于 存在副本分片，通过轮训方式来确定访问那个节点的分片</p><p>3.分片节点将文档返回给协调节点，协调节点在将文档返回给客户端</p><p>在处理读取请求时，<strong>协调结点在每次请求的时候都会通过轮询所有的副本分片来达到负载均衡</strong>，已经被索引的文档可能已经存在于主分片上但是还没有复制到副本分片。在这种情况下，副本分片可能会报告文档不存在，但是主分片可能成功返回文档</p></blockquote><h5 id="文档删除更新">文档删除更新</h5><blockquote><p>段是不可改变的，只是在 <code>.del</code> 文件中被 <em>标记</em> 删除</p><p><strong>近实时搜索</strong></p><p>按段搜索降低了文档从索引到可被搜素的延迟，但是还是不够(Commiting 提交到磁盘还是很慢)</p><p>在Elasticsearch和磁盘之间是文件系统缓存：</p><p>在内存索引缓冲区中的文档会被写入到一个新的段中。但是这里新段会被先写入到文件系统缓存—这一步代价会比较低，稍后再被刷新到磁盘—这一步代价比较高。不过只要文件已经在缓存中，就可以像其它文件一样被打开和读取了(<strong>缓冲区的内容已经被写入一个可被搜索的段中，但还没有进行提交</strong>)</p></blockquote><h4 id="存储原理">存储原理</h4><blockquote><p>ES基于Lucene实现的，当添加一份文档时候，会经过一下流程</p><p>1.Lucene进行分词等预处理</p><p>2.将文档索引写入内存中，并将操作写入事务日志(translog，类似于mysql的binlog,保存未持久化数据的操作日志，用于宕机后内存数据恢复)</p><p>3.Lucene每隔<code>refresh_interval</code>(配置项)时间将内存数据刷入到文件系统缓存中，称为segment，刷入文件系统缓存后，segment才可以被用于检索</p><p>默认情况下，Lucene每隔30min或segment 空间大于512M，将缓存中的segment持久化落盘，称为一个commit point，此时删掉对应的transLog</p><p>在Elasticsearch 中，写入和打开一个新段的轻量的过程叫做<code>refresh</code> 。<strong>默认情况下每个分片会每秒自动刷新一次</strong>。这就是为什么我们说Elasticsearch 是近实时搜索: <strong>文档的变化并不是立即对搜索可见，但会在一秒之内变为可见</strong></p><p>并不是所有情况都需要每秒刷新,可以设置refresh_interval，降低每个索引刷新频率，达到优化索引速度</p><p><strong>段合并</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">由于自动刷新每秒会创建一个新的段,这样会导致短时间内段的激增,段太多会消耗文件句柄并且每个请求都必须轮流检查每个段</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">通过段合并来解决问题</span></code></pre></div></blockquote><h4 id="文档查询的优化">文档查询的优化</h4><blockquote><p>1.分片规模(为了让分片查询性能发挥到最优,需要对规模进行限制)</p><p>2.增加副本数(分摊查询的负载)</p><p>3.Mapping设计</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.ES 默认会建立索引，行存，列存。对于某些并不重要的字段，可以通过指定（index: <span class="hljs-literal">false</span> ， store: <span class="hljs-literal">false</span> ，doc_values: <span class="hljs-literal">false</span>）来关闭，以减少冗余存储成本</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.ES 默认对于数值字段建立BKDTree 索引，但是倒排索引能够最大发挥Lucene 的查询性能。所以对于有限枚举值的数值字段，也建议使用keyword 类型以创建倒排索引</span></code></pre></div><p>4.<strong>查询 Routing 路由优化</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">单个查询会扫描所有分片，容易遇到长尾效应，且大量节点在空转，可利用ES路由能力，大幅提高查询吞吐、降低长尾</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">过写入时支持指定routing ，ES 会计算 target_shard_id = <span class="hljs-built_in">hash</span>(routing) 将写入数据路由到指定分片上，这样在查询时，也可以通过指定routing，快速定位到目前数据所在的分片，查询的效率能够提升一个数量级</span></code></pre></div><p><a href="https://zhuanlan.zhihu.com/p/647279604">ES查询优化攻略</a></p></blockquote><h4 id="文档写入速度的优化">文档写入速度的优化</h4><blockquote><p>ES的默认配置是综合了数据的可靠性和写入程度,实际需要根据场景优化</p><div class="code-wrapper"><pre><code class="hljs pgsql">&gt;<span class="hljs-number">1.</span>加大Translog Flush，目的是降低Iops、WriteblockFlush的目的将操作系统的文件缓存中的段持久化到硬盘，Translog 的数据量达到<span class="hljs-number">512</span>MB 或者<span class="hljs-number">30</span> 分钟时，会触发一次Flush&gt;<span class="hljs-number">2.</span>增加<span class="hljs-keyword">Index</span> <span class="hljs-keyword">Refresh</span> 间隔，目的是减少Segment Merge 的次数 新的数据写入索引时，Lucene 就会自动创建一个新的段，Lucene 将待写入的数据先写到内存中，超过<span class="hljs-number">1</span> 秒（默认）时就会触发一次<span class="hljs-keyword">Refresh</span>，然后<span class="hljs-keyword">Refresh</span> 会把内存中的的数据刷新到操作系统的文件缓存系统中&gt;<span class="hljs-number">3.</span>调整Bulk 线程池和队列&gt;<span class="hljs-number">4.</span>优化节点间的任务分布&gt;<span class="hljs-number">5.</span>优化Lucene 层的索引建立，目的是降低CPU 及IO&gt;<span class="hljs-number">6.</span>大批量写的时候，可以先禁止<span class="hljs-keyword">Replica</span>复制设置<span class="hljs-keyword">index</span>.number_of_replicas: <span class="hljs-number">0</span> 关闭副本。在写入完成后，<span class="hljs-keyword">Replica</span> 修改回正常的状态</code></pre></div></blockquote><h4 id="ES节点和集群">ES节点和集群</h4><h5 id="节点">节点</h5><blockquote><p>一个节点就是一个运行的ES实例,每个节点都有一个唯一的名称作为身份标识，如果没有设置名称，默认使用 UUID 作为名称每个节点都知道集群中任一文档的位置，可以直接将请求转发到任一节点，每个节点都可以扮演协调节点(coordinating node)角色</p></blockquote><h5 id="节点角色">节点角色</h5><blockquote><p>ES中节点有角色的区分的，通过配置文件conf/elasticsearch.yml中配置以下配置进行角色的设定</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">node.master:  <span class="hljs-literal">true</span>/false</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">node.data: <span class="hljs-literal">true</span>/false</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">（1）仅为候选主节点</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">（2）既是候选主节点也是数据节点</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">（3）仅为数据节点</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">（4）既不是候选主节点也不是数据节点</span></code></pre></div><p>Mater节点：无需参与文档层面的变更和搜索，负责管理集群的变更(如索引的创建和删除，节点的加入和删除)</p><p>data节点: 持有数据和倒排索引</p><p>client节点: 将node.master和node.data都设置成false，那么该节点就是一个客户端节点，将请求路由到集群其他节点，扮演一个协调节点角色，用于负载均衡</p></blockquote><h5 id="节点发现机制">节点发现机制</h5><blockquote><p>ZenDiscovery 是ES内置发现机制，提供<code>多播</code>和<code>单播</code>两种方式</p><p><strong>多播:</strong></p><div class="code-wrapper"><pre><code class="hljs gcode">&gt;一个节点可以向多台机器发送请求<span class="hljs-comment">(生产中不建议这样用,会产生大量不必要的通信)</span></code></pre></div><p><strong>单播:(默认)</strong></p><div class="code-wrapper"><pre><code class="hljs crmsh">&gt;当一个节点请求到单播列表中的成员时，就会得到整个集群所有节点的状态，然后请求<span class="hljs-literal">master</span>节点并加入集群</code></pre></div></blockquote><h5 id="选主">选主</h5><blockquote><p><strong>选主流程</strong></p><p>Es的master就是从activeMasters列表或者masterCandidates列表选举出来</p><p>1.筛选activeMasters列表</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Elasticsearch节点成员首先向集群中的所有成员发送Ping请求，elasticsearch默认等待discovery.zen.ping_timeout时间，然后elasticsearch针对获取的全部response进行过滤，筛选出其中activeMasters列表，activeMaster列表是其它节点认为的当前集群的Master节点</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">在获取activeMasters列表的时候会排除本地节点，目的是为了避免脑裂问题</span></code></pre></div><p>2.筛选masterCandidatess</p><div class="code-wrapper"><pre><code class="hljs crmsh">&gt;masterCandidates列表是当前集群有资格成为<span class="hljs-literal">Master</span>的节点，在elasticsearch.yml中配置了如下参数，那么这个节点就没有资格成为<span class="hljs-literal">Master</span>节点，也就不会被筛选进入masterCandidates列表&gt;node.<span class="hljs-literal">master</span>:<span class="hljs-literal">false</span></code></pre></div><p>3.从activeMaters列表选举Master节点</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">activeMasters列表不为空，elasticsearch会优先从activeMasters列表中选举</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">选举算法是Bully算法</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">会涉及到优先级比较，选择优先级最高的，在选择<span class="hljs-built_in">id</span>最小的节点</span></code></pre></div><p>4.从masterCandidates列表选举Master节点</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">activeMasters列表节点为空，则从masterCandidates列表选举</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">首先会判断masterCandidates列表成员数目是否达到了最小数目discovery.zen.minimum_master_nodes</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">在比较节点拥有集群状态版本编号(让拥有最新集群状态节点成为master)，比较优先级和<span class="hljs-built_in">id</span></span></code></pre></div><p>5.节点是master</p><div class="code-wrapper"><pre><code class="hljs crmsh">&gt;上面流程会选举出一个**准<span class="hljs-literal">master</span>**节点&gt;准<span class="hljs-literal">master</span>节点等待其它节点的投票，有discovery.zen.minimum_master_nodes-<span class="hljs-number">1</span>个节点投票认为当前节点是<span class="hljs-literal">master</span>，选举就成功，&gt;准<span class="hljs-literal">master</span>会等待discovery.zen.master_election.wait_for_joins_timeout时间，超时则就失败，失败会重新进行选举&gt;本地节点是<span class="hljs-literal">Master</span>时候:&gt;<span class="hljs-literal">Master</span>节点会开启错误检测(NodeFaultDetection机制)，它节点会定期扫描集群所有的成员，将失活的成员移除集群，同时将最新的集群状态发布到集群中，集群成员收到最新的集群状态后会进行相应的调整，比如重新选择主分片，进行数据复制等操作</code></pre></div><p>6.节点不是master</p><div class="code-wrapper"><pre><code class="hljs crmsh">&gt;当前节点判定在集群当前状态下如果自己不可能是<span class="hljs-literal">master</span>节点，首先会禁止其他节点加入自己，然后投票选举出准<span class="hljs-literal">Master</span>节点。同时监听<span class="hljs-literal">master</span>发布的集群状态(MasterFaultDetection机制)，如果集群状态显示的<span class="hljs-literal">master</span>节点和当前节点认为的<span class="hljs-literal">master</span>节点不是同一个节点，那么当前节点就重新发起选举。&gt;非<span class="hljs-literal">Master</span>节点也会监听<span class="hljs-literal">Master</span>节点进行错误检测，如果成员节点发现<span class="hljs-literal">master</span>连接不上，重新加入新的<span class="hljs-literal">Master</span>节点，如果发现当前集群中有很多节点都连不上<span class="hljs-literal">master</span>节点，那么会重新发起选举。</code></pre></div><p><strong>脑裂问题</strong></p><div class="code-wrapper"><pre><code class="hljs crmsh">&gt;集群中不同的节点对于<span class="hljs-literal">master</span>的选择出现了分歧，出现了多个<span class="hljs-literal">master</span>竞争,这种现象称为脑裂&gt;`脑裂问题可能的原因`&gt;<span class="hljs-number">1</span>.网络问题: 节点访问不到<span class="hljs-literal">Master</span>，而选举新的<span class="hljs-literal">Master</span>，实际<span class="hljs-literal">master</span>并没有宕机&gt;<span class="hljs-number">2</span>.节点负载: 主节点的角色既为<span class="hljs-literal">master</span>又为data，访问量较大时可能会导致ES停止响应造成大面积延迟，此时其他节点得不到主节点的响应认为主节点挂掉了，会重新选取主节点&gt;<span class="hljs-number">3</span>.内存回收: data节点上的ES进程占用的内存较大，引发JVM的大规模内存回收，造成ES进程失去响应</code></pre></div><p><strong>脑裂问题解决方式</strong></p><div class="code-wrapper"><pre><code class="hljs stylus">&gt;<span class="hljs-number">1</span>.减少误判:discovery<span class="hljs-selector-class">.zen</span>.ping_timeout节点状态的响应时间，默认为<span class="hljs-number">3s</span>，可以适当调大，如果master在该响应时间的范围内没有做出响应应答，判断该节点已经挂掉了。调大参数（如<span class="hljs-number">6s</span>，discovery<span class="hljs-selector-class">.zen</span><span class="hljs-selector-class">.ping_timeout</span>:<span class="hljs-number">6</span>），可适当减少误判&gt;<span class="hljs-number">2</span>.选举触发: discovery<span class="hljs-selector-class">.zen</span><span class="hljs-selector-class">.minimum_master_nodes</span>:<span class="hljs-number">1</span>&gt;当备选主节点的个数大于等于该参数的值，且备选主节点中有该参数个节点认为主节点挂了，进行选举。官方建议为（n/<span class="hljs-number">2</span>）+<span class="hljs-number">1</span>，n为主节点个数（即有资格成为主节点的节点个数）&gt;<span class="hljs-number">3</span>.角色分离:即master节点与data节点分离，限制角色&gt;主节点配置为：node<span class="hljs-selector-class">.master</span>: true node<span class="hljs-selector-class">.data</span>: false&gt;从节点配置为：node<span class="hljs-selector-class">.master</span>: false node<span class="hljs-selector-class">.data</span>: true</code></pre></div></blockquote><h4 id="三种ES基本操作">三种ES基本操作</h4><blockquote><p>1.使用request发送http请求</p><p>2.使用官方提供的elasticsearch</p><p>3.ORM包elasticsearch-dsl</p></blockquote><h5 id="查询描述">查询描述</h5><div class="code-wrapper"><pre><code class="hljs lasso"><span class="hljs-number">1</span>、must (must字段对应的是个列表，也就是说可以有多个并列的查询条件，一个文档满足各个子条件后才最终返回)<span class="hljs-number">2</span>、should (只要符合其中一个条件就返回)<span class="hljs-number">3</span>、must_not (与must相反，也就是说可以有多个并列的查询条件，一个文档各个子条件后才最终的结果都不满足)<span class="hljs-number">4</span>、filter(条件过滤查询，过滤条件的范围用range表示<span class="hljs-literal">gt</span>表示大于、<span class="hljs-literal">lt</span>表示小于、<span class="hljs-literal">gte</span>表示大于等于、<span class="hljs-literal">lte</span>表示小于等于)bool查询总结    must：与关系，相当于关系型数据库中的 <span class="hljs-literal">and</span>。    should：或关系，相当于关系型数据库中的 <span class="hljs-literal">or</span>。    must_not：非关系，相当于关系型数据库中的 <span class="hljs-literal">not</span>。    filter：过滤条件。range：条件筛选范围。<span class="hljs-literal">gt</span>：大于，相当于关系型数据库中的 &gt;。<span class="hljs-literal">gte</span>：大于等于，相当于关系型数据库中的 &gt;=。<span class="hljs-literal">lt</span>：小于，相当于关系型数据库中的 &lt;。<span class="hljs-literal">lte</span>：小于等于，相当于关系型数据库中的 &lt;=<span class="hljs-number">1.1</span>、term<span class="hljs-number">1</span>）term查询<span class="hljs-built_in">keyword</span>字段。term不会分词。而<span class="hljs-built_in">keyword</span>字段也不分词。需要完全匹配才可。<span class="hljs-number">2</span>）term查询text字段因为text字段会分词，而term不分词，所以term查询的条件必须是text字段分词后的某一个。<span class="hljs-number">1.2</span>.<span class="hljs-keyword">match</span><span class="hljs-number">1</span>）<span class="hljs-keyword">match</span>查询<span class="hljs-built_in">keyword</span>字段<span class="hljs-keyword">match</span>会被分词，而<span class="hljs-built_in">keyword</span>不会被分词，<span class="hljs-keyword">match</span>的需要跟<span class="hljs-built_in">keyword</span>的完全匹配可以。其他的不完全匹配的都是失败的。<span class="hljs-number">2</span>）<span class="hljs-keyword">match</span>查询text字段<span class="hljs-keyword">match</span>分词，text也分词，只要<span class="hljs-keyword">match</span>的分词结果和text的分词结果有相同的就匹配。<span class="hljs-number">1.3</span>.match_phrase<span class="hljs-number">1</span>）match_phrase匹配<span class="hljs-built_in">keyword</span>字段。这个同上必须跟keywork一致才可以。<span class="hljs-number">2</span>）match_phrase匹配text字段。match_phrase是分词的，text也是分词的。match_phrase的分词结果必须在text字段分词中都包含，而且顺序必须相同，而且必须都是连续的。<span class="hljs-number">1.4</span>.query_string<span class="hljs-number">1</span>）query_string查询<span class="hljs-built_in">keyword</span>类型的字段，试过了，无法查询。<span class="hljs-number">2</span>）query_string查询text类型的字段。和match_phrase区别的是，不需要连续，顺序还可以调换。</code></pre></div><h5 id="Elasticsearch包操作">Elasticsearch包操作</h5><div class="code-wrapper"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> elasticsearch import Elasticsearches = Elasticsearch([&#123;<span class="hljs-string">&quot;host&quot;</span>: <span class="hljs-string">&quot;123.60.180.204&quot;</span>, <span class="hljs-string">&quot;port&quot;</span>: 9200&#125;], <span class="hljs-attribute">timeout</span>=3600)<span class="hljs-comment"># 1.查询</span>query = &#123;    <span class="hljs-string">&quot;query&quot;</span>: &#123;        <span class="hljs-string">&quot;match_all&quot;</span>: &#123;&#125;    &#125;&#125;re = es.search(<span class="hljs-attribute">index</span>=<span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-attribute">body</span>=query)<span class="hljs-comment"># term/terms查询,terms可以指定多个条件</span>query = &#123;    <span class="hljs-string">&quot;query&quot;</span>: &#123;        <span class="hljs-string">&quot;term&quot;</span>: &#123;            # <span class="hljs-string">&quot;name&quot;</span>:[<span class="hljs-string">&quot;汪老师&quot;</span>,<span class="hljs-string">&quot;老师&quot;</span>]            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;老师&quot;</span>        &#125;    &#125;&#125;result = es.search(<span class="hljs-attribute">index</span>=<span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-attribute">body</span>=query)<span class="hljs-built_in">print</span>(result)<span class="hljs-comment"># 范围查询</span> query = &#123;  <span class="hljs-string">&quot;query&quot;</span>:&#123;<span class="hljs-string">&quot;&quot;</span>&#125;  &#125;<span class="hljs-comment"># 2.插入单条数据</span>result = es.index(<span class="hljs-attribute">index</span>=<span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-attribute">doc_type</span>=<span class="hljs-string">&quot;_doc&quot;</span>, body=&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;老师名称&quot;</span>,<span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;是个可爱的语文老师&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-string">&quot;20&quot;</span>,<span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;男&quot;</span>&#125;)<span class="hljs-comment"># 3.插入多条数据</span>doc = [&#123;<span class="hljs-string">&quot;index&quot;</span>: &#123;<span class="hljs-string">&quot;_index&quot;</span>: <span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-string">&quot;_type&quot;</span>: <span class="hljs-string">&quot;_doc&quot;</span>, <span class="hljs-string">&quot;_id&quot;</span>: 1&#125;&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;汪老师&quot;</span>,<span class="hljs-string">&quot;description&quot;</span>:<span class="hljs-string">&quot;语文老师&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>:26,<span class="hljs-string">&quot;sex&quot;</span>:<span class="hljs-string">&quot;女&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;index&quot;</span>: &#123;<span class="hljs-string">&quot;_index&quot;</span>: <span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-string">&quot;_type&quot;</span>: <span class="hljs-string">&quot;_doc&quot;</span>, <span class="hljs-string">&quot;_id&quot;</span>: 2&#125;&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;何老师&quot;</span>, <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;政治老师&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: 26&#125;,&#123;<span class="hljs-string">&quot;index&quot;</span>: &#123;<span class="hljs-string">&quot;_index&quot;</span>: <span class="hljs-string">&quot;teacher&quot;</span>, <span class="hljs-string">&quot;_type&quot;</span>: <span class="hljs-string">&quot;_doc&quot;</span>, <span class="hljs-string">&quot;_id&quot;</span>: 2&#125;&#125;,&#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;老师&quot;</span>, <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;老师&quot;</span>, <span class="hljs-string">&quot;sex&quot;</span>: <span class="hljs-string">&quot;女&quot;</span>&#125;]es.bulk(<span class="hljs-attribute">index</span>=<span class="hljs-string">&quot;teacher&quot;</span>,doc_type=&quot;_doc&quot;,body=doc)</code></pre></div><h5 id="elasticsearch-dsl">elasticsearch-dsl</h5><div class="code-wrapper"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">from</span> elasticsearch_dsl <span class="hljs-keyword">import</span> Document, Date, Nested, Boolean, analyzer, InnerDoc, Completion, Keyword, Text, Integer<span class="hljs-keyword">from</span> elasticsearch_dsl.connections <span class="hljs-keyword">import</span> connectionsconnections.create_connection(hosts=[<span class="hljs-string">&quot;123.060.180.204:9200&quot;</span>])es = connections.create_connection(hosts=[<span class="hljs-string">&quot;127.0.0.1:9200&quot;</span>], timeout=<span class="hljs-number">20</span>)res = Search(using=es).index(<span class="hljs-string">&quot;test_index&quot;</span>).query()<span class="hljs-keyword">class</span> Article(Document):    title = Text(fields=&#123;<span class="hljs-string">&#x27;title&#x27;</span>: Keyword()&#125;)    author = Text()    <span class="hljs-keyword">class</span> Index:        name = <span class="hljs-string">&#x27;myindex&#x27;</span>  # 索引名<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    Article.init()  # 创建映射    # 保存数据    article = Article()    article.title = <span class="hljs-string">&quot;test&quot;</span>    article.author = <span class="hljs-string">&quot;lxx&quot;</span>    article.save()  # 保存数据# # 查询数据# s = Article.search()# s = s.filter(<span class="hljs-string">&#x27;match&#x27;</span>, title=<span class="hljs-string">&quot;test&quot;</span>)# results = s.execute()# print(results)# # 删除数据# s = Article.search()# s = s.filter(<span class="hljs-string">&#x27;match&#x27;</span>, title=<span class="hljs-string">&quot;test&quot;</span>).delete()# # 修改数据# s = Article().search()# s = s.filter(<span class="hljs-string">&#x27;match&#x27;</span>, title=<span class="hljs-string">&quot;test&quot;</span>)# results = s.execute()# print(results[<span class="hljs-number">0</span>])# results[<span class="hljs-number">0</span>].title = <span class="hljs-string">&quot;xxx&quot;</span># results[<span class="hljs-number">0</span>].save()</code></pre></div><blockquote></blockquote><h4 id="Others">Others</h4><div class="code-wrapper"><pre><code class="hljs"># ./bin/elasticsearch-plugin install https://github.com/NLPchina/elasticsearch-analysis-ansj/releases/download/v7.6.2/elasticsearch-analysis-ansj-7.6.2.0-release.zip # docker run --name my_es7 -p 9200:9200  -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms84m -Xmx512m&quot; -v /root/my_elasticsearch/data:/usr/share/elasticsearch/data -v  /root/my_elasticsearch/plugins:/usr/share/elasticsearch/plugins -d elasticsearch:7.6.2</code></pre></div><h1></h1><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基本概念&quot;&gt;基本概念&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;索引Index:&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs delphi&quot;&gt;&amp;gt;一个索引就是相似特</summary>
      
    
    
    
    <category term="中间件" scheme="https://centyuan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Elasticsearch" scheme="https://centyuan.github.io/tags/Elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>Kafka Note</title>
    <link href="https://centyuan.github.io/2023/11/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/kakfa_note/"/>
    <id>https://centyuan.github.io/2023/11/22/%E4%B8%AD%E9%97%B4%E4%BB%B6/kakfa_note/</id>
    <published>2023-11-22T14:33:13.611Z</published>
    <updated>2023-11-28T03:01:56.242Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基础概念">基础概念</h4><blockquote><p>**Producer: **Producer 即生产者，消息的产生者，是消息的入口</p><p><strong>Broker:</strong>  Broker 是 kafka 一个实例，每个服务器上有一个或多个 kafka 的实例，简单的理解就是一台 kafka 服务器，kafka cluster表示集群的意思</p><p><strong>Topic:</strong>  消息的主题，可以理解为消息队列，kafka的数据就保存在topic。在每个 broker 上都可以创建多个 topic</p><p><strong>Partition:</strong>  Topic的分区，每个 topic 可以有多个分区，分区的作用是做负载，提高 kafka 的吞吐量。同一个 topic 在不同的分区的数据是不重复的，partition 的表现形式就是一个一个的文件夹,每个Partition都是一个有序队列</p><p><strong>Replication:</strong>  每一个分区都有多个副本，副本的作用是做备胎，主分区（Leader）会将数据同步到从分区（Follower）。当主分区（Leader）故障的时候会选择一个备胎（Follower）上位，成为 Leader。在kafka中默认副本的最大数量是10个，且副本的数量不能大于Broker的数量，follower和leader绝对是在不同的机器，同一机器对同一个分区也只可能存放一个副本</p><p><strong>Message:</strong> 每一条发送的消息主体</p><p><strong>Consumer:</strong> 消费者，即消息的消费方，是消息的出口,在实际的应用中，建议消费者组的consumer的数量与partition的数量保持一致</p><p><strong>Consumer Group:</strong>  可以将多个消费组组成一个消费者组，在 kafka 的设计中同一个分区的数据只能被消费者组中的某一个消费者消费。同一个消费者组的消费者可以消费同一个topic的不同分区的数据，这也是为了提高kafka的吞吐量</p><p><strong>Zookeeper:</strong> kafka 集群依赖 zookeeper 来保存集群的的元信息，来保证系统的可用性</p></blockquote><p><a href="https://zhuanlan.zhihu.com/p/442468709">https://zhuanlan.zhihu.com/p/442468709</a><br><a href="https://juejin.cn/post/7238604003599695928">https://juejin.cn/post/7238604003599695928</a></p><h4 id="基本命令">基本命令</h4><div class="code-wrapper"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#1.配置内网ip vim config/server.properties</span>listeners=PLAINTEXT:<span class="hljs-string">//10.0.0.11</span>:<span class="hljs-function">:9092</span><span class="hljs-comment">#2.配置外网连接</span>advertised.listeners=PLAINTEXT<span class="hljs-function">:ip</span><span class="hljs-function">:9092</span><span class="hljs-comment">#3.后台运行</span>nohup kafka-server-start.sh config/server.properties 2&gt;&amp;1 &amp;<span class="hljs-comment">#4.添加环境变量</span>vim ~<span class="hljs-string">/.bashrc</span>export KAFKA_HOME=<span class="hljs-string">/home/lighthouse/kafka_2.12-3.3.2</span>export PATH=$KAFKA_HOME/bin:$PATH<span class="hljs-comment">#5.查看所有topics</span>kafka-topics.sh <span class="hljs-params">--list</span> <span class="hljs-params">--bootstrap-server</span> 43.136.217.222<span class="hljs-function">:9092</span><span class="hljs-comment">#6.创建topics</span>kafka-topics.sh <span class="hljs-params">--bootstrap-server</span> 43.136.217.222<span class="hljs-function">:9092</span> <span class="hljs-params">--create</span> <span class="hljs-params">--topic</span> web <span class="hljs-params">--replication-factor</span> 1 <span class="hljs-params">--partitions</span> 3<span class="hljs-comment">#7.查看某个topic状态</span>kafka-topics.sh <span class="hljs-params">--describe</span> <span class="hljs-params">--topic</span> web <span class="hljs-params">--bootstrap-server</span> 43.136.217.222<span class="hljs-function">:9092</span><span class="hljs-comment">#8.查看消费组</span>kafka-consumer-groups.sh <span class="hljs-params">--list</span> <span class="hljs-params">--bootstrap-server</span> 43.136.217.222<span class="hljs-function">:9092</span><span class="hljs-comment">#9.查看生产与消费情况</span>kafka-consumer-groups.sh <span class="hljs-params">--describe</span> <span class="hljs-params">--bootstrap-server</span> 43.136.217.222<span class="hljs-function">:9092</span><span class="hljs-comment">#10.发送消息</span>kafka-console-producer.sh <span class="hljs-params">--broker-list</span> 43.136.217.222<span class="hljs-function">:9092</span> <span class="hljs-params">--topic</span> web<span class="hljs-comment">#11.消费,from-beginning消费之前的消息</span>kafka-console-consumer.sh <span class="hljs-params">--topic</span> web <span class="hljs-params">--bootstrap-server</span> 43.136.217.222<span class="hljs-function">:9092</span> <span class="hljs-params">--from-beginning</span><span class="hljs-comment">#12.消费多个topic</span>kafka-console-consumer.sh <span class="hljs-params">--whitelist</span> <span class="hljs-string">&quot;web|quick_demo&quot;</span> <span class="hljs-params">--bootstrap-server</span> 43.136.217.222<span class="hljs-function">:9092</span><span class="hljs-comment">#13.单播消费,一条消息只能被某一个消费者消费</span>分别在两个客户端执行kafka-console-consumer.sh <span class="hljs-params">--bootstrap-server</span> 43.136.217.222<span class="hljs-function">:9092</span> <span class="hljs-params">--consumer-property</span> group.id=testGroup <span class="hljs-params">--topic</span> web<span class="hljs-comment">#14.多播消费,一条消费能被多个消费者消费,类似publish-subscribe模式</span>保证消费者属于不同的消费组kafka-console-consumer.sh <span class="hljs-params">--bootstrap-server</span> 43.136.217.222<span class="hljs-function">:9092</span> <span class="hljs-params">--consumer-property</span> group.id=testGroup2 <span class="hljs-params">--topic</span> web</code></pre></div><h4 id="Partition分区">Partition分区</h4><blockquote><p><code>leader-follower:</code></p><p>生产者在向某个主题发送消息时，会根据分配策略将消息发送到对应的分区<br>kafka保证同一个分区内的数据是有序的，我们也可以认为一个分区就是一个有序的消息队列每个主题的某一个分区只能被同一个消费组下的其中一个消费者消费，因此我们可以说分区是消费并行度的基本单位。从消费者的角度讲，我们订阅消费了一个主题，也就订阅了该主题的所有分区</p></blockquote><h4 id="Kafka消息队列模式">Kafka消息队列模式</h4><blockquote><p><strong>一对一</strong>:</p><p>消费者主动拉取数据，消息收到后消息清除</p><p>`Producer -&gt; Mesage Queue -&gt; Consumer</p><p><strong>一对多(发布/订阅模式)</strong></p><p>消息生产者（发布）将消息发布到 topic 中，同时有多个消息消费者（订阅）消费该消息。和点对点方式不同，发布到 topic 中的消息会被所有订阅者消费</p></blockquote><h4 id="消息可靠生产和可靠消费">消息可靠生产和可靠消费</h4><blockquote><p><code>可靠生产:</code></p><div class="code-wrapper"><pre><code class="hljs maxima">为保证 producer 发送的数据，能可靠的发送到指定的 topic，topic 中的每个 <span class="hljs-built_in">partition</span> 收到 producer 发送的数据后，都需要向 producer 发送 ack （acknowledgement 确认收到），如果 producer 收到 ack，就会进行下一轮的发送，否则重新发送数据。</code></pre></div><p>1.使用Callback的api发送消息(ack确认+重试),</p><p>2.通过send方法发送消息,并返回Future对象,get()方法会等待Future对象，处理异常看send()方法是否成功</p><p><code>可靠消费:</code></p><div class="code-wrapper"><pre><code class="hljs applescript">每个分区在同一时间只被一个 consumer 消费，通每个分区被消费的消息在日志中的位置仅仅是一个简单的整数：<span class="hljs-built_in">offset</span>，通过<span class="hljs-built_in">offset</span>来跟踪消费状态</code></pre></div><p>1.手动提交偏移量offset+重试+死信队列</p></blockquote><h4 id="kafka如何将数据写入到对应的分区">kafka如何将数据写入到对应的分区</h4><p>1.send指定的分区<br>2.没有指定分区,则根据key的hash出一个分区<br>3.没有指定也没有key,则会轮询出一个分区</p><blockquote><p><code>发送消息的方法</code><br>ack机制：</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>:立即发送,不等待ack,<span class="hljs-number">1</span>:leader收到,-<span class="hljs-number">1</span>:producer等ISR中所有的fllower都确认收到数据</code></pre></div><p>1.立即发送(不care消息是否成功发送,大部分情况下会成功,producer会自动重试)<br>2.同步发送(通过send方法发送消息,并返回Future对象,get()方法会等待Future对象，看send()方法是否成功)<br>3.异步发送(通过有回调函数的send发送消息,当producer收到Kafka broker的response会触发回调函数)</p><p><code>kafka消费模式(客户端处理消息和提交反馈两个动作不是原子性)</code></p><p><strong>数据传输的事务定义:</strong></p><p>1.最多一次(客户端收到消息前自动提交反馈了)<br>2.最少一次(客户端处理消息提交反馈,提交反馈时服务可能挂掉,kafka认为消息未被消费,产生消息重复推送)<br>3.正好一次(保证消息处理和提交反馈在同一个事务中,既有原子性)</p></blockquote><h4 id="副本同步策略">副本同步策略</h4><blockquote><p>1.半数以上完成同步，就发送 ack</p><div class="code-wrapper"><pre><code class="hljs excel">&gt;延迟低,选取新的 leader 时，容忍 <span class="hljs-built_in">n</span> 台节点的故障，需要 <span class="hljs-number">2</span><span class="hljs-built_in">n</span>+<span class="hljs-number">1</span> 个副本</code></pre></div><p>2.全部完成同步，就发送 ack</p><div class="code-wrapper"><pre><code class="hljs excel">&gt;延迟高,选取新的 leader 时，容忍 <span class="hljs-built_in">n</span> 台节点的故障，需要 <span class="hljs-built_in">n</span>+<span class="hljs-number">1</span> 个副本</code></pre></div><p>kafka 采用第二种方案后，可能会出县一个问题：leader 收到数据后。所有的 follower 都开始同步数据，但是某个 follower 因为故障，迟迟不能与 leader 进行同步，那么 leader 就要一直等下去，直到它完成同步，才能发送 ack.</p><p><code> 为了解决这个问题，leader 维护了一个动态的 in-sync replica（ISA）</code></p><div class="code-wrapper"><pre><code class="hljs fortran">&gt;isr:<span class="hljs-keyword">In</span>-<span class="hljs-built_in">Sync</span> Replicas isr 是一个副本的列表，里面存储的都是能跟leader 数据一致的副本</code></pre></div></blockquote><h4 id="kafka-为什么那么快">kafka 为什么那么快</h4><blockquote><ul class="lvl-1"><li class="lvl-2"><p>顺序读写: 由于现代的操作系统提供了预读和写技术，磁盘的顺序写大多数情况下比随机写内存还要快。</p></li><li class="lvl-2"><p>零拷技术(Zero-copy): 减少拷贝次数</p></li><li class="lvl-2"><p>批量处理: Batching of Messages ,合并小的请求，然后以流的方式进行交互，直顶网络上限。</p></li><li class="lvl-2"><p>Pull 拉模式 使用拉模式进行消息的获取消费，与消费端处理能力相符</p></li></ul></blockquote><h4 id="Other">Other</h4><blockquote><p>kafka.errors.kafkaTimeoutError:KafkaTimeoutError:Batch for TopicPartition(topic=“notifyCenter_topic”,partition=0) containing 1 record(s) expired:30 seconds have passed since last append</p><p>可以正常后去kafka topic信息发送消息时报这个错,原因是和kafka连接使用了代理，在发送消息时，拿到具体的节点地址不能发送，需要改成代理才行<br>kafka对跨网络的访问有个专门的参数:<br>advertised.listeners=PLAINTEXT://hostname:9092<br>这个参数配置了,默认返回给生产者或消费者的就是这个参数的内容</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基础概念&quot;&gt;基础概念&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;**Producer: **Producer 即生产者，消息的产生者，是消息的入口&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Broker:&lt;/strong&gt;  Broker 是 kafka 一个实例，每个服务器</summary>
      
    
    
    
    <category term="中间件" scheme="https://centyuan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="Kafka" scheme="https://centyuan.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>GIL/进程线程协程切换</title>
    <link href="https://centyuan.github.io/2023/11/22/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/GIL(%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B)/"/>
    <id>https://centyuan.github.io/2023/11/22/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/GIL(%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B)/</id>
    <published>2023-11-22T14:18:03.539Z</published>
    <updated>2023-11-25T04:36:29.600Z</updated>
    
    <content type="html"><![CDATA[<h4 id="GIL">GIL</h4><blockquote><p>Global interperter Lock全局解释器锁,并不是Python特性,CPython引入的概念，python完全可以不依赖GIL</p><p><strong>为什么使用GIL?</strong></p><p>每个线程在执行过程中都要先获取GIl，保证同一时刻只有一个线程运行,目的是解决多线程之间的数据完整性和状态同步,</p><p>并且因为使用引用技术管理内存，所以某个对象的引用计数不能被两个线程同时增加和减少，不然造成内存泄露,GIL对线程间共享的所有数据结构加锁可以保证引用计数变量的安全性</p><p>导致python的多线程在多核CPU上，只对IO密集型产生正面效果,对应CPU密集型，多线程效率会因为GIL而大幅下降</p><p><strong>GIL锁的释放</strong></p><div class="code-wrapper"><pre><code class="hljs scss">&gt;<span class="hljs-number">1</span>.协同式多任务处理(IO密集型任务)&gt;在较长的或者不确定的时间(IO阻塞，python标准库中所有阻塞性I/O和time.sleep()都会释放)，没有运行Python代码的需要，线程便会让出GIL&gt;<span class="hljs-number">2</span>.抢占式多任务(CPU密集型任务)&gt;解释器运行一段时间就主动释放GIL,这种机制叫间隔式检查(check_interval),每隔一段时间Python解释器就会强制当前线程释放GIL而不需要正在执行代码线程调度允许(python3中，这个时间间隔是<span class="hljs-number">15</span>毫秒)</code></pre></div><p><strong>GIL缺陷</strong></p><div class="code-wrapper"><pre><code class="hljs x86asm">&gt;<span class="hljs-number">1</span>.抢占式多任务处理(<span class="hljs-meta">CPU</span>密集型):(每个线程在多个<span class="hljs-meta">cpu</span>交替执行:<span class="hljs-meta">cpu</span>调度线程唤醒-&gt;去拿GIL-&gt;没拿到-&gt;在等待:<span class="hljs-number">1</span>.线程上下文切换,<span class="hljs-number">2</span>.争抢不到GIL会让<span class="hljs-meta">cpu</span>等待,都浪费<span class="hljs-meta">cpu</span>时间)&gt;<span class="hljs-number">2.</span>Python的每个版本中也在逐渐改进GIL和线程调度之间的互动关系。例如先尝试持有GIL在做线程上下文切换，在IO等待时释放GIL等尝试。&gt;<span class="hljs-number">3</span>.但是无法改变的是GIL的存在使得操作系统线程调度的这个本来就昂贵的操作变得更奢侈了</code></pre></div></blockquote><h4 id="CPU上下文">CPU上下文</h4><blockquote><p>CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境</p><ol><li class="lvl-3">CPU寄存器是CPU内置的小容量高速的内存(用来存放指令和数据等内容的一块内存)，速度很快，可以存储一些计算过程中的信息</li></ol>  <div class="code-wrapper"><pre><code class="hljs x86asm">x64架构下一共有<span class="hljs-number">16</span>个通用寄存器，以<span class="hljs-string">&#x27;r&#x27;</span>开头列举几个重要的寄存器的使用:<span class="hljs-symbol">rax:</span> 用于存放函数返回值和中间件计算结果<span class="hljs-built_in">rsp</span>、<span class="hljs-built_in">rbp</span>: 栈顶,栈低寄存器，用于存放当前函数栈的栈顶，栈低地址<span class="hljs-built_in">rdi</span>、<span class="hljs-built_in">rsi</span>、<span class="hljs-built_in">rdx</span>、<span class="hljs-built_in">rcx</span>、<span class="hljs-built_in">r8</span>、<span class="hljs-built_in">r9</span>: 调用函数时依次存放第<span class="hljs-number">1</span>个到第<span class="hljs-number">6</span>个参数,多余<span class="hljs-number">6</span>个参数则会被压入栈<span class="hljs-symbol">rip:</span> 用于存放下一条指令地址,<span class="hljs-meta">CPU</span>会取此寄存器地址去找到下一条指令并执行</code></pre></div><p><strong>函数调用过程</strong></p>  <div class="code-wrapper"><pre><code class="hljs x86asm">函数是在一块栈空间运行的，这个栈顶和栈低地址存放在<span class="hljs-built_in">rsp</span>,<span class="hljs-built_in">rbp</span>里面，且函数的局部变量也会存在栈中某一快内存中函数调用就是从一个函数栈跳转到相领另一个函数栈罢了，调用返回后还需要恢复原函数栈的状态,必须在调用时通过寄存器和栈空间的配合来存储一些数据，方便调用完成后恢复重点:具有调用关系的两个函数栈空间一定是相邻的，也就是说主调方的函数栈空间与被调方的函数栈空间一点是相邻的</code></pre></div><ol start="2"><li class="lvl-3"><p>程序计数器用来存储CPU正在执行的指令位置,或者将执行的下一条指令位置</p></li></ol></blockquote><h5 id="CPU上下文切换">CPU上下文切换</h5><blockquote><p>1.把前一个CPU上下文(CPU寄存器和程序计数器)保存起来</p><p>2.加载新任务的上下文到CPU寄存器和程序计数器</p><p>3.调到程序计数器所指位置，运行新任务</p></blockquote><h5 id="CPU上下文切换类型">CPU上下文切换类型</h5><blockquote><p>进程上下文线程上下文中断上下文</p></blockquote><h4 id="内核空间和用户空间">内核空间和用户空间</h4><blockquote><p>内核空间(Ring 0): 具有最高权限,直接访问所有资源</p><p>用户控件(Ring 3): 只能访问受限资源,不能直接访问内存等硬件设备，必须通过系统调用到内核空间才能访问这些特权资源</p><p>进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态</p><p><strong>用户态内陷内核态三种方式</strong></p><p>系统调用,异常,中断</p></blockquote><h4 id="系统调用">系统调用</h4><blockquote><p>比如查看文件内容就需要系统调用:open()打开文件,read()读取文件内容,write()将文件内容写到标准输出</p><p>过程：</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.保存CPU寄存器原来用户态的指令位</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.跳转到内核态运行内核任务</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">一次系统调用的过程，其实是发生了两次 CPU 上下文切换。（用户态-内核态-用户态）</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">要注意的是：系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">所以，系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换。</span></code></pre></div></blockquote><h4 id="进程上下文切换">进程上下文切换</h4><div class="code-wrapper"><pre><code class="hljs arcade">虚拟内存:当内存耗尽时,自动调用硬盘充当内存Linux 通过 TLB（Translation Lookaside <span class="hljs-built_in">Buffer</span>）来管理虚拟内存到物理内存的映射关系</code></pre></div><blockquote><p>首先：<strong>进程是由内核来管理和调度的，进程的切换只能发生在内核态</strong></p><p>进程的上下文：不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态</p><p>因此：<strong>进程的上下文切换就比系统调用时多了一步</strong></p><p><strong>在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</strong></p><p><strong>导致进程上下文切换的情况</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.CPU时间被耗尽</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.系统资源不足，需要等到资源满足才可以运行</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.进程通过<span class="hljs-built_in">sleep</span>这样的方法主动挂起</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.有更高的优先级进程</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">5.硬件中断</span></code></pre></div><p><code>进程状态:</code><br>1.运行running<br>2.就绪ready<br>3.等待wait</p></blockquote><h4 id="线程上下文切换">线程上下文切换</h4><blockquote><p>线程本身是共享进程的虚拟内存和全局变量等资源，这些资源在上下文切换时不需要修改，不涉及虚拟地址的变化，这就是为什么进程切换比线程切换开销大的原因</p><p><strong>所以线程的切换就只包括线程上下文的切换，就是替换线程放在处理器寄存器中的相关私有数据，但是线程的调度也需要到内核空间完成,同样需要从用户态转向内核态</strong></p><p><code>线程状态</code><br>1.创建new(分配资源，初始化)<br>2.就绪ready<br>3.执行running(获取CPU时间,执行代码)<br>4.阻塞blocked(放弃CPU,暂停运行,常见阻是原因:等待I/O操,等待锁,等待其他线程通知)<br>5.终止terminated()</p></blockquote><h4 id="协程切换">协程切换</h4><blockquote><div class="code-wrapper"><pre><code class="hljs gcode">协程:是一种比线程更加轻量级的微线程，一个线程也可以拥有多个协程协程与函数调用栈是密切相关的，协程拥有自己的上下文<span class="hljs-comment">(函数栈状态/寄存器值)</span></code></pre></div><p><strong>协程上下文</strong></p><div class="code-wrapper"><pre><code class="hljs cpp">协程是一段子程序(其实就是函数), 只要保存当前函数栈状态和寄存器指，就可以描述这个协程的全部状态- 函数栈状态- 寄存器值<span class="hljs-keyword">struct</span> <span class="hljs-title class_">coctx_t</span>&#123;<span class="hljs-type">void</span> *regs[ <span class="hljs-number">14</span> ];       <span class="hljs-comment">// 一个数组，保存了14个寄存器的值 </span><span class="hljs-type">size_t</span> ss_size;         <span class="hljs-comment">// 协程栈大小</span><span class="hljs-type">char</span> *ss_sp;            <span class="hljs-comment">// 协程栈指针</span>&#125;;</code></pre></div><p>1.保存当前协程的CPU寄存器的值保存到协程上下文中的regs数组中</p><p>2.将新协程上下文的regs数组中值取出来赋值给对应的寄存器</p><p>切换在用户空间不涉及内核空</p></blockquote><h4 id="进程线程区别">进程线程区别</h4><blockquote><p>1根本区别:资源分配的基本单位,cpu调度执行的基本单位<br>2地址空间:空间资源独立,共享本进程的空间和资源<br>3键壮性:崩溃不影响其他进程,一个线程崩溃整个进程崩掉<br>4执行过程:进程有(执行入口/顺序执行/执行开销大),线程不能独立运行(依附于进程,执行开销小)<br>5切换:进程切换资源消耗大,线程切换消耗小<br>(进程切换需要切换页表,页表切换后,TLB失效,地址转化时需要重新查找页表。线程切换不需要切换页表)</p></blockquote><h4 id="切换对比">切换对比</h4><blockquote><p>程序=指令序列+上下文  # 信息=位+上下文</p><p>**指令:**就是寄存器地址指向的值，也就是CPU要执行的命令</p><p><strong>上下文:</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">CPU上下文：</span>操作数寄存器，栈寄存器，状态寄存器等各类寄存器<span class="hljs-meta prompt_">&gt;</span><span class="language-bash">进程上下文:</span>寄存器,信号,分配的内存空间,文件描述符等各类由CPU抽象出来的资源<span class="hljs-meta prompt_">&gt;</span><span class="language-bash">线程上下文:</span> 寄存器，线程堆栈<span class="hljs-meta prompt_">&gt;</span><span class="language-bash">函数上下文:</span>当前的命名空间<span class="hljs-meta prompt_">&gt;</span><span class="language-bash">协程上下文:</span>寄存器</code></pre></div><p>进程切换：需要切换系统资源和指令，操作最重</p><p>线程切换：只切换线程堆栈，不需要切换系统资源</p><p>协程切换:   都在用户空间进行，不需要进行系统调用</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;GIL&quot;&gt;GIL&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;Global interperter Lock全局解释器锁,并不是Python特性,CPython引入的概念，python完全可以不依赖GIL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为什么使用GIL?&lt;/stro</summary>
      
    
    
    
    <category term="Python从入门到放弃" scheme="https://centyuan.github.io/categories/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    
    
    <category term="GIL" scheme="https://centyuan.github.io/tags/GIL/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ Note</title>
    <link href="https://centyuan.github.io/2023/11/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq_note/"/>
    <id>https://centyuan.github.io/2023/11/20/%E4%B8%AD%E9%97%B4%E4%BB%B6/rabbitmq_note/</id>
    <published>2023-11-20T13:33:48.474Z</published>
    <updated>2023-11-22T14:32:39.763Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://pic3.zhimg.com/v2-c6404583156af22d90e35aa2ae66de86_b.jpg" alt="RabbitMQ_note"></p><h4 id="什么是MQ">什么是MQ</h4><blockquote><p><strong>AMQP</strong>：即Advanced Message Queuing Protocol，是一个应用层标准高级消息队列协议，提供统一消息服务。是应用层协议的一个开放标准，为面向消息的中间件设计。类似于一种FIFO先入先出队列</p><p><strong>为啥要用MQ?</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.高并发的流量削峰</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.应用解耦</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.处理异步任务</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.消息分发</span></code></pre></div><p><strong>常见MQ:</strong></p><p><strong>RabbitMQ</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">由erlang语言开发,性能较好,吞吐量到万级，MQ功能比较完备,消息投递和消费可靠,稳定易用支持多种语言</span></code></pre></div><p><strong>Kafka</strong></p><div class="code-wrapper"><pre><code class="hljs crmsh">&gt;大数据的杀手锏,性能卓越，吞吐量高，单机写入 TPS 约在百万条/秒，时效性 <span class="hljs-keyword">ms</span> <span class="hljs-title">级，可用性非常高；其次kafka</span>是分布式的</code></pre></div><p><strong>RocketMQ</strong></p><div class="code-wrapper"><pre><code class="hljs mipsasm">&gt;RocketMQ 出自阿里巴巴的开源产品，用 <span class="hljs-keyword">Java </span>语言实现</code></pre></div></blockquote><h4 id="名词解释">名词解释</h4><blockquote><p><strong>Broker</strong>: 接收和分发消息的应用，<code>RabbitMQ Server</code>就是<code>Message Broker</code></p><p><strong>Virtual host</strong>: 出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的<code>namespace</code>概念。当多个不同的用户使用同一个<code>RabbitMQ server</code>提供的服务时，可以划分出多个<code>vhost</code>，每个用户在自己的<code>vhost</code>创建<code>exchange/queue</code>等</p><p><strong>Connection</strong>: <code>publisher/consumer</code>和<code>broker</code>之间的TCP连接</p><p><strong>Channel</strong>: 如果每一次访问<code>RabbitMQ</code>都建立一个<code>Connection</code>，在消息量大的时候建立<code>TCP Connection</code>的开销将是巨大的，效率也低,<code>Channel</code>是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，<code>AMQP method</code>包含了<code>channel id</code>帮助客户端和<code>message broker</code>识别<code>channel</code>，所以<code>channel</code>之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销</p><p><strong>Exchange</strong>: message到达broker的第一站，根据分发规则，匹配查询表中的<code>routing key</code>，分发消息到queue中去。</p><p>常用的类型有：<code>direct(point-to-point)</code>，<code>topic(publish-subscribe) and fanout(multicast)</code></p><p><strong>Queue</strong>: 消息投递到queue，等待consumer消费</p><p><strong>Binding</strong>: exchange和queue之间的虚拟连接，binding中可以包含routing key，Binding信息被保存到exchange中的查询表中，用于message的分发依据。</p></blockquote><h4 id="RabbitMQ-Exchange分类">RabbitMQ Exchange分类</h4><blockquote><p>常用的有direct,fanout,topic,headers</p><p><strong>direct:</strong></p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span>:<span class="hljs-number">1</span>,binding <span class="hljs-keyword">key</span>和routing <span class="hljs-keyword">key</span>都是队列的名称</code></pre></div><p><strong>fanout:</strong></p><div class="code-wrapper"><pre><code class="hljs basic"><span class="hljs-number">1</span>:N,不需要处理Route <span class="hljs-keyword">key</span>,把消息路由到与该Exchange绑定Binding的所有Queue</code></pre></div><p><strong>topic:</strong></p><div class="code-wrapper"><pre><code class="hljs vbnet"><span class="hljs-symbol">N:</span><span class="hljs-number">1</span>,多个exchange路由到同一个queue,根据routing <span class="hljs-keyword">key</span>的模糊匹配</code></pre></div><p><strong>headers:</strong></p><div class="code-wrapper"><pre><code class="hljs gauss">不处理routing <span class="hljs-built_in">key</span>,根据发送的消息内容中的headers属性(及参数)与绑定时指定的键值对进行匹配</code></pre></div><p><code>direct Exchange:</code><br>是RabbitMQ Broker的默认Exchange它有一个特别的属性对一些简单的应用来说是非常有用的，在使用这个类型的Exchange时,可以不必指定routing key的名字,在此类型下创建的Queue有一个默认的routing key,这个routing key一般同Queue同名。</p></blockquote><h4 id="RabbitMQ的工作模式">RabbitMQ的工作模式:</h4><h5 id="1-simple模式">1.simple模式</h5><blockquote><p>一对一,不需要指定exchange,使用默认的 direct exchange</p><p><code>producer -&gt; queue -&gt; consumer</code></p></blockquote><h5 id="2-worker模式">2.worker模式</h5><blockquote><p>使用默认的direct exchange,一对多</p><p><code>producer -&gt;queue -&gt; consumer1,consumer2,consumer3</code></p><p>有多个消费者,消息被均分给多个消费者处理,两种分发方式:<br>(1.轮询分发:平均分配,必须采用自动应答autoAck<br>(2.公平分发:能者多劳(需要修改配置:1.消息确认改为手动ack,2.预处理模式qos参数=1,为每次读取一条消息)</p><div class="code-wrapper"><pre><code class="hljs gcode">&gt;高并发情况下,默认会产生某一个消息被多个消费者共同使用,可以设置一个开关<span class="hljs-comment">(syncronize)</span> 保证一条消息只能被一个消费者使用</code></pre></div></blockquote><h5 id="3-发布订阅模式">3.发布订阅模式</h5><blockquote><p>使用fanout exchange,publish/subscribe,消息投递到每个绑定的queue中<br><code>producer -&gt; fanout exchange-&gt; queue1,queue2,queue3 -&gt; consumer1,consumer2,consumer3</code></p></blockquote><h5 id="4-routing路由模式">4.routing路由模式</h5><blockquote><p>使用direct exchange,发送消息时指定routing key,以此投递消息到指定queue<br><code>producer -&gt; direct  exchange -&gt; queue1,queue2,queue3 -&gt; consumer1,consumer2,consumer3</code></p></blockquote><h5 id="5-topic主题模式">5.topic主题模式</h5><blockquote><p>使用Topic exchange,发送消息时候指定routing key,根据routing key模式匹配,消息被投递到一个或多个队列中</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-comment">#:代表0,1,多个</span><span class="hljs-section">*:至少有一个</span></code></pre></div></blockquote><h5 id="6-RPC模式">6.RPC模式</h5><h4 id="RabbitMQ-消息确认机制ACK">RabbitMQ 消息确认机制ACK</h4><blockquote><p>1.生产者发送消息确认分为:Confirm消息确认(将信道设置成Confirm模式,成功失败都有返回)和Return(投递失败时才有返回)消息机制<br><strong>2.消费者采用ack模式:</strong></p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">自动ACK: 消费者接收到消息后自动发送ACK给RabbitMQ</span><span class="hljs-section">手动ACK: 手动控制消费者接收到并成功消息后发送ACK给RabbitMQ</span></code></pre></div></blockquote><h4 id="持久化">持久化</h4><blockquote><p>设置了队列和消息持久化后：<code>当服务重启之后，消息仍然存在</code></p><p>只设置队列持久化，不设置消息持久化：<code>重启之后消息会丢失</code></p><p>只设置消息持久化，不设置队列持久化: <code>在服务重启后，队列会消失，从而依附于队列的消息也会丢失,毫无意义</code></p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">&gt;exchange和queue:通过durable参数设置</span><span class="hljs-section">&gt;消息:通过properties = pika.BasicProperties(delivery_mode=2)设置</span></code></pre></div></blockquote><h4 id="预取值">预取值</h4><blockquote><p>消息的发送就是异步发送的，所以在channel上肯定不止只有一个消息，消费者的手动确认也是异步的，就存在一个未确认的消息缓冲区，因此希望能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题</p><p><code>通过使用basic.gos，方法设置“预取计数”值来完成的</code></p><p>定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ将停止在通道上传递更多消息</p><p><strong>prefetch预取值可以用来限流</strong></p></blockquote><h4 id="死信队列">死信队列:</h4><blockquote><p>死信，就是无法被消费的消息,由于某些原因导致queue中的某些消息无法被消费,则将这些消息投递到<code>死信队列</code></p><p><strong>死信可能的原因</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.消息TTL过期</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.队列达到最大长度(队列满了，无法再添加数据到mq中)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.消息被拒绝</span></code></pre></div></blockquote><h4 id="消息丢失？">消息丢失？</h4><blockquote><p>从三个方面解决:</p><p>1.生产者确认机制</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">&gt;开启生产者确认机制Confirm:只要消息成功发送到交换机之后，RabbitMQ就会发送一个ack给生产者（即使消息没有Queue接收，也会发送ack）。如果消息没有成功发送到交换机，就会发送一条nack消息，提示发送失败</span><span class="hljs-section">&gt;事务机制:在一条消息发送之后会使发送端阻塞，等待RabbitMQ的回应，之后才能继续发送下一条消息。性能差</span></code></pre></div><p>2.消费者手动确认</p><p>3.持久化</p></blockquote><h4 id="延迟队列">延迟队列</h4><blockquote><p>存储对应的延迟消息，指当消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费</p></blockquote><h4 id="消息重复消费怎么处理？">消息重复消费怎么处理？</h4><blockquote><p><strong>1.生产时消息重复</strong></p><p><strong>2.消费时消息重复</strong></p><p>由于网络波动，导致消息确认没有收到</p><p><strong>解决方法:</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">发送消息时让每个消息携带一个全局的唯一ID，在消费消息时先判断消息是否已经被消费过，保证消息消费逻辑的幂等性</span></code></pre></div></blockquote><h4 id="Other">Other</h4><blockquote><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">exclusive:指示队列是否是排他性。如果一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除。</span>1. 排他队列是基于连接可见的，同一连接的不同信道Channel是可以同时访问同一连接创建的排他队列；  2.“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；  3. 即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。<span class="hljs-meta prompt_">&gt;</span><span class="language-bash">autoDelete:是否自动删除。如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于发布订阅方式创建的临时队列</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">mandatory:</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">当消息无法找到对应的queue时</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">mandatory ：<span class="hljs-literal">true</span> 返回消息给生产者</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">mandatory: <span class="hljs-literal">false</span> 直接丢弃</span></code></pre></div><p><strong>rabbitmq内存磁盘监控</strong></p><div class="code-wrapper"><pre><code class="hljs routeros">&gt;内存使用超过配置的阈值,或磁盘剩余空间低于配置的阈值会警告,rabbitmq连接会被挂起rabbitmqctl set_vm_memory_high_watermark.<span class="hljs-attribute">relative</span>=0.4-0.6rabbitmqctl set_vm_memory_high_watermark.<span class="hljs-attribute">absolute</span>=2GBrabbitmqctl set_disk_free_limit 100GB&gt;内存换页,内存使用率达到一定值,将内存中数据转入磁盘中<span class="hljs-attribute">vm_memory_high_watermark_paging_ratio</span>=0.7</code></pre></div></blockquote><h4 id="rabbitmq集群搭建">rabbitmq集群搭建</h4><blockquote><p>1.停止rabbitmq服务<br>2.启动第一个节点<br>sudo RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit-1 rabbit-server start &amp;<br>3.启动第二个节点<br>sudo RABBITMQ_NODE_PORT=5673 RABBITMQ_SERVER_START_ARGS=“-rabbitmq_management listener [{port,15673}]” RABBITMQ_NODENAME=rabbit-2 rabbitmq-server start &amp;<br>4.修改rabbit-1为主节点<br>sudo rabbitmqctl -n rabbit-1 stop_app  # 1.停止应用<br>sudo rabbitmqctl -n rabbit-1 reset     # 2.重置,清除节点上的历史数据(否则无法加入节点)<br>sudo rabbitmqctl -n rabbit-1 start_app # 3.启动应用<br>5.修改rabbit-2为从节点<br>sudo rabbitmqctl -n rabbit-2 stop_app<br>sudo rabbitmqctl -n rabbit-2 reset<br>sudo rabbitmqctl -n rabbit-2 join_cluster rabbit-1@主机名<br>sudo rabbitmqctl -n rabbit-2 start_app<br>6.验证集群状态<br>sudo rabbitmqctl cluster_status -n rabbit-1</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;https://pic3.zhimg.com/v2-c6404583156af22d90e35aa2ae66de86_b.jpg&quot; alt=&quot;RabbitMQ_note&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;什么是MQ&quot;&gt;什么是MQ&lt;/h4&gt;
&lt;blockquot</summary>
      
    
    
    
    <category term="中间件" scheme="https://centyuan.github.io/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
    <category term="RabbitMQ" scheme="https://centyuan.github.io/tags/RabbitMQ/"/>
    
  </entry>
  
  <entry>
    <title>Python性能优化</title>
    <link href="https://centyuan.github.io/2023/11/19/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8F%8A%E5%BA%A6%E9%87%8F/"/>
    <id>https://centyuan.github.io/2023/11/19/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%8F%8A%E5%BA%A6%E9%87%8F/</id>
    <published>2023-11-19T09:45:50.866Z</published>
    <updated>2023-11-19T12:11:11.579Z</updated>
    
    <content type="html"><![CDATA[<h5 id="选择合适的数据结构">选择合适的数据结构</h5><blockquote><p><strong>1.使用dict或set查找元素</strong></p><div class="code-wrapper"><pre><code class="hljs python">&gt;<span class="hljs-built_in">dict</span>/<span class="hljs-built_in">set</span> 底层使用了<span class="hljs-built_in">hash</span> table，因此查找操作时间复杂度为O(<span class="hljs-number">1</span>)</code></pre></div><p><strong>2.使用set求交集而不是list</strong></p><p><strong>3.推导式或生成器表达式</strong></p><p><strong>4.字符串拼接使用join</strong></p><p><strong>5.合理使用copy,deepcopy(deepcopy使用递归复制,慢一个数量级)</strong></p><p><strong>6.循环优化</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">循环外能做的事放在循环外面</span></code></pre></div><p><strong>7.优化多个判断表达式顺序</strong></p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">&gt;对于and，应该把满足条件少的放在前面，对于or，把满足条件多的放在前面)ps:充分利用Lazy-evaluation</span></code></pre></div><p><strong>8.使用is</strong></p><div class="code-wrapper"><pre><code class="hljs actionscript">&gt;<span class="hljs-keyword">is</span>运算符比==速度快,能用<span class="hljs-keyword">is</span>情况尽量使用</code></pre></div><p><strong>9.while 1比while True快</strong></p><div class="code-wrapper"><pre><code class="hljs ada">&gt;(后者可读性强，<span class="hljs-literal">True</span>是一个全局变量而非关键字)</code></pre></div><p><strong>10.使用局部变量,避免global，局部变量比全局变量快</strong></p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h5 id=&quot;选择合适的数据结构&quot;&gt;选择合适的数据结构&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;1.使用dict或set查找元素&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;code-wrapper&quot;&gt;&lt;pre&gt;&lt;code class=&quot;hljs pyt</summary>
      
    
    
    
    <category term="Python从入门到放弃" scheme="https://centyuan.github.io/categories/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    
    
    <category term="Python" scheme="https://centyuan.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Redis Note</title>
    <link href="https://centyuan.github.io/2023/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_Note/"/>
    <id>https://centyuan.github.io/2023/11/19/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis_Note/</id>
    <published>2023-11-19T06:01:03.573Z</published>
    <updated>2023-12-06T14:37:08.117Z</updated>
    
    <content type="html"><![CDATA[<h4 id="概述">概述</h4><blockquote><p>REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。</p><p>是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API。</p><p><strong>单线程:</strong> Redis是单线程的(所谓多线程,是说Redis处理客户端的请求及执行命令，并不是整个Redis都是单线程)</p><p>4.0后有了多线程,处理命令请求的核心模块,其他地方已经有了多线程比如:后台删除对象，生成dump文件，以及6.0中网络I/O实现了多线程</p><p><strong>IO多路复用机制:</strong></p><p>多路指的是多个TCP连接,复用指的是一个或多个线程，<code>I/O</code> 多路复用的核心原理就是不再由应用程序自己来监听连接，而是由服务器内核替应用程序监听</p><p>在redis中，多路复用有多重实现如: select,epoll,evport,kqueue</p><p>通俗解释:</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">以买奶茶为例:你点了一杯奶茶</span><span class="hljs-section">同步阻塞IO:，啥也不干，就等着,没做其他的叫阻塞，等奶茶叫同步</span><span class="hljs-section">同步非阻塞IO:一会刷刷抖音，一会瞅瞅奶茶好没，没阻塞干其他的，但是在同步等奶茶好没</span><span class="hljs-section">异步阻塞IO:服务员给你个小票,好了通知你来取,但是你没干其他的，叫阻塞，好了通知你叫异步,这个最傻</span><span class="hljs-section">异步非阻塞IO:服务员给你个小票,好了通知你来取，你可以刷刷抖音</span><span class="hljs-section">事件驱动机制:</span> 奶茶做好了并不知道是谁的，就需要每个问下，这个就是select模型,最多只能监听1024个socket,poll解决了这个限制 奶茶做好了也不知道是谁的,就大声喊下“某某的奶茶好了<span class="hljs-string">&quot;,这就是多路复用中的epoll模型</span></code></pre></div></blockquote><h4 id="1-基础命令">1.基础命令</h4><div class="code-wrapper"><pre><code class="hljs plaintext">select number(0-15):切换数据库dbsize:查看当前数据库的key的数量flushdb:清空当前数据库flushall:清空所有库keys *:查看当前库所有keyexists key:key是否存在type key:查看key类型del key:删除unlink key:非阻塞删除,先将keys从keyspaces删除,真正的删除在后续异步操作中expire key 10:设置10秒过期时间ttl  key :-1表示永不过期,-2表示已过期info memory:查看内存使用情况config set maxmemory 100mb:动态命令配置redis最大内存 config get maxmemory淘汰策略:1.noeviction(默认,只读不写)2.lru:最近最少使用(allkeys-lru,volatile-lru)3.random:随机淘汰(allkeys-random,volatile-random)4.ttl:过期时间淘汰(volatile-ttl:配置过期的键中删除马上过期的,volatile-lfu:配置过期键中删除使用频率最少的)5.allkeys-lfu:所有键删除使用频率最少的定时(每个过期key都需创建一个定时器)/惰性(访问key,判定key是否过期)/定期</code></pre></div><p><img src="https://pic4.zhimg.com/v2-83d9146cac1b288a30fbb841534b6e73_r.jpg" alt="Redis数据类型"></p><h4 id="2-五大基本数据类型">2.五大基本数据类型</h4><blockquote><p>在Redis有个核心对象<strong>redisObject</strong>,用来表示String,Hash,List,Set,ZSet</p></blockquote><blockquote><h5 id="1-String字符串">1.String字符串</h5><blockquote><p>字符串是一种基本的数据类型，Redis对字符串进行了特别设计，一种二进制安全的字符串对象，可以包含任何数据。比如jpg图片或者序列化的对象。string 类型的值最大能存储 512MB,类似Java的ArrayList,pyton的list,在第一次append也会超额分配,来减少频繁的内存分配</p></blockquote><p>底层实现:动态字符串</p><div class="code-wrapper"><pre><code class="hljs plaintext">底层数据结构存储方式有三种:int, raw,embstr1.如果是整数值就会使用int的存储方式2.使用【简单动态字符串SDS】(Simple dynamic string):如果是字符串且长度大于32个字节,,encoding设置为raw如果是字符串且长度小于等于32个字节,encoding设置为embstr</code></pre></div><p><strong>SDS与c语言字符串对比</strong></p><div class="code-wrapper"><pre><code class="hljs excel">redis在SDS上对c语言的字符串做了自己的设计和优化，具体优势有以下几点：（<span class="hljs-number">1</span>）c中字符串并不会记录长度，每次获取字符串的长度都会遍历得到，[时间的复杂度是O(<span class="hljs-built_in">n</span>)]，而Redis中获取字符串只要读取<span class="hljs-built_in">len</span>的值就可，[时间复杂度变为O(<span class="hljs-number">1</span>)]。（<span class="hljs-number">2</span>）c中两个字符串拼接，没有分配足够长度的内存空间就「会出现缓冲区溢出的情况」；SDS会先根据<span class="hljs-built_in">len</span>属性判断空间是否满足要求，若是空间不够，会进行空间扩展，所以不会出现缓冲区溢出的情况。（<span class="hljs-number">3</span>）SDS还提供「空间预分配」和「惰性空间释放」两种策略。在字符串分配空间时，分配的空间比实际要多，这样就能减少连续的执行字符串增长带来内存重新分配的次数。当字符串被缩短的时候，SDS也不会立即回收不适用的空间，而是通过free属性将不使用的空间记录下来，等后面使用的时候再释放。具体的空间预分配原则是：「当修改字符串后的长度<span class="hljs-built_in">len</span>小于<span class="hljs-number">1</span>MB，就会预分配和<span class="hljs-built_in">len</span>一样长度的空间，即<span class="hljs-built_in">len</span>=free；若是<span class="hljs-built_in">len</span>大于<span class="hljs-number">1</span>MB，free分配的空间大小就为<span class="hljs-number">1</span>MB」。（<span class="hljs-number">4</span>）SDS是二进制安全的，除了可以储存字符串，还可以储存二进制文件（如图片、音频，视频等文件的二进制数据）；而c中字符串是以空字符(\0)串作为结束符，一些图片中含有结束符，因此不是二进制安全的。</code></pre></div><p>应用场景: 存储图片，统计粉丝数</p><h5 id="2-List列表">2.List列表</h5><blockquote><p>quicklist: 将多个ziplist使用双向指针串起来,即满足快速插入删除,又不会出现太大的空间冗余</p></blockquote><p>底层实现：</p><p>Redis3.2之前:</p><ul class="lvl-1"><li class="lvl-4"><p>列表中元素较少和长度较小时: ziplist(压缩链表)</p></li><li class="lvl-5"><p>列表中元素角度和长度较大时: linkedlist(双向链表)</p></li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><p>Redis3.2之后：quicklist</p><h6 id="ziplist">ziplist</h6><div class="code-wrapper"><pre><code class="hljs nestedtext"><span class="hljs-attribute">是一组连续内存块组成的顺序的数据结构,能够节省空间,使用多个节点来存储数据</span><span class="hljs-attribute">**压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间**</span><span class="hljs-attribute">内存结构图如下</span><span class="hljs-punctuation">:</span><span class="hljs-attribute">| zlbytes | zltail | zllen | entry1 | entry2 ... | zlend |</span><span class="hljs-attribute">zlbytes</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4个字节大小,记录压缩列表占用内存的字节数</span><span class="hljs-attribute">zltail</span><span class="hljs-punctuation">:</span> <span class="hljs-string">4个字节大小,记录尾节点距起始位置的偏移量,用于快速定位到尾节点</span><span class="hljs-attribute">zllen</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2个字节大小,记录列表表中的节点数</span><span class="hljs-attribute">entry</span><span class="hljs-punctuation">:</span> <span class="hljs-string">列表中一个节点</span>   <span class="hljs-attribute">entry由三部分组成</span><span class="hljs-punctuation">:</span>   <span class="hljs-attribute">1.previous_entry_ength</span><span class="hljs-punctuation">:</span> <span class="hljs-string">表示前一个节点entry的长度,因为地址是连续的，可用于计算前一个节点的地址</span>   <span class="hljs-attribute">2.encoding</span><span class="hljs-punctuation">:</span> <span class="hljs-string">保存的是content的内容类型和长度</span>   <span class="hljs-attribute">3.content</span><span class="hljs-punctuation">:</span> <span class="hljs-string">保存每个节点内容</span><span class="hljs-attribute">zlend</span><span class="hljs-punctuation">:</span> <span class="hljs-string">表示压缩列表的特殊结束符号 &#x27;0xFF&#x27;</span><span class="hljs-attribute">总结</span><span class="hljs-punctuation">:</span>ziplist的优点是内存紧凑，访问效率高，缺点是更新效率低，并且数据量较大时，可能导致大量的内存复制</code></pre></div><h6 id="linkedlist">linkedlist</h6><div class="code-wrapper"><pre><code class="hljs css">和普通链表一样,指向前后节点的指针插入/修改/更新的时间复杂度:<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)查询时间复杂度: <span class="hljs-built_in">O</span>(n)链表的特性：每一个节点都有指向前一个节点和后一个节点的指针。头节点和尾节点的prev和next指针指向为null，所以链表是无环的。链表有自己长度的信息，获取长度的时间复杂度为<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)。总结：linkedlist的优点是节点修改的效率高，但是需要额外的内存开销，并且节点较多时，会产生大量的内存碎片</code></pre></div><h6 id="quicklist">quicklist</h6><div class="code-wrapper"><pre><code class="hljs">就是双向链表与压缩列表的组合,包含多个内存不连续的节点，但每个节点本身就是一个 ziplist</code></pre></div><p>应用场景:阻塞队列</p><h5 id="3-Hash哈希">3.Hash哈希</h5><blockquote><p>当field-value长度较短个数较少: ziplist,否则使用: hashtable</p><p>当hash对象可以同时满足一下两个条件时，哈希对象使用ziplist编码：</p><p>1.哈希对象保存的所有键值对的键和值的字符串长度都小于64字节</p><p>​    2.哈希对象保存的键值对数量小于512个</p></blockquote><p>底层实现方式为：hashtable,ziplist,其中hashtable的key是String类型</p><h6 id="ziplist压缩列表">ziplist压缩列表</h6><div class="code-wrapper"><pre><code class="hljs makefile">同上<span class="hljs-section">使用ziplist的优点:</span>  1.相比hashtable,ziplist结构减少了指针,节约了内存  2.相比linkedlist,ziplist存储时内存分配是连续的,查询更快<span class="hljs-section">ziplist如何实现hash存储的:</span>  将同一个键值对的两个节点紧挨着保存,保存键的节点在前,保存值的节点在后,新加入的键值对,放在压缩列表表尾</code></pre></div><h6 id="hashtable">hashtable</h6><div class="code-wrapper"><pre><code class="hljs bash">和字典底层类型类似，通过链地址法解决<span class="hljs-built_in">hash</span>冲突当对其扩容时，需要<span class="hljs-built_in">rehash</span>,但是Redis不是一次性把所有数据全部<span class="hljs-built_in">rehash</span>成功，这样会导致Redis对外停止服务,Redis内部为了解决这种情况采用【渐进式<span class="hljs-built_in">rehash</span>】,将所有<span class="hljs-built_in">rehash</span>的操作分成多步进行，直到都<span class="hljs-built_in">rehash</span>完成</code></pre></div><p>应用场景:存储用户数据,分布式生成唯一id</p><h5 id="4-Set集合">4.Set集合</h5><blockquote><p>一个无序的、自动去重的集合数据类型</p></blockquote><p>底层实现: hashtable,intset</p><h6 id="hashtable-2">hashtable</h6><div class="code-wrapper"><pre><code class="hljs arcade">同上其实是value为<span class="hljs-literal">null</span>(所有value指向同一个内部值)的<span class="hljs-built_in">hash</span>表</code></pre></div><h6 id="intset">intset</h6><div class="code-wrapper"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span><span class="hljs-keyword">set</span>叫整数集合，查询方式一般采用二分查找法，实际查询复杂度也就在log(n)使用条件: - 元素个数不少于默认值<span class="hljs-number">512</span> - 元素可以用整数表示<span class="hljs-built_in">int</span><span class="hljs-keyword">set</span>底层结构:  <span class="hljs-built_in">uint32</span>_t encoding; <span class="hljs-comment">//编码类型</span>  <span class="hljs-built_in">uint32</span>_t length;   <span class="hljs-comment">//元素的数量</span>  <span class="hljs-built_in">int8</span>_t contents [] <span class="hljs-comment">//元素的数组</span></code></pre></div><p>应用场景:去重、抽奖、共同好友、二度好友</p><h5 id="5-Zset有序集合">5.Zset有序集合</h5><blockquote><p>有序（score从小到大排序，score相同则元素字典序），自动去重的集合数据类型</p></blockquote><p>底层实现: ziplist 和skiplist(跳跃表)</p><h6 id="ziplist-2">ziplist</h6><div class="code-wrapper"><pre><code class="hljs markdown">同上满足以下两个条件使用ziplist，其他时候使用skiplist:<span class="hljs-bullet"> 1.</span> 有序集合元素数量小于128个<span class="hljs-bullet"> 2.</span> 所有元素长度小于64字节</code></pre></div><h6 id="skiplist">skiplist</h6><div class="code-wrapper"><pre><code class="hljs">跳跃表是一种有序的数据结构,每个节点维持多个指向其他节点的指针，从而能快速访问skiplist由如下几个特点： 1.有很多层组成，由上到下节点数逐渐密集，最上层的节点最稀疏，跨度也最大。 2.每一层都是一个有序链表，只扫包含两个节点，头节点和尾节点。 3.每一层的每一个节点都含有指向同一层下一个节点和下一层同一个位置节点的指针。 4.如果一个节点在某一层出现，那么该以下的所有链表同一个位置都会出现该节点。</code></pre></div><p>应用场景:在实现排序类型的业务是比较常见的</p><p>如:最热门帖子,排行榜</p><p>参考:<a href="https://zhuanlan.zhihu.com/p/148562122">Redis五种数据类型</a></p></blockquote><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">Redis</span> 中支持的数据类型到 <span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">6</span> 版本，一共有 <span class="hljs-number">9</span> 种。分别是：<span class="hljs-attribute">Binary</span>-safe strings（二进制安全字符串）<span class="hljs-attribute">Lists</span>（列表）<span class="hljs-attribute">Sets</span>（集合）<span class="hljs-attribute">Sorted</span> sets（有序集合）<span class="hljs-attribute">Hashes</span>（哈希）<span class="hljs-attribute">BitMap</span>（<span class="hljs-number">2</span>.<span class="hljs-number">2</span> 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；<span class="hljs-attribute">HyperLogLog</span>（<span class="hljs-number">2</span>.<span class="hljs-number">8</span> 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；<span class="hljs-attribute">GEO</span>（<span class="hljs-number">3</span>.<span class="hljs-number">2</span> 版新增）：存储地理位置信息的场景，比如滴滴叫车；<span class="hljs-attribute">Stream</span>（<span class="hljs-number">5</span>.<span class="hljs-number">0</span> 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据</code></pre></div><h4 id="3-操作命令">3. 操作命令</h4><h5 id="1-String">1.String</h5><div class="code-wrapper"><pre><code class="hljs mipsasm"><span class="hljs-comment"># nx不存在时才会成功,ex设置过期时间</span>set cent <span class="hljs-keyword">bingxi </span>nx ex <span class="hljs-number">20</span>set cent <span class="hljs-keyword">bingxi</span><span class="hljs-keyword"></span><span class="hljs-comment"># 取值的范围</span>getrange cent <span class="hljs-number">0</span> <span class="hljs-number">3</span><span class="hljs-comment"># 设置和过期时间</span>setex cent <span class="hljs-number">20</span> <span class="hljs-keyword">bingxi</span><span class="hljs-keyword"></span><span class="hljs-comment"># 设置新值并返回旧值</span>getset cent newbingxi<span class="hljs-comment"># 设置多个key value</span>mset <span class="hljs-built_in">k1</span> <span class="hljs-built_in">v1</span> k2 v2 k3 v3<span class="hljs-comment"># setnx key:不存在成功</span>setnx cent <span class="hljs-keyword">bingxi</span><span class="hljs-keyword"></span><span class="hljs-comment"># msetnx 设置多个:都不存在才成功</span>msetnx k11 v11 k22 v22get cent<span class="hljs-comment"># 取多个key</span>mget <span class="hljs-built_in">k1</span> k2 k3<span class="hljs-comment"># 取值的范围</span>getrange cent <span class="hljs-number">0</span> <span class="hljs-number">3</span><span class="hljs-comment"># 值里面追加</span>append cent yuan<span class="hljs-comment"># 获取key长度</span>strlen cent<span class="hljs-comment"># 数字类型值加1  incr操作是原子性的:不会被线程调度机制打断</span>incr cent<span class="hljs-comment"># 数字类型加步长</span>incrby cent <span class="hljs-number">10</span><span class="hljs-comment"># 数字类型值减1</span>decr cent<span class="hljs-comment"># 数字类型减步长</span>decrby cent <span class="hljs-number">10</span><span class="hljs-comment"># 发布订阅</span><span class="hljs-keyword">subscribe </span>channel_yuan  <span class="hljs-comment"># 订阅频道</span>publish channel_yuan helloworld <span class="hljs-comment"># 推送消息到频道</span></code></pre></div><h5 id="2-List">2.List</h5><div class="code-wrapper"><pre><code class="hljs tcl"><span class="hljs-comment"># 从左边插入一个或多个 ###从左边结果为n a u y</span>lpush cent y u a n<span class="hljs-comment"># 从右边插入一个或多个 ###从右边结果为y u a n</span>rpush cent y u a n<span class="hljs-comment"># 从左边/右边吐出一个值</span>lpop/rpop key<span class="hljs-comment"># 从key1列表右边吐出一个值,插到key2列表左边</span>rpoplpush key1 key2<span class="hljs-keyword">lrange</span> cent <span class="hljs-number">1</span> <span class="hljs-number">4</span>:取值  ### <span class="hljs-number">0</span> <span class="hljs-number">-1</span>:取所有<span class="hljs-comment"># 按照索引下表获得元素</span><span class="hljs-keyword">lindex</span> cent <span class="hljs-number">2</span><span class="hljs-comment"># 获取列表长度</span>llen cent<span class="hljs-comment"># 在列表value值后面或前面插入一个新值</span><span class="hljs-keyword">linsert</span> cent <span class="hljs-keyword">after</span>/before &lt;value&gt; &lt;new_value&gt;<span class="hljs-comment"># 将列表2的位置的值替换成newvalue</span><span class="hljs-keyword">lset</span> cent <span class="hljs-number">2</span> newvalue<span class="hljs-comment"># 删除（指定值进行删除）</span>lrem &lt;key&gt; &lt;n&gt; &lt;value&gt;</code></pre></div><h5 id="3-Hash">3.Hash</h5><div class="code-wrapper"><pre><code class="hljs gherkin"><span class="hljs-comment"># 添加数据</span>hset <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;field&gt;</span> <span class="hljs-variable">&lt;value&gt;</span><span class="hljs-comment"># 取出数据</span>hget <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;field&gt;</span><span class="hljs-comment"># 批量设置多个值</span>hmset <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;field1&gt;</span> <span class="hljs-variable">&lt;value2&gt;</span> <span class="hljs-variable">&lt;field2&gt;</span> <span class="hljs-variable">&lt;value2&gt;</span><span class="hljs-comment"># 查看hash中field是否存在</span>hexists <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;field&gt;</span><span class="hljs-comment"># 查看hash中所有field</span>hkeys <span class="hljs-variable">&lt;key&gt;</span><span class="hljs-comment"># 查看hash中所有value</span>hvals <span class="hljs-variable">&lt;key&gt;</span><span class="hljs-comment"># hash对应field加上n</span>hincrby <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;field&gt;</span> n<span class="hljs-comment"># 添加hash中对应field:当field不存在时</span>hsetnx <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;field&gt;</span> <span class="hljs-variable">&lt;value&gt;</span></code></pre></div><h5 id="4-Set">4.Set</h5><div class="code-wrapper"><pre><code class="hljs gherkin"><span class="hljs-comment"># 添加，第二次插入相同元素将被忽略</span>sadd <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;value1&gt;</span> <span class="hljs-variable">&lt;value2&gt;</span><span class="hljs-comment"># 取集合所有值</span>smembers <span class="hljs-variable">&lt;key&gt;</span><span class="hljs-comment"># 判断值是否在集合中,有返回,无返回0</span>sismember <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;value&gt;</span><span class="hljs-comment"># 返回集合元素个数</span>scard <span class="hljs-variable">&lt;key&gt;</span><span class="hljs-comment"># 删除集合中某些值</span>srem <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;value1&gt;</span> <span class="hljs-variable">&lt;value2&gt;</span><span class="hljs-comment"># 随机吐出一个值</span>spop <span class="hljs-variable">&lt;key&gt;</span><span class="hljs-comment"># 随机从集合取出n个值</span>srandmember <span class="hljs-variable">&lt;key&gt;</span> n<span class="hljs-comment"># 把集合中某个值移动到另一个集合</span>smove <span class="hljs-variable">&lt;source&gt;</span> <span class="hljs-variable">&lt;destination&gt;</span> value<span class="hljs-comment"># 返回两个集合的交集</span>sinter <span class="hljs-variable">&lt;key1&gt;</span> <span class="hljs-variable">&lt;key2&gt;</span><span class="hljs-comment"># 返回两个集合并集</span>sunion <span class="hljs-variable">&lt;key1&gt;</span> <span class="hljs-variable">&lt;key2&gt;</span><span class="hljs-comment"># 返回两个集合的差集,key1中的,不包含key2的</span>sdiff <span class="hljs-variable">&lt;key1&gt;</span> <span class="hljs-variable">&lt;key2&gt;</span></code></pre></div><h5 id="5-ZSet">5. ZSet</h5><div class="code-wrapper"><pre><code class="hljs pf"><span class="hljs-comment"># 添加元素</span>zadd <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;score1&gt;</span> <span class="hljs-variable">&lt;value1&gt;</span> <span class="hljs-variable">&lt;score2&gt;</span> <span class="hljs-variable">&lt;value2&gt;</span><span class="hljs-comment"># 取出所有值</span>zrange <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-number">0</span> -<span class="hljs-number">1</span><span class="hljs-comment"># 取出值和评分</span>zrange <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-number">0</span> -<span class="hljs-number">1</span> withscores<span class="hljs-comment"># 取出评分在min,max之间的值</span>zrangebyscore <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span>          <span class="hljs-comment"># zrevrangebyscore 从大到小</span><span class="hljs-comment"># 增加value对应的score n</span>zincrby <span class="hljs-variable">&lt;key&gt;</span> n <span class="hljs-variable">&lt;value&gt;</span><span class="hljs-comment"># 删除</span>zrem <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;value&gt;</span><span class="hljs-comment"># 统计score在min,max之间元素个数</span>zcount <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-keyword">min</span> <span class="hljs-keyword">max</span><span class="hljs-comment"># 返回value对应的排名 从0开始</span>zrank <span class="hljs-variable">&lt;key&gt;</span> <span class="hljs-variable">&lt;value&gt;</span><span class="hljs-comment"># 6.redis6的新数据类型</span>Bitmaps实现了对位的操作字符串<span class="hljs-comment"># 设置值 key 偏移量</span>setbit <span class="hljs-variable">&lt;key&gt;</span> offset <span class="hljs-number">1</span><span class="hljs-comment"># 取值</span>getbit <span class="hljs-variable">&lt;key&gt;</span> offset</code></pre></div><p>详细参考:<a href="https://www.runoob.com/w3cnote/python-redis-intro.html">redis使用介绍</a></p><h4 id="4-Redis事务">4.Redis事务</h4><blockquote><p>Redis事务(transaction)可以理解为一个打包的批量执行脚本，多个命令缓存在服务端,没有像Mysql关系型数据库事务隔离级别的概念，<strong>不能保证原子性操作,中间某条指令的失败不会导致前面已做指令的回滚,也不会造成后续的指令不做</strong></p><p><strong>特点</strong>:</p><div class="code-wrapper"><pre><code class="hljs makefile"><span class="hljs-section">&gt;1.命令执行异常情况:命令执行时候出现异常,不影响其他命令的执行。</span><span class="hljs-section">&gt;2.指令或参数错误:命令入队失败,整个事务被取消。</span></code></pre></div><p><strong>事务使用:</strong></p><div class="code-wrapper"><pre><code class="hljs mipsasm">&gt;<span class="hljs-number">1</span>.<span class="hljs-keyword">multi开启事务:redis会将后续命令逐个放入队列中，</span><span class="hljs-keyword"></span><span class="hljs-keyword">multi</span><span class="hljs-keyword"></span>&gt;<span class="hljs-number">2</span>.多个命令(入队时:命令失败,其他命令都不会执行,执行时:会跳过错误命令继续执行)SET <span class="hljs-keyword">book_name </span><span class="hljs-string">&quot;c++ plus&quot;</span>SADD tag <span class="hljs-string">&quot;C++&quot;</span> <span class="hljs-string">&quot;Programming&quot;</span> <span class="hljs-string">&quot;Mastering Series&quot;</span>&gt;<span class="hljs-number">3</span>. EXEC执行事务(执行时:命令失败,不影响其他命令)EXEC&gt;<span class="hljs-number">4</span>.<span class="hljs-keyword">discard取消事务(放弃事务中所有命令)</span><span class="hljs-keyword"></span>&gt;<span class="hljs-number">5</span>.WATCH、UNWATCH在事务中用于乐观锁在<span class="hljs-keyword">multi之前,watch监视一个(或多个) </span>key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断，EXEC会放弃队列中所有命令</code></pre></div><p><strong>为什么Redis不支持事务回滚:</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">多数事务失败是语法错误或数据结构类型错误导致的，语法错误在命令入队检查，类型错误在执行时检查,Redis为提升性能而采用这种简单事务</span></code></pre></div></blockquote><h4 id="5-管道Pipeline">5.管道Pipeline</h4><blockquote><p>管道技术(Pipeline)是客户端提供的一种批处理技术，用于一次处理多个 Redis 命令，从而提高整个交互的性能</p><p>事务：是服务端行为，事务会被缓存，一起执行</p></blockquote><blockquote><p>redis是基于客户端-服务端模型以及请求/响应协议的TCP服务,服务器进程会系统调用read()读取消息,处理完成后调用write把返回结果写入,这一过程涉及用户态到内核太的切换，管道使read/write一次处理多个命令,可以解决多个命令执行时的网络等待</p><p>通常一个请求会遵循以下步骤:</p><p>​1.客户端向服务端发送一个请求,并监听Socket返回,通常是阻塞模式,等待服务响应</p><p>​2.服务端处理命令,并将结果返回客户端</p><p>总结:如果想要在一次请求中指定多个命令，则可以使用pipline实现一次请求指定多个命令,不具有原子性,且并不是管道中命令越多越好(这个会消耗一定内存)</p></blockquote><h4 id="6-配置说明">6.配置说明</h4><div class="code-wrapper"><pre><code class="hljs tap">**redis.conf**<span class="hljs-comment"># 开启远程访问</span>注释bind 127.0.0.1关闭保护模式:protected-mode notcp-backlog<span class="hljs-number"> 511 </span>    <span class="hljs-comment"># tcp-backlog未完成三次握手队列+已完成三次握手队列(高并发提升客户端连接,改成更大的值)</span>timeout<span class="hljs-number"> 0 </span>          <span class="hljs-comment"># 连接超时配置 0为永不超时,秒为单位</span>tcp-keepalive<span class="hljs-number"> 300 </span>  <span class="hljs-comment"># 300秒执行一次心跳检测,来决定是否释放连接</span>requirepass<span class="hljs-number"> 123456 </span> <span class="hljs-comment"># 设置密码</span>conig set requirepass<span class="hljs-number"> 123456 </span>  <span class="hljs-comment"># 命令设置</span>maxclients<span class="hljs-number"> 10000 </span>   <span class="hljs-comment"># 设置客户端最大连接数</span>daemonize yes  <span class="hljs-comment"># 设置后台启动</span>slave-priority<span class="hljs-number"> 100 </span>  <span class="hljs-comment"># 哨兵模式配置优先级 值越小优先级越高</span>maxmemory 3G         <span class="hljs-comment"># 置内存大小一般为3G</span>dbfilename dump.rdb  <span class="hljs-comment"># 配置RDB持久化文件名</span>rdbcompression yes   <span class="hljs-comment"># 指定存储至本地数据库时是否压缩数据</span><span class="hljs-comment">#多实例关闭,指定端口关闭:redis-cli -p 6379 shutdown</span></code></pre></div><h4 id="7-Redis持久化方案">7.Redis持久化方案</h4><blockquote><p>Redis是基于内存的key-value数据库,数据保存在内存中,为此提供了数据持久化,防止内存数据丢失，redis启动后会加载持久化文件</p><p>分为RDB和AOF两种方式</p></blockquote><h5 id="RDB-Redis-DataBase-默认持久化方式">RDB(Redis DataBase:默认持久化方式)</h5><blockquote><p>RDB是默认持久化方式,按一定时间周期将内存中数据以快照形式保存到硬盘中(默认文件名dump.rdb)</p><p><strong>命令方式</strong></p><p>save(生产中一般不使用)：Reids save命令执行一个同步保存操作，将当前Redis实例的所有数据快照(snapshort)以RDB文件的方式保存到磁盘</p><p>bgsave：bgsave执行后，会立刻返回OK，Redis 会fork一个子进程，原来的redis主进程继续执行后续操作，新fork的子进程负责将数据保存到磁盘，然后退出</p><p>区别：</p><ul class="lvl-1"><li class="lvl-2"><p>save是<strong>同步</strong>持久化数据，而bgsave是<strong>异步</strong>持久化数据。</p></li><li class="lvl-2"><p><code>save</code>不会fork子进程，通过<strong>主进程</strong>持久化数据，会<strong>阻塞</strong>处理客户端的请求，而<code>bdsave</code>会<code>fork</code>子进程持久化数据，同时还可以处理客户端请求，高效。</p></li><li class="lvl-2"><p>save<strong>不会消耗内存</strong>，而bgsave<strong>会消耗内存</strong>。</p></li></ul><p><strong>相关配置</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 生成的文件名称</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">dbfilename dump.rdb</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 路径</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">dri /var/lib/redis</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># yes表示Redis无法写入硬盘了,关闭Redis的写操作</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">stop-writes-on-bgsave-error <span class="hljs-built_in">yes</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># yes表示持久化文件压缩</span></span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">rdbcompression <span class="hljs-built_in">yes</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># yes表示持久化之前检测完整性,会增加大约10%性能消耗</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">rdbchecksum <span class="hljs-built_in">yes</span></span></code></pre></div><p><strong>持久化触发时机:</strong></p><p>1.save:使用save命令手动触发</p><p>2.bgsave: 使用bgsave命令手动触发</p><p>3.自动化:配置文件中配置 save</p><div class="code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">save</span> <span class="hljs-number">900</span> <span class="hljs-number">1</span>    # 表示<span class="hljs-number">900</span>秒内如果至少有<span class="hljs-number">1</span>个key值变化，则进行持久化保存数据<span class="hljs-attribute">save</span> <span class="hljs-number">300</span> <span class="hljs-number">10</span>   # 表示<span class="hljs-number">300</span>秒内如果至少有<span class="hljs-number">10</span>个key值发生变化，则进行持久化<span class="hljs-attribute">save</span> <span class="hljs-number">60</span> <span class="hljs-number">10000</span> # 表示<span class="hljs-number">60</span>秒内如果至少有<span class="hljs-number">10000</span>个key值发生变化，则进行持久化</code></pre></div><p><strong>优缺点</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">RDB持久化的文件是紧凑的二进制文件</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">优点:</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.适合于大规模的数据恢复，并且还原速度快(redis服务启动后会找到dump.rdb自动恢复)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.生成多个数据文件，适合冷备份</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.fork子进程处理，对外提供的读写影响小</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">缺点:</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.占用两倍内存</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.会丢失最后一次快照数据</span></code></pre></div></blockquote><h5 id="AOF-Append-Only-File">AOF(Append Only File)</h5><blockquote><p>AOF持久化机制是以日志的形式记录Redis中的每一次的增删改操作，不会记录查询操作，以文本的形式记录，打开记录的日志文件就可以查看操作记录</p><p>默认是不开启的</p><p><strong>相关配置</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">appendonly <span class="hljs-built_in">yes</span>  <span class="hljs-comment"># 开启AOF</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">appendfilename <span class="hljs-string">&quot;appendonly.aof&quot;</span>   <span class="hljs-comment"># 配置生成的文件名</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 备份模式</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">appendfsync always/everysec/no</span></code></pre></div><p><strong>持久化触发时机</strong></p><p>AOF带来的持久化更加安全可靠，默认提供<strong>三种</strong>触发机制</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">AOF带来的持久化更加安全可靠，默认提供三种触发机制</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">no：服务器不主动调用 fsync 函数，由操作系统决定何时将缓冲区里面的命令写入到硬盘。这种模式下，服务器遭遇意外停机时，丢失命令的数量是不确定的，所以这种策略，不确定性较大，不安全。</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">always：服务器每写入一个命令，就调用一次 fsync 函数，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，也不会丢失任何已经成功执行的命令数据，但是其执行速度较慢。</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">everysec(默认)：服务器每一秒调用一次 fsync 函数，将缓冲区里面的命令写入到硬盘。这种模式下，服务器出现故障，最多只丢失一秒钟内的执行的命令数据，通常都使用它作为 AOF 配置策略</span></code></pre></div><p><strong>优缺点</strong></p><div class="code-wrapper"><pre><code class="hljs isbl">&gt;优点:<span class="hljs-number">1</span>.AOF更好保证数据不会被丢失，最多只丢失一秒内的数据<span class="hljs-number">2</span>.通过<span class="hljs-variable">fork</span>一个子进程处理持久化操作，保证了主进程不会进程<span class="hljs-variable">io</span>操作，能高效的处理客户端的请求<span class="hljs-number">3</span>.AOF的日志文件的记录可读性非常的高&gt;缺点:<span class="hljs-number">1</span>.相同数据，<span class="hljs-variable">AOF</span>文件大于<span class="hljs-function"><span class="hljs-title">RDB</span>(日志文件很多重复的操作，甚至是无效的操作，导致日志文件越来越大)</span><span class="hljs-number">2</span>.AOF恢复速度比<span class="hljs-variable">RDB</span>慢</code></pre></div><p><strong>AOF重写机制</strong></p><div class="code-wrapper"><pre><code class="hljs perl">&gt;日志文件很多无效操作,通过bgrewriteaof命令。将内存中的数据以命令的方式保存到临时文件中，同时会<span class="hljs-keyword">fork</span>出一条新进程来将文件重写。&gt;重写操作也会<span class="hljs-keyword">fork</span>一个子进程来处理重写操作，重写以内存中的数据作为重写的源，避免了操作的冗余性，保证了数据的最新</code></pre></div></blockquote><h5 id="混合持久化">混合持久化</h5><blockquote><p>在redis4.0后混合持久化（RDB+AOF）对重写的优化，4.0版本的混合持久化默认是关闭的，可以通过以下的配置开启混合持久化</p><div class="code-wrapper"><pre><code class="hljs pgsql">&gt;aof-<span class="hljs-keyword">user</span>-rdb-preamble <span class="hljs-keyword">no</span></code></pre></div><p>混合持久化结合<strong>RDB持久化</strong>和<strong>AOF持久化</strong>的优点，由于绝大部分的格式是RDB格式，加载速度快，增量数据以AOF方式保存，数据更少的丢失</p></blockquote><p>总结:</p><blockquote><p>rdb适合大规模的数据恢复，由于rdb时异快照的形式持久化数据，恢复的数据快，在一定的时间备份一次，而aof的保证数据更加完整，损失的数据只在秒内。</p><p>具体哪种更适合生产，在官方的建议中两种持久化机制同时开启</p></blockquote><h4 id="8-淘汰策略">8.淘汰策略</h4><blockquote><p>Redis提供了<strong>6种的淘汰策略</strong>，其中默认的是<code>no-eviction</code>，这6中淘汰策略如下：</p><ol><li class="lvl-3"><code>no-eviction</code>(<strong>默认策略</strong>)：不删除策略,若是内存的大小达到阀值的时候，所有申请内存的指令都会报错。</li><li class="lvl-3"><code>allkeys-lru</code>：在所有key中优先删除最近最少使用(less recently used ,LRU) 的 key。</li><li class="lvl-3"><code>volatile-lru</code>：所有<strong>设置了过期时间的key使用LRU算法</strong>进行淘汰。</li><li class="lvl-3"><code>allkeys-random</code>：所有的key使用<strong>随机淘汰</strong>的方式进行淘汰。</li><li class="lvl-3"><code>volatile-random</code>：所有<strong>设置了过期时间的key使用随机淘汰</strong>的方式进行淘汰。</li><li class="lvl-3"><code>volatile-ttl</code>：在设置了过期时间（expire ）的key中优先删除剩余时间(time to live,TTL) 短的key。。</li></ol></blockquote><h4 id="9-过期键删除策略">9.过期键删除策略</h4><blockquote><p><strong>1、</strong> 定时删除:创建一个定时器，定时的执行对key的删除操作。</p><p><strong>2、</strong> 惰性删除:每次只有再访问key的时候，才会检查key的过期时间，若是已经过期了就执行删除。</p><p><strong>3、</strong> 定期删除:每隔一段时间，就会检查删除掉过期的key。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</p></blockquote><h4 id="10-Redis集群方式">10.Redis集群方式</h4><blockquote><p>1.主从复制</p><p>2.哨兵sentinel</p><p>3.Cluster</p></blockquote><h5 id="1-主从">1.主从</h5><blockquote><p>一主二从,薪火相传,反客为主<br>master： read/wirte<br>slave:    only read<br>一般是读写分离,master负责write，slave负责read，slave要变成master需要手动slaveof加入,master挂了重启不影响主从之间关系</p><p><strong>配置流程:</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#1.创建/myredis文件夹</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#2.创建redis6379.conf,redis6380.conf,redis6381.conf</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#3.修改各自配置文件</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">include /myredis/redis.conf</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">pidfile /var/run/redis_6379.pid</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">port 6379</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">dbfilename dump6379.rdb</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#4.启动几个redis redis-server /myredis/redis6379.conf</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#5.查看主从情况:info replication</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">#6.设置主从:slaveof 127.0.0.1 6379</span></span></code></pre></div><p><strong>主从同步流程:</strong></p><div class="code-wrapper"><pre><code class="hljs crmsh">&gt;<span class="hljs-number">1</span>.<span class="hljs-literal">slave</span>启动后向<span class="hljs-literal">master</span>发送SYNC命令,<span class="hljs-literal">master</span>收到请求后,使用bgsave保存快照(RDB持久化),期间执行的些命令会被缓存起来&gt;<span class="hljs-number">2</span>.<span class="hljs-literal">master</span>将快照发给<span class="hljs-literal">slave</span>,并且继续缓存期间的写命令&gt;<span class="hljs-number">3</span>.<span class="hljs-literal">slave</span>收到快照后就会加载到内存中&gt;<span class="hljs-number">4</span>.最后<span class="hljs-literal">master</span>将缓存的命令同步给<span class="hljs-literal">slave</span></code></pre></div></blockquote><h5 id="2-哨兵模式">2.哨兵模式</h5><blockquote><p>基于主从模式,增加了哨兵来监控与自动处理故障</p><p>哨兵模式有以下的优点（功能点）：</p><ol><li class="lvl-3"><p><strong>监控</strong>：监控master和slave是否正常运行，以及哨兵之间也会相互监控</p></li><li class="lvl-3"><p><strong>自动故障恢复</strong>：当master出现故障的时候，会自动选举一个slave作为master顶上去,选举算法<strong>Raft算法</strong></p></li></ol><p><strong>配置流程:</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 1.创建sentinel.conf</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">sentinel monitor mymaster 127.0.0.1 6379 1</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">mymaster:为监控对象起的名称,1为至少有多少哨兵同意</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 2.启动哨兵</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">redis-sentinel /myredis/sentinel.conf</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 选举new master策略</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.选择优先级靠前的</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.选择偏移量最大的(偏移量指获得原主机数据最全的)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.选择runid最小的slave从服务(Redis实例启动后随机生成一个40位的runid)</span></code></pre></div><p>当哨兵启动后，会与master建立一条连接，用于订阅master的<code>_sentinel_:hello</code>频道,该频道用于获取监控该master的其它哨兵的信息。并且还会建立一条定时向master发送INFO命令获取master信息的连接</p><p><strong>当哨兵与master建立连接后，定期会向（10秒一次）master和slave发送INFO命令，若是master被标记为主观下线，频率就会变为1秒一次</strong></p></blockquote><h5 id="3-Cluster集群配置">3.Cluster集群配置</h5><blockquote><p>集群模式实现了数据的分布式存储和数据的分片,每个节点存储不同内容</p><p><strong>Redis Cluster:</strong></p><div class="code-wrapper"><pre><code class="hljs asciidoc">&gt;<span class="hljs-strong">**多主多从，去中心化**</span>：从节点作为备用，复制主节点，不做读写操作&gt;<span class="hljs-strong">**不支持处理多个key**</span>：因为数据分散在多个节点，在数据量大高并发的情况下会影响性能&gt;<span class="hljs-strong">**支持动态扩容节点**</span>：算是Rerdis Cluster最大的优点之一&gt;<span class="hljs-strong">**节点之间相互通信，相互选举，不再依赖sentinel**</span>：准确来说是主节点之间相互“监督”，保证及时故障转移</code></pre></div></blockquote><blockquote><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 集群实现扩容,集群不支持多键操作</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1. 每个redis.conf加上集群配置</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">cluster-enabled <span class="hljs-built_in">yes</span>                   <span class="hljs-comment"># 打开集群</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">cluster-config-file nodes-6379.conf   <span class="hljs-comment"># 设置节点配置文件名</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">cluster-node-timeout 15000            <span class="hljs-comment"># 设置节点失联时间单位为毫秒,超过该时间,集群自动进行主从切换</span></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.启动每个Redis实例 redis-server /myredis/redis.conf,确保nodes-xxxx.conf等文件都生成</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.在redis src下执行依赖ruby环境,实现redis实例合成集群</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 1.表示一主一从</span></span>redis-cli --cluster create --cluster-replicas  1 ip:port ip2:port2<span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 集群连接-c</span></span>redis-cli -c -p 6379<span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 查看集群状态</span></span>cluster nodes<span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># yes为某一段插槽的主从挂了,整个集群都挂掉.no为某一段插槽主从挂了,该插槽数据不能使用</span></span>cluster-require-full-coverage yes</code></pre></div><p>更多参考:<a href="https://zhuanlan.zhihu.com/p/194143258">Redis主从复制、哨兵、Cluster三种模式</a></p><p><strong>哈希槽</strong></p><div class="code-wrapper"><pre><code class="hljs dns">&gt;一个Redis Cluster包含（<span class="hljs-number">0-16384</span>)各哈希槽&gt;<span class="hljs-number">3</span>个节点:<span class="hljs-keyword">A</span>节点(<span class="hljs-number">0</span>-<span class="hljs-number">5499</span>),B节点(<span class="hljs-number">5500-10999</span>),C节点(<span class="hljs-number">11000-16383</span>)&gt;计算方式: slot=CRC16（key）/<span class="hljs-number">16384</span></code></pre></div><p><strong>集群中执行命令流程</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.客户端向集群节点发送数据命令</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.计算键key属于那个槽slot</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.槽在当前节点直接执行命令</span> 槽不在当前节点:节点向客户端返回Redirected(MOVED命令),指引客户端转向至正确的节点,并再次发送要执行的命令</code></pre></div><p><strong>Redis Cluster是如何将数据分片的?</strong></p></blockquote><h4 id="11-三大缓存问题">11.三大缓存问题</h4><blockquote><p>1.缓存穿透</p><p>2.缓存击穿</p><p>3.缓存雪崩</p></blockquote><h5 id="1-缓存穿透">1.缓存穿透</h5><blockquote><p>指访问大量缓存不存在的数据(和不存在的空值),缓存命中率降低了</p><p><strong>解决方案</strong></p><p>1.对数据库中的空值进行缓存,设置较短的过期时间(维护较简单，但是效果不好)</p><p>2.使用布隆过滤器(维护复杂，效果很好)</p><p><strong>布隆过滤器</strong></p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-operator">&gt;</span>是一个很长的二进制向量和一系列随机映射函数，用于检索一个元素是否在一个集合中<span class="hljs-operator">&gt;</span>优点：空间效率和查询时间都比一般的算法要好的多，增加和查询的时间复杂度为<span class="hljs-built_in">O</span><span class="hljs-punctuation">(</span><span class="hljs-built_in">N</span><span class="hljs-punctuation">)</span><span class="hljs-built_in">N</span>为<span class="hljs-variable">hash</span>函数个数<span class="hljs-operator">&gt;</span>缺点：是有一定的误识别率和删除困难</code></pre></div><p>Redis中的布隆过滤器底层是<strong>一个大型位数组（二进制数组）+多个无偏hash函数</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">多个<span class="hljs-built_in">hash</span>函数计算一个值的不同<span class="hljs-built_in">hash</span>，并产生多个索引值,将数组上对应的索引位置置为1</span></code></pre></div></blockquote><h5 id="2-缓存击穿">2.缓存击穿</h5><blockquote><p>冷门数据大并发，或者是一个<code>key</code>非常热点，有着大并发,当这个key失效的随间，持续的<strong>大并发</strong>就穿破缓存，直接请求数据库，瞬间对数据库的访问压力增大</p><p><strong>解决方案</strong></p><p>1.预先设置热门数据,设置较大的过期时间,实时调整</p><p>2.加锁，对第一个进来的请求执行并做缓存,接下来的就命中缓存</p></blockquote><h5 id="3-缓存雪崩">3.缓存雪崩</h5><blockquote><p>缓存雪崩 是指在某一个时间段，缓存集中过期失效。此刻无数的请求直接绕开缓存，直接请求数据库</p><p><strong>解决方案</strong></p><p>1.构建多级缓存架构和redis集群</p><p>2.分散过期时间</p><p>3.限流降级</p></blockquote><p>更多参考<a href="https://zhuanlan.zhihu.com/p/140772422">Redis缓存三大问题</a></p><h4 id="12-相关问题">12.相关问题</h4><blockquote><p><strong>Redis为什么这么快?</strong></p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-operator">&gt;</span><span class="hljs-number">1.</span><span class="hljs-variable">Redis</span> 是纯内存结构的，避免了磁盘 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 等耗时操作。<span class="hljs-operator">&gt;</span><span class="hljs-number">2.</span><span class="hljs-variable">Redis</span> 命令处理的核心模块为单线程，减少了锁竞争，以及频繁创建线程和销毁线程的代价，减少了线程上下文切换的消耗。<span class="hljs-operator">&gt;</span><span class="hljs-number">3.</span>采用了 <span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span> 多路复用机制，大大提升了并发效率。</code></pre></div><p><strong>Redis为什么是单线程?</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">CPU不是redis的瓶颈,不会有太多的计算和逻辑判断,最有可能机器内存和网络带宽</span></code></pre></div><p><strong>Redis6.0为什么引入了多线程?</strong></p><div class="code-wrapper"><pre><code class="hljs mathematica"><span class="hljs-operator">&gt;</span>瓶颈在网络<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>模块带来的<span class="hljs-variable">CPU</span>耗时<span class="hljs-operator">,</span>引入的多线程用来处理网络<span class="hljs-built_in">I</span><span class="hljs-operator">/</span><span class="hljs-built_in">O</span>部分。</code></pre></div><p><strong>是否有并发安全问题?</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">内存操作，依然是单线程运行的。redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程顺序执行，也就不存在并发安全问题</span></code></pre></div><p><strong>如何开启多线程？</strong></p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">配置文件开启多线程：</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">io-thread-do-reads <span class="hljs-built_in">yes</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">io-thread 线程数</span></code></pre></div><p><strong>如何实现优先级队列？</strong></p><div class="code-wrapper"><pre><code class="hljs fsharp"><span class="hljs-operator">&gt;</span>使用Zset,是一个有序队列,每个元素<span class="hljs-keyword">member</span>都有一个分数score</code></pre></div><p><strong>如何实现延迟队列?</strong></p><p>使用Zset，score为当前时间+时间戳</p><div class="code-wrapper"><pre><code class="hljs maxima">&gt;生产者:&gt;# <span class="hljs-built_in">key</span>为队列的名称，score为当前的时间戳+延迟时间，<span class="hljs-built_in">member</span>为消息体&gt;zadd <span class="hljs-built_in">key</span> score <span class="hljs-built_in">member</span>&gt;消费者:一直循环从redis的zset队列获取数据&gt;# <span class="hljs-built_in">key</span>为队列的名称，<span class="hljs-built_in">min</span>为<span class="hljs-number">0</span>，<span class="hljs-built_in">max</span>为当前的时间戳，<span class="hljs-built_in">limit</span>为单次个数&gt;zrangebyscore <span class="hljs-built_in">key</span> <span class="hljs-built_in">min</span> <span class="hljs-built_in">max</span> <span class="hljs-built_in">limit</span>&gt;消费删除:&gt;zrem <span class="hljs-built_in">key</span> <span class="hljs-built_in">member</span></code></pre></div></blockquote><p>参考<a href="https://cloud.tencent.com/developer/article/2315477">Redis常见面试题</a></p><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;概述&quot;&gt;概述&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;REmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库。&lt;/p&gt;
&lt;p&gt;是一个开源的使</summary>
      
    
    
    
    <category term="数据库" scheme="https://centyuan.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="Redis" scheme="https://centyuan.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>InterviewQS</title>
    <link href="https://centyuan.github.io/2023/11/15/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/InterviewQS/"/>
    <id>https://centyuan.github.io/2023/11/15/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/InterviewQS/</id>
    <published>2023-11-15T13:50:24.486Z</published>
    <updated>2023-11-16T15:08:35.766Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Python基础">Python基础</h4><h5 id="list和tuple的区别">list和tuple的区别?</h5><blockquote><p>列表是动态的，属于可变序列，可以使用<a href="https://link.zhihu.com/?target=https%3A//www.olzz.com/tag/append/">append</a>()、<a href="https://link.zhihu.com/?target=https%3A//www.olzz.com/tag/extend/">extend</a>()、<a href="https://link.zhihu.com/?target=https%3A//www.olzz.com/tag/insert/">insert</a>()、remove()和pop()等方法实现添加和<a href="https://link.zhihu.com/?target=https%3A//www.olzz.com/tag/xiugailiebiao/">修改列表</a>元素，</p><p>元组是静态的，属于不可变序列，无法增加、删除、修改元素，除非整体替换</p><p>元组比列表更轻量:<br>1.元组占用空间更小(空的小16字节，列表是动态数组，会额外预留一部分空间，元组空间大小固定)</p><p>2.元组初始化速度快5倍(python -m timeit “x=(1,2,3)” 和 python -m timeit “x=[1,2,3]”)</p><p>3.元组的访问速度快2倍</p><p>4.元组可以在字典中作为键</p><p>5.元组底层也是数组，但是做了优化(为了避免效率,避免频繁调用系统函数free,malloc向系统释放申请空间,tuple源文件中定义了一个free_list,所有申请过的，小于一定大小的元组，在释放的时候会被放进这个 <code>free_list</code> 中以供下次使用。也就是说，如果以后需要再去创建同样的 <code>tuple</code>，Python 就可以直接从缓存中载入)</p><p><a href="https://blog.csdn.net/qq_32727095/article/details/118383426">元组和列表底层实现</a></p></blockquote><h5 id="可变和不可变对象">可变和不可变对象?</h5><blockquote><p>int、float、bool、string、tuple</p><p>list、dict、set</p></blockquote><h5 id="检查一个字符串是否仅仅包含数字？">检查一个字符串是否仅仅包含数字？</h5><blockquote><p>isnumeric() 方法检测字符串是否只由数字组成。这种方法是只针对unicode对象</p><p>str = u&quot;this2009&quot;;</p><p>print(str.isnumeric())</p></blockquote><h5 id="返回一个整数的二进制">返回一个整数的二进制?</h5><blockquote><p>bin(3)</p></blockquote><h5 id="检查一个字符串是否仅仅包含字母？">检查一个字符串是否仅仅包含字母？</h5><blockquote><p>str.isalpha()</p></blockquote><h5 id="检查字符串是否只包含数字和字母">检查字符串是否只包含数字和字母?</h5><blockquote><p>str.isalnum()</p></blockquote><h5 id="remove、del和pop有什么区别">remove、del和pop有什么区别?</h5><blockquote><p>remove 删除第一个匹配的值。</p><p>del按索引删除元素。</p><p>pop 按索引删除一个元素并返回该元素。</p></blockquote><h5 id="列表随机化">列表随机化?</h5><blockquote><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">from random import shuffle</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">x = [<span class="hljs-string">&quot;keep&quot;</span>, <span class="hljs-string">&quot;the&quot;</span>,<span class="hljs-string">&quot;me&quot;</span>, <span class="hljs-string">&quot;fighting&quot;</span>]</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-built_in">print</span>(shuffle(x))</span></code></pre></div></blockquote><h5 id="is和-区别">is和==区别?</h5><blockquote><p>is运算符比==速度快</p><p>==:比较的是两个对象的值</p><p>is:比较的是两个对象是否是同对象(不会考虑子类)</p><p>isinstance:判断两个类型是否相同(isinstance),类似 type</p><p>diff:</p><p>type:不会认为子类是一种父类类型，不考虑继承关系</p><p>isinstance:会认为子类是一种父类类型，考虑继承关系</p></blockquote><h5 id="浅拷贝和深拷贝以及赋值区别">浅拷贝和深拷贝以及赋值区别?</h5><blockquote><p><strong>深拷贝</strong>⛳:复制对象后并创建了一个新对象,内存地址不一样(无论是否嵌套,都是一个独立对象),改变其中一个值不影响另一个.</p><p><strong>浅拷贝和copy,切片</strong>🎃:分两中情况</p><p>​    内置类型的构造方法或[:]以及copy.copy做的是浅拷贝</p><ul class="lvl-1"><li class="lvl-2"><p>不可变对象时(int,string,tuple):直接原对象引用(和赋值一样),内存地址一样,改变其中一个值不影响另一个(不可变对象:改变值,实际新创建了一个对象)</p></li><li class="lvl-2"><p>可变对象时:外层是新对象,内存地址不一样(改变其中一个值不影响另一个),嵌套层是引用同一对象,内存地址一样(嵌套层改变其中一个值,另一个相应改变)</p></li></ul><p><strong>赋值</strong>🍳:直接对原对象引用(不可变对象时:改变值,实际新创建了一个对象,不影响,可变对象时:改变其中一个值,外层或嵌套层相应改变)</p></blockquote><h5 id="装饰器是什么？">装饰器是什么？</h5><blockquote><p>函数装饰器:</p><p>1.装饰器是可调用函数,参数是一个函数,返回另一个函数或可调用对象，用于在源码中标记函数,已某种方式增强函数的行为</p><p>2.装饰器在加载模块时立即执行</p><div class="code-wrapper"><pre><code class="hljs pgsql">&gt;def time_calc(func):   @wraps(func)   def <span class="hljs-keyword">wrapper</span>(*args, **kwargs):       start_time = <span class="hljs-type">time</span>.perf_counter()       result = func(*args, **kwargs)       speed_time = <span class="hljs-type">time</span>.perf_counter()-start_time       <span class="hljs-keyword">return</span> result   <span class="hljs-keyword">return</span> <span class="hljs-keyword">wrapper</span></code></pre></div></blockquote><h5 id="实例方法-静态方法-类方法区别">实例方法,静态方法,类方法区别?</h5><blockquote><p><strong>三种方法获取类的属性和变量范围不同</strong></p><p>实例方法</p><p>定义：第一个参数必须是实例对象，该参数名一般约定为“self”，通过它来传递实例的属性和方法（也可以传类的属性和方法）；</p><p>调用：只能由实例对象调用。</p><p>范围：既可以获取构造函数定义的变量,也可以获取类的属性值</p><p>类方法</p><p>定义：@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”，通过它来传递类的属性和方法（不能传实例的属性和方法）；</p><p>调用：类和实例对象都可以调用。</p><p>范围: 不能获取构造函数定义的变量,可以获取类的属性值</p><p>静态方法</p><p>定义：@staticmethod。参数随意，没有“self”和“cls”参数，但是方法体中不能使用类或实例的任何属性和方法；</p><p>调用：类和实例对象都可以调用。</p><p>范围：不能获取构造函数定义的变量，也不可以获取类的属性</p><p>example:如有一个学生类和一个班级类</p><p>​    功能:执行班级人数增加的操作、获得班级的总人数</p><p>​    这个问题用类方法做比较合适，为什么？因为我实例化的是学生，</p><p>​    但是如果我从学生这一个实例中获得班级总人数，在逻辑上显然是不合理的。</p><p>​    同时，如果想要获得班级总人数，如果生成一个班级的实例也是没有必要的</p></blockquote><h5 id="参数传递是引用传递还是值传递？">参数传递是引用传递还是值传递？</h5><blockquote><p>参数的传递是赋值传递,或叫对象的引用传递</p><p>所有都是对象，新变量和原变量指向相同对象</p><p>1、如果对象是可变的，当其改变时，所有指向这个对象的变量都会改变。</p><p>2、如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响</p></blockquote><h5 id="闭包">闭包?</h5><blockquote><p>内函数运用了外函数的临时变量，并且外函数返回值是内函数的引用</p><div class="code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">outer</span>():    b = <span class="hljs-number">10</span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params">a</span>):        <span class="hljs-comment"># nonlocal b的值会一直保持</span>        <span class="hljs-keyword">nonlocal</span> b        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b的值=:&quot;</span>,b)        b +=a        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;b+=a的值:&quot;</span>,b)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;a+b的值:&quot;</span>,a + b)    <span class="hljs-keyword">return</span> inner</code></pre></div></blockquote><h5 id="魔术方法">魔术方法?</h5><div class="code-wrapper"><pre><code class="hljs markdown"><span class="hljs-section">#打印输出  </span><span class="hljs-strong">__str__</span>     <span class="hljs-strong">__repr__</span>  <span class="hljs-strong">__format__</span> <span class="hljs-section"># 删除</span><span class="hljs-strong">__del__</span><span class="hljs-section"># 是否可callable</span><span class="hljs-strong">__call__</span>   <span class="hljs-section"># len(object)时候触发</span><span class="hljs-strong">__len__</span>    <span class="hljs-section"># bool(object)时候触发</span><span class="hljs-strong">__bool__</span>   <span class="hljs-section">#  dir(object)时候触发</span><span class="hljs-strong">__dir__</span> <span class="hljs-section"># 类相关</span><span class="hljs-strong">__init__</span><span class="hljs-strong">__new__</span><span class="hljs-strong">__class__</span>:和type类似查看对象所属类<span class="hljs-strong">__dict__</span>:和dir类似，<span class="hljs-strong">__dict__</span>返回字典,有些对象没有<span class="hljs-strong">__dict__</span><span class="hljs-strong">__slots__</span>：限制实例有哪些属性<span class="hljs-section"># 迭代器相关</span><span class="hljs-strong">__iter__</span>(self)  定义当迭代容器中的元素的行为<span class="hljs-strong">__next__</span><span class="hljs-section"># 上下文管理器</span><span class="hljs-strong">__enter__</span>(self）<span class="hljs-strong">__exit__</span>(self, exctype, excvalue, traceback)<span class="hljs-section"># hash类型(不可变对象)需要实现，对象的生命周期中，散列值是不变的</span><span class="hljs-strong">__hash__</span><span class="hljs-strong">__eq__</span> 或者<span class="hljs-strong">__cmp__</span><span class="hljs-section"># 比较相关</span><span class="hljs-strong">__lt__</span>(self,other) x<span class="language-xml">&lt;y调用x.lt(y)</span><span class="language-xml">__le__(self,other) x&lt;=y调用x.le(y)</span><span class="language-xml">__eq__(self,other) x==y调用x.eq(y)</span><span class="language-xml">__ne__(self,other) x !=y 调用x.ne(y)</span><span class="language-xml">__gt__(self, other)x &gt;</span> y 调用 x.<span class="hljs-strong">**gt(y)</span><span class="hljs-strong">_<span class="hljs-emphasis">_ge_</span><span class="hljs-emphasis">_(self, other)x &gt;= y 调用 x.ge(y)</span></span><span class="hljs-emphasis"><span class="hljs-strong"># 算术运算相关</span></span><span class="hljs-emphasis"><span class="hljs-strong">_</span><span class="hljs-emphasis">_add_</span><span class="hljs-emphasis">_(self, other)           定义加法的行为：+</span></span><span class="hljs-emphasis"><span class="hljs-strong">_</span><span class="hljs-emphasis">_sub_</span><span class="hljs-emphasis">_(self, other)           定义减法的行为：-</span></span><span class="hljs-emphasis"><span class="hljs-strong">_</span><span class="hljs-emphasis">_mul_</span><span class="hljs-emphasis">_(self, other)           定义乘法的行为：*</span></span><span class="hljs-emphasis"><span class="hljs-strong"># 定义当被 int() 调用时的行为（需要返回恰当的值）</span></span><span class="hljs-emphasis"><span class="hljs-strong">_</span><span class="hljs-emphasis">_int_</span><span class="hljs-emphasis">_(self)          </span></span><span class="hljs-emphasis"><span class="hljs-strong"># 定义当被 float() 调用时的行为（需要返回恰当的值）</span></span><span class="hljs-emphasis"><span class="hljs-strong">_</span><span class="hljs-emphasis">_float_</span><span class="hljs-emphasis">_(self)        </span></span><span class="hljs-emphasis"><span class="hljs-strong"># 排序</span></span><span class="hljs-emphasis"><span class="hljs-strong">_</span><span class="hljs-emphasis">_cmp_</span><span class="hljs-emphasis">_(self,)    sorted调用时候</span></span><span class="hljs-emphasis"><span class="hljs-strong"></span></span><span class="hljs-emphasis"><span class="hljs-strong"># 找不到键</span></span><span class="hljs-emphasis"><span class="hljs-strong">_</span><span class="hljs-emphasis">_missing_</span>_</span><span class="hljs-strong"></span></code></pre></div><h5 id="垃圾回收机制和内存管理">垃圾回收机制和内存管理?</h5><blockquote><p>gc.collect()手动出发回收机制</p><p>python垃圾回收机制:</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.引用计数机制为主</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.标记-清除 mark and sweep:首先标记对象（垃圾检测），然后清除垃圾（垃圾回收）</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3.分代收集 generation collection:这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">两种机制为辅的策略</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 1.引用计数机制：(简单，实时)python里每一个东西都是对象，它们的核心就是一个结构体：PyObject</span></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(1:PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(2:对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(3:当引用计数为0时，该对象生命就结束了。</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">优点:简单,内存直接释放,实时性高,处理内存回收的时间分摊了</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">缺点:维护引用技术消耗资源,循环引用</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 2.标记清除:基于追踪回收,分为标记阶段和回收阶段,解决了容器对象可能产生的循环引用问题</span></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.基本思路是先按需分配，等到没有空闲内存的时候从寄存器和程序栈上的引用出发</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.遍历以对象为节点、以引用为边构成的图</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。)</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">把所有可以访问到的对象打上标记，然后清扫一遍内存空间，把所有没标记的对象释放。</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">缺点:必须扫描整个内存</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 3.分带回收:建立在标记-清除基础上,以空间换时间的方法提高了垃圾回收效率</span></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">将内存根据对象存活的时间分为不同的集合(年轻代:0,中年代:1,老年代:2),对应三个链表</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.新创建的对象分配在年轻代,年轻代链表总数达到上限会触发回收机制,可以回收的对象回收,不能回收的被移到中年代</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.老年代存活时间最长,甚至整个系统的生命周期</span></code></pre></div></blockquote><h5 id="GIL">GIL</h5><blockquote><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">GIL:Global interperter Lock全局解释器锁(并不是python的特性,CPython时所引入的概念,python完全可以不依赖GIL)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">1.GIL全局解释锁:每个线程在执行过程都要先获取GIL,保证同一时刻只有一个线程运行,目的是解决多线程之间数据完整性和状态同步。</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">2.因为引用计数管理内存,所以某个对象的引用计数不能被两个线程同时增加和减少,或内存泄露:GIL对线程间共享的所有数据结构加锁可以保证引用计数变量的安全性</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">3. GIL锁的释放:</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">### 1.协同式多任务处理：IO密集型的操作，在较长的或者不确定的时间(IO阻塞，python标准库中所有阻塞性I/O和time.sleep()都会释放)，没有运行Python代码的需要，线程便会让出GIL；</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment">### 2.抢占式多任务处理：CPU密集型的操作，解释器运行一段时间就主动释放GIL，这种机制叫间隔式检查（check_interval）,每隔一段时间Python解释器就会强制当前线程去释放 GIL而不需要经过正在执行代码的线程允许，这样其他线程便能运行。</span></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">(在python3中，这个时间间隔是15毫秒)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">控制多线程同步的原语:Locks、RLocks、Semaphores、Events、Conditions和Barriers(python3.2之后引入)，还有Queue,可以继承这些类，实现自己的同步控制原语。</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">4.GIL缺陷:</span>   1.抢占式多任务处理(CPU密集型):(每个线程在多个cpu交替执行:cpu调度线程唤醒-&gt;去拿GIL-&gt;没拿到-&gt;在等待:1.线程上下文切换,2.争抢不到GIL会让cpu等待,都浪费cpu时间)   2.Python的每个版本中也在逐渐改进GIL和线程调度之间的互动关系。例如先尝试持有GIL在做线程上下文切换，在IO等待时释放GIL等尝试。   3.但是无法改变的是GIL的存在使得操作系统线程调度的这个本来就昂贵的操作变得更奢侈了<span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">5.避免GIL(multiprocess替代Thread,每个进程都有独立的GIL)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">但是:它的引入会增加程序实现时线程间数据通讯和同步的困难</span></code></pre></div></blockquote><h5 id="什么是元类？">什么是元类？</h5><blockquote><p>元类是制造类的工厂</p></blockquote><h5 id="常用模块">常用模块?</h5><blockquote><p>random,re,sys,os(os.system()),json,time,datetime,hashlib,collections,pillow,threading,multiprocessing,selenium,BeautifulSoup,concurrent,django,pydantic Fastapi</p></blockquote><h5 id="进程和线程的区别">进程和线程的区别?</h5><blockquote><p>1.进程是操作系统资源分配的最小单位，而线程是程序执行的最小单位</p><p>2.进程之间相互独立，每个进程都有自己的地址空间、数据栈、文件描述符等，而线程共享进程的地址空间和资源</p><p>3.进程之间通信需要使用IPC（Inter-Process Communication）机制，如管道、消息队列、共享内存等，而线程之间可以通过共享内存、信号量、互斥量等方式进行通信。</p><p>4.进程有(执行入口/顺序执行/执行开销大),线程不能独立运行(依附于进程,执行开销小)</p><p>5.键壮性:崩溃不影响其他进程,一个线程崩溃整个进程崩掉</p><p>6.进程的创建和销毁需要较大的系统开销，而线程的创建和销毁则比较轻量级</p><p>7.切换:进程切换资源消耗大,线程切换消耗小</p><p>(进程切换需要切换页表,页表切换后,TLB失效,地址转化时需要重新查找页表。线程切换不需要切换页表)</p></blockquote><h5 id="列表底层原理实现">列表底层原理实现?</h5><blockquote><p>Python的列表是一种动态数组,数组中每个元素都一个指向存储真实数据的指针,扩容时会重新分配一块更大的内存空间,并将原来的值复制到新内存空间,这种实现方式使列表的随机访问非常高效，但在插入和删除元素时需要移动大量的数据，效率较低</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">typedef struct &#123;</span>   PyObejct_VAR_HEAD   PyObject **ob_item;   Py_ssize_t allocated;<span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&#125;PyListObject</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">ob_item:指向列表对象的指针数组</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">allocated:申请内存的槽的个数(通常分配的槽的大小大于列表的大小,为了避免每次列表添加元素的时候调用分配内存的函数扩容)</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">append:追加元素的操作平均复杂度为  O(1)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">insert:插入操作平均复杂度为 O(n)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">pop：取出最后一个的平均复杂度为 O(1)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">remove: 删除指定元素的复杂度为 O(n)</span></code></pre></div></blockquote><h5 id="字典底层实现原理">字典底层实现原理?</h5><blockquote><p>Python中字典是通过hash表来实现的</p><div class="code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">typedef struct &#123;</span>   Py_ssize_t me_hash;   PyObject *me_key;   PyObject *me_value;<span class="hljs-meta prompt_">&gt;</span><span class="language-bash">&#125;PyDictEntry;</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">存储内容有 <span class="hljs-built_in">hash</span>，key，value</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">字典是否有序?</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Python3.5以前:字典是不能保证插入顺序的，底层使用一个二维数组</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">创建字典: 初始化一个二维数组,8行3列,字典的键值对数量超过当前数组的2/3时，数组会进行扩容</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">往字典添加一个值: <span class="hljs-built_in">hash</span>(key)&amp;掩码 或 <span class="hljs-built_in">hash</span>(key)后的值对8取余数，余数为二维数组的索引，二维数组记录该索引(<span class="hljs-built_in">hash</span>值，key的内存地址,vlaue的内存地址)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">取值: <span class="hljs-built_in">hash</span>(key)后的值对8取余数，余数为二维数组的索引</span><span class="hljs-meta prompt_"></span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">Python3.6后:字典插入有序了，且占用内存空间变小了,底层使用两个一维数组</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">创建字典:</span> <span class="hljs-meta prompt_">&gt;</span><span class="language-bash">indices = [None,None,None,None,None，None，None，None]</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">entries = 二维数组(<span class="hljs-built_in">hash</span>值，key的内存地址,value的内存地址)</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">往字典添加一个值: <span class="hljs-built_in">hash</span>后取余后的值为indices上的索引,在该索引上记录entries存值的索引</span><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">插入新的数据只在entries后面添加数据,确保了插入的顺序</span></code></pre></div></blockquote><h5 id="设计模式">设计模式?</h5><blockquote><blockquote><ul class="lvl-2"><li class="lvl-2"><p>创建型模式（5种）：<strong>工厂方法模式</strong>、<strong>抽象工厂模式</strong>、<strong>创建者模式</strong>、（原型模式）、<strong>单例模式</strong></p></li><li class="lvl-2"><p>结构型模式（7种）：<strong>适配器模式</strong>、<strong>桥模式</strong>、组合模式、装饰模式、外观模式、享元模式、<strong>代理模式</strong></p></li><li class="lvl-2"><p>行为型模式（11种）：解释器模式、<strong>责任链模式</strong>、命令模式、迭代器模式、中介者模式、备忘录模式、<strong>观察者模式</strong>、状态模式、<strong>策略模式</strong>、访问者模式、<strong>模版方法模式</strong></p></li></ul></blockquote><p>参考:<a href="https://centyuan.github.io/2023/11/14/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></p></blockquote><h5 id="单例模式">单例模式?</h5><blockquote><ol><li class="lvl-3"><p>import 使用模块</p></li><li class="lvl-3"><p>使用装饰器</p></li><li class="lvl-4"><p>使用new，加锁解决多线程问题</p></li><li class="lvl-3"><p>使用元类，metaclass</p></li></ol></blockquote><h5 id="分布式系统中的单例任务是怎么实现的">分布式系统中的单例任务是怎么实现的?</h5><blockquote><p>把这个单路模式序列化并存储到外部共享存储区(如Redis),进程在使用这个单例模式时候,读取出来并反序列化成对象</p></blockquote><h4 id="框架">框架</h4><h5 id="django生命周期">django生命周期?</h5><blockquote><ul class="lvl-1"><li class="lvl-2"><p><strong>请求阶段</strong>：当用户发送请求时，Django会根据URL路由规则找到对应的视图函数，并将请求传递给该函数处理。</p></li><li class="lvl-2"><p><strong>视图函数阶段</strong>：视图函数会处理请求，并返回一个HttpResponse对象，该对象包含了要返回给用户的内容。</p></li><li class="lvl-2"><p><strong>中间件阶段</strong>：在视图函数处理请求之前或之后，Django会执行中间件的相应方法，例如处理请求头、身份验证、缓存等。</p></li><li class="lvl-2"><p><strong>模板渲染阶段</strong>：如果视图函数返回的是一个模板，Django会将模板渲染成HTML页面，并将其包含在HttpResponse对象中返回给用户。</p></li><li class="lvl-2"><p><strong>响应阶段</strong>：最后，Django会将HttpResponse对象发送给用户的浏览器，完成请求响应过程。</p></li></ul><p>在整个生命周期中，Django还会执行一些其他的操作，例如数据库查询、缓存读写、日志记录等。</p></blockquote><h5 id="ORM有哪些">ORM有哪些?</h5><blockquote><p>Django orm</p><p>Sqlalchemy</p><p>Turtoise</p></blockquote><h4 id="数据库">数据库</h4><h5 id="如何优化慢查询">如何优化慢查询?</h5><h5 id="pg与mysql的区别有哪些？">pg与mysql的区别有哪些？</h5><blockquote><ul class="lvl-1"><li class="lvl-2"><p>数据类型：PG支持更多的数据类型，如数组、JSON、XML等，而MySQL则不支持。</p></li><li class="lvl-2"><p>ACID支持：PG支持完全的ACID（原子性、一致性、隔离性、持久性）事务，而MySQL只支持部分ACID事务。</p></li><li class="lvl-2"><p>复杂查询：PG支持更复杂的查询，如递归查询、窗口函数等，而MySQL则不支持。</p></li><li class="lvl-2"><p>存储引擎：MySQL支持多种存储引擎，如InnoDB、MyISAM等，而PG只支持一种存储引擎。</p></li><li class="lvl-2"><p>性能：在高并发、大数据量的情况下，PG的性能比MySQL更好。</p></li><li class="lvl-2"><p>开源许可证：PG采用的是BSD许可证，而MySQL采用的是GPL许可证</p></li></ul><p>总的来说，PG更适合处理复杂的数据结构和高并发的场景，而MySQL则更适合处理简单的数据结构和小型应用</p></blockquote><script type="text&#x2F;javascript" src="https://unpkg.com/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://unpkg.com/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://unpkg.com/hexo-simple-mindmap@0.8.0/dist/mindmap.min.css">]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;Python基础&quot;&gt;Python基础&lt;/h4&gt;
&lt;h5 id=&quot;list和tuple的区别&quot;&gt;list和tuple的区别?&lt;/h5&gt;
&lt;blockquote&gt;
&lt;p&gt;列表是动态的，属于可变序列，可以使用&lt;a href=&quot;https://link.zhihu.com</summary>
      
    
    
    
    <category term="Python从入门到放弃" scheme="https://centyuan.github.io/categories/Python%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83/"/>
    
    
    <category term="Python" scheme="https://centyuan.github.io/tags/Python/"/>
    
  </entry>
  
</feed>
